

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ensembler.potentials.OneD &mdash; Ensembler beta documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Ensembler
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_source/index.html">Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ensembler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>ensembler.potentials.OneD</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ensembler.potentials.OneD</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module: Potential</span>
<span class="sd">This module shall be used to implement subclasses of Potential. This module contains all available potentials.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">t</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">const</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">ensembler.potentials._basicPotentials</span> <span class="kn">import</span> <span class="n">_potential1DCls</span><span class="p">,</span> <span class="n">_potential1DClsPerturbed</span>
<span class="kn">from</span> <span class="nn">ensembler.util.ensemblerTypes</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">systemCls</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SIMPLE POTENTIALS</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="harmonicOscillatorPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.harmonicOscillatorPotential">[docs]</a><span class="k">class</span> <span class="nc">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of an 1D  harmonic oscillator potential following hooke&#39;s law</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Harmonic Oscillator&quot;</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">y_shift</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;k r_0 r Voffset&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">x_shift</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">y_shift</span>

<div class="viewcode-block" id="harmonicOscillatorPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.harmonicOscillatorPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the 1D harmonic oscillator</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: float, optional</span>
<span class="sd">            force constant, defaults to 1.0</span>
<span class="sd">        x_shift: float, optional</span>
<span class="sd">            shift of the minimum in the x Axis, defaults to 0.0</span>
<span class="sd">        y_shift: float, optional</span>
<span class="sd">            shift on the y Axis, defaults to 0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_shift</span><span class="p">:</span> <span class="n">x_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_shift</span><span class="p">:</span> <span class="n">y_shift</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="wavePotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.wavePotential">[docs]</a><span class="k">class</span> <span class="nc">wavePotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Simple 1D wave potential consisting of a cosine function with given multiplicity, that can be shifted and elongated</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Wave Potential&quot;</span>
    <span class="n">amplitude</span><span class="p">,</span> <span class="n">phase_shift</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;A w r Voff m&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">multiplicity</span> <span class="o">*</span> <span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">phase_shift</span><span class="p">))</span> <span class="o">+</span> <span class="n">y_shift</span>

<div class="viewcode-block" id="wavePotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.wavePotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">multiplicity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">phase_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">y_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">radians</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the 1D wave potential function</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amplitude: float, optional</span>
<span class="sd">            absolute min and max of the potential, defaults to 1.0</span>
<span class="sd">        multiplicity: float, optional</span>
<span class="sd">            amount of minima in one phase, defaults to 1.0</span>
<span class="sd">        phase_shift: float, optional</span>
<span class="sd">            shift of the potential on the x Axis, defaults to 0.0</span>
<span class="sd">        y_offset: float, optional</span>
<span class="sd">            shift on the y Axis, defaults to 0.0</span>
<span class="sd">        radians: bool, optional</span>
<span class="sd">            in radians or degrees, defaults to False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">:</span> <span class="n">amplitude</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiplicity</span><span class="p">:</span> <span class="n">multiplicity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_shift</span><span class="p">:</span> <span class="n">phase_shift</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">y_shift</span><span class="p">:</span> <span class="n">y_shift</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_radians</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span></div>

    <span class="c1"># OVERRIDE</span>
<div class="viewcode-block" id="wavePotential._update_functions"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.wavePotential._update_functions">[docs]</a>    <span class="k">def</span> <span class="nf">_update_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _update_functions</span>
<span class="sd">            calculates the current energy and derivative of the energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tmp_Vfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dVdpfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span></div>

<div class="viewcode-block" id="wavePotential.set_degrees"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.wavePotential.set_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">set_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets output to either degrees or radians</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degrees: bool, optional,</span>
<span class="sd">            if True, output will be given in degrees, otherwise in radians, default: True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radians</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">degrees</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">degrees</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">positions</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_Vfunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">positions</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dVdpfunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_radians</span><span class="p">(</span><span class="n">radians</span><span class="o">=</span><span class="ow">not</span> <span class="n">degrees</span><span class="p">)</span></div>

<div class="viewcode-block" id="wavePotential.set_radians"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.wavePotential.set_radians">[docs]</a>    <span class="k">def</span> <span class="nf">set_radians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets output to either degrees or radians</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radians: bool, optional,</span>
<span class="sd">            if True, output will be given in radians, otherwise in degree, default: True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radians</span> <span class="o">=</span> <span class="n">radians</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">radians</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_Vfunc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dVdpfunc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_degrees</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="ow">not</span> <span class="n">radians</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="coulombPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.coulombPotential">[docs]</a><span class="k">class</span> <span class="nc">coulombPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coulomb potential representing the pairwise electrostatic interaction of two charged particles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Coulomb Potential&quot;</span>
    <span class="n">charge1</span><span class="p">,</span> <span class="n">charge2</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">electric_permetivity</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;q1 q2 r e&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="p">(</span><span class="n">charge1</span> <span class="o">*</span> <span class="n">charge2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">position</span> <span class="o">*</span> <span class="n">electric_permetivity</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<div class="viewcode-block" id="coulombPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.coulombPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">q2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the Coulomb potential</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q1: int, optional</span>
<span class="sd">            Charge of atom 1, defaults to 1</span>
<span class="sd">        q2: int, optional</span>
<span class="sd">            Charge of atom 2, defaults to 1</span>
<span class="sd">        epsilon: int, optional</span>
<span class="sd">            Electric Permetivitty, defaults to 1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">charge1</span><span class="p">:</span> <span class="n">q1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge2</span><span class="p">:</span> <span class="n">q2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">electric_permetivity</span><span class="p">:</span> <span class="n">epsilon</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="lennardJonesPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.lennardJonesPotential">[docs]</a><span class="k">class</span> <span class="nc">lennardJonesPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Lennard Jones potential representing the pairwise van-der-Waals interaction of two particles</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Lennard Jones Potential&quot;</span>
    <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;s e r_0 V_off r&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="p">((</span><span class="n">sigma</span> <span class="o">/</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">x_shift</span><span class="p">))</span> <span class="o">**</span> <span class="mi">12</span> <span class="o">-</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">/</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">x_shift</span><span class="p">))</span> <span class="o">**</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="n">y_shift</span>

<div class="viewcode-block" id="lennardJonesPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.lennardJonesPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the Lennard-Jones Potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma: float, optional</span>
<span class="sd">            x - Position of the minimum, defaults to 1.5</span>
<span class="sd">        epsilon: float, optional</span>
<span class="sd">            y - position of minimum, defaults to 2</span>
<span class="sd">        x_shift: float, optional</span>
<span class="sd">            shift of potential on x Axis, defaults to 0</span>
<span class="sd">        y_shift: int, optional</span>
<span class="sd">            shift of potential on y Axis, defaults to 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">:</span> <span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span> <span class="n">epsilon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_shift</span><span class="p">:</span> <span class="n">x_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_shift</span><span class="p">:</span> <span class="n">y_shift</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="lennardJonesForceFieldPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.lennardJonesForceFieldPotential">[docs]</a><span class="k">class</span> <span class="nc">lennardJonesForceFieldPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This is a forcefield like implementation of  a lennard Jones Potential</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Lennard Jones Potential&quot;</span>
    <span class="n">c6</span><span class="p">,</span> <span class="n">c12</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;c6 c12 r_0 V_off r&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="p">(</span><span class="n">c12</span> <span class="o">/</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">x_shift</span><span class="p">)</span> <span class="o">**</span> <span class="mi">12</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c6</span> <span class="o">/</span> <span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">x_shift</span> <span class="o">**</span> <span class="mi">6</span><span class="p">))</span> <span class="o">+</span> <span class="n">y_shift</span>

<div class="viewcode-block" id="lennardJonesForceFieldPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.lennardJonesForceFieldPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c6</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">c12</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the Lennard-Jones Field Potential</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c6: float, optional</span>
<span class="sd">            prefactor of the interaction term that scales with **6, defaults to 0.2</span>
<span class="sd">        c12: float, optional</span>
<span class="sd">            prefactor of the interaction term that scales with **12, defaults to 0.0001</span>
<span class="sd">        x_shift: float, optional</span>
<span class="sd">            shift of potential on x Axis, defaults to 0</span>
<span class="sd">        y_shift: float, optional</span>
<span class="sd">            shift of potential on y Axis, defaults to 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c6</span><span class="p">:</span> <span class="n">c6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c12</span><span class="p">:</span> <span class="n">c12</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_shift</span><span class="p">:</span> <span class="n">x_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_shift</span><span class="p">:</span> <span class="n">y_shift</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="doubleWellPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.doubleWellPotential">[docs]</a><span class="k">class</span> <span class="nc">doubleWellPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This is an implementation of a double Well potential</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Double Well&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;a b V_max r&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vmax</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">**</span> <span class="mi">4</span><span class="p">))</span> <span class="o">*</span> <span class="p">((</span><span class="n">position</span> <span class="o">-</span> <span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

<div class="viewcode-block" id="doubleWellPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.doubleWellPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vmax</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">a</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the double well Potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Vmax: int, optional</span>
<span class="sd">            Maximal barrier between minima, defaults to 5</span>
<span class="sd">        a: int, optional</span>
<span class="sd">            defines x position of the minimum of the first well, defaults to -1</span>
<span class="sd">        b: int, optional</span>
<span class="sd">            defines x position of the minimum of the second well, defaults to 1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Vmax</span><span class="p">:</span> <span class="n">Vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="fourWellPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.fourWellPotential">[docs]</a><span class="k">class</span> <span class="nc">fourWellPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Unperturbed four well potential</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Four Well Potential&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">ah</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">Vmax</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;a ah b bh c ch d dh V_max r&quot;</span><span class="p">)</span>

    <span class="n">V_functional</span> <span class="o">=</span> <span class="o">-</span><span class="n">Vmax</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ah</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">bh</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
        <span class="o">-</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ch</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dh</span><span class="p">))</span>

<div class="viewcode-block" id="fourWellPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.fourWellPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Vmax</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mf">9.0</span><span class="p">,</span> <span class="n">ah</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">bh</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dh</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of the four well Potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Vmax: float, optional</span>
<span class="sd">            scaling of the whole potential</span>
<span class="sd">        a: float, optional</span>
<span class="sd">            x position of the minimum of the first well</span>
<span class="sd">        b: float, optional</span>
<span class="sd">            x position of the minimum of the second well</span>
<span class="sd">        c: float, optional</span>
<span class="sd">            x position of the minimum of the third well</span>
<span class="sd">        d: float, optional</span>
<span class="sd">            x position of the minimum of the fourth well</span>
<span class="sd">        ah: str, optional</span>
<span class="sd">            ah*Vmax = y position of the first well</span>
<span class="sd">        bh: str, optional</span>
<span class="sd">            bh*Vmax = y position of the second well</span>
<span class="sd">        ch: str, optional</span>
<span class="sd">            ch*Vmax = y position of the third well</span>
<span class="sd">        dh: str, optional</span>
<span class="sd">            dh*Vmax = y position of the fourth well</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Vmax</span><span class="p">:</span> <span class="n">Vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ah</span><span class="p">:</span> <span class="n">ah</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bh</span><span class="p">:</span> <span class="n">bh</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">ch</span><span class="p">:</span> <span class="n">ch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dh</span><span class="p">:</span> <span class="n">dh</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="gaussPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.gaussPotential">[docs]</a><span class="k">class</span> <span class="nc">gaussPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Gaussian like potential, usually used for metadynamics</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Gaussian Potential&quot;</span>

    <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;mu sigma A r&quot;</span><span class="p">)</span>

    <span class="n">V_functional</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">position</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

<div class="viewcode-block" id="gaussPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.gaussPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of a 1D Gauss Potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A: float, optional</span>
<span class="sd">            scaling of the gauss function, defaults to 1.</span>
<span class="sd">        mu: float, optional</span>
<span class="sd">            mean of the gauss function, defautls to 0.</span>
<span class="sd">        sigma: float, optional</span>
<span class="sd">            standard deviation of the gauss function, defaults to 1.</span>

<span class="sd">                TODO: improve numerical stablility</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">:</span> <span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">:</span> <span class="n">sigma</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>

<div class="viewcode-block" id="gaussPotential._update_functions"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.gaussPotential._update_functions">[docs]</a>    <span class="k">def</span> <span class="nf">_update_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is needed to simplyfiy the symbolic equation on the fly and to calculate the position derivateive.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos_functional</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>  <span class="c1"># not always working!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span></div></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    COMBINED POTENTIALS</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="torsionPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.torsionPotential">[docs]</a><span class="k">class</span> <span class="nc">torsionPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Torsion potential that represents the energy potential of a torsion angle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Torsion Potential&quot;</span>

    <span class="n">phase</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">wavePotentials</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;i N&quot;</span><span class="p">)</span>  <span class="c1"># sum symbols</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">wavePotentials</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>

<div class="viewcode-block" id="torsionPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.torsionPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavePotentials</span><span class="o">=</span><span class="p">[</span><span class="n">wavePotential</span><span class="p">(),</span> <span class="n">wavePotential</span><span class="p">(</span><span class="n">multiplicity</span><span class="o">=</span><span class="mi">3</span><span class="p">)],</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__</span>
<span class="sd">            This is the Constructor of a Torsion Potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wavePotentials: list of two potentialTypes, optionel</span>
<span class="sd">            Torsion potential use the wave potential class to generate its potential, default to</span>
<span class="sd">            [wavePotential(), wavePotential(multiplicity=3)]</span>
<span class="sd">        radians: bool, optional</span>
<span class="sd">            set potential to radians or degrees, defaults to False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        initializes torsions Potential</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">wavePotentials</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wavePotentials</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="s2">&quot;wave_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">):</span> <span class="n">wave</span><span class="o">.</span><span class="n">V</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">wave</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wavePotentials</span><span class="p">)},</span>
                          <span class="o">**</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">wavePotentials</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wavePotentials</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;wave_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wavePotentials</span><span class="p">))])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavePotentials</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_radians</span><span class="p">(</span><span class="n">radians</span><span class="o">=</span><span class="n">radians</span><span class="p">)</span></div>

    <span class="c1"># OVERRIDE</span>
<div class="viewcode-block" id="torsionPotential._update_functions"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.torsionPotential._update_functions">[docs]</a>    <span class="k">def</span> <span class="nf">_update_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _update_functions</span>
<span class="sd">            calculates the current energy and derivative of the energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tmp_Vfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dVdpfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span></div>

<div class="viewcode-block" id="torsionPotential.set_degrees"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.torsionPotential.set_degrees">[docs]</a>    <span class="k">def</span> <span class="nf">set_degrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets output to either degrees or radians</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        degrees: bool, optional,</span>
<span class="sd">            if True, output will be given in degrees, otherwise in radians, default: True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radians</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">degrees</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">degrees</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">positions</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_Vfunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">positions</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dVdpfunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_radians</span><span class="p">(</span><span class="n">radians</span><span class="o">=</span><span class="ow">not</span> <span class="n">degrees</span><span class="p">)</span></div>

<div class="viewcode-block" id="torsionPotential.set_radians"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.torsionPotential.set_radians">[docs]</a>    <span class="k">def</span> <span class="nf">set_radians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets output to either degrees or radians</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        radians: bool, optional,</span>
<span class="sd">            if True, output will be given in radians, otherwise in degree, default: True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radians</span> <span class="o">=</span> <span class="n">radians</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">radians</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_Vfunc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmp_dVdpfunc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_degrees</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="ow">not</span> <span class="n">radians</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="forceField"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.forceField">[docs]</a><span class="k">class</span> <span class="nc">forceField</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Force field potential energy that combines Coulomb, Lennard Jones and Torsion potentials</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented yet, but this class shall be used to link N potential terms! &quot;</span><span class="p">)</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multi State Potentials - PERTURBED POTENTIALS</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="linearCoupledPotentials"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.linearCoupledPotentials">[docs]</a><span class="k">class</span> <span class="nc">linearCoupledPotentials</span><span class="p">(</span><span class="n">_potential1DClsPerturbed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear Coupled Potential combines two potential as linear combinations,</span>
<span class="sd">    $ V_{\lambda} = \lambda * V_a + (1-\lambda)*V_b $</span>

<span class="sd">    This variant of coupling states is used for example in FEP, TI or BAR approaches.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Linear Coupled System&quot;</span>
    <span class="n">lam</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;λ r&#39;</span><span class="p">)</span>
    <span class="n">Va</span><span class="p">,</span> <span class="n">Vb</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;V_a&quot;</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;V_b&quot;</span><span class="p">))</span>
    <span class="n">coupling</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">Va</span> <span class="o">+</span> <span class="n">lam</span> <span class="o">*</span> <span class="n">Vb</span>

<div class="viewcode-block" id="linearCoupledPotentials.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.linearCoupledPotentials.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Va</span><span class="p">:</span> <span class="n">_potential1DCls</span> <span class="o">=</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
                 <span class="n">Vb</span><span class="p">:</span> <span class="n">_potential1DCls</span> <span class="o">=</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">11.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
                 <span class="n">lam</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            __init__</span>
<span class="sd">                This constructor builds a linear combination of Va and Vb potentials, with lam as a cofactor.</span>
<span class="sd">                Linear Coupled Potentials, like in FEP or TI simulations.]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Va: _potential1DCls, optional</span>
<span class="sd">            Potential A that is mixed to the new potential.</span>
<span class="sd">        Vb:  _potential1DCls, optional</span>
<span class="sd">            Potential B that is mixed to the new potential.</span>
<span class="sd">        lam: float</span>
<span class="sd">            lam is representing the lambda variable</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Va</span><span class="p">:</span> <span class="n">Va</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vb</span><span class="p">:</span> <span class="n">Vb</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Va</span><span class="p">:</span> <span class="n">Va</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vb</span><span class="p">:</span> <span class="n">Vb</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">:</span> <span class="n">lam</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="exponentialCoupledPotentials"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.exponentialCoupledPotentials">[docs]</a><span class="k">class</span> <span class="nc">exponentialCoupledPotentials</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation of exponential Coupling is the symbolic variant of the more robust eds potential implementation.</span>
<span class="sd">    Here N-states are coupled by the log-sum-exp resulting in a new reference state $V_R$,</span>

<span class="sd">    $V_R = -1/{\beta} * \ln(\sum_i^Ne^(-\beta*s*(V_i-E^R_i)))$</span>

<span class="sd">    This potential coupling is for example used in EDS.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;exponential Coupled System&quot;</span>
    <span class="n">position</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">eoffA</span><span class="p">,</span> <span class="n">eoffB</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;r s T eoffI eoffJ&#39;</span><span class="p">)</span>
    <span class="n">Va</span><span class="p">,</span> <span class="n">Vb</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;V_a&quot;</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;V_b&quot;</span><span class="p">))</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">gas_constant</span> <span class="o">/</span> <span class="mf">1000.0</span> <span class="o">*</span> <span class="n">temp</span>
    <span class="n">coupling</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">Vb</span> <span class="o">-</span> <span class="n">eoffA</span><span class="p">)</span> <span class="o">+</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">Va</span> <span class="o">-</span> <span class="n">eoffB</span><span class="p">))</span>

<div class="viewcode-block" id="exponentialCoupledPotentials.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.exponentialCoupledPotentials.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Va</span><span class="p">:</span> <span class="n">_potential1DCls</span> <span class="o">=</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
                 <span class="n">Vb</span><span class="p">:</span> <span class="n">_potential1DCls</span> <span class="o">=</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">11.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
                 <span class="n">eoffA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eoffB</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">temp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">298</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            __init__</span>
<span class="sd">                This constructor is building a exponential coupled Potential out of two given end-states.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Va: _potential1DCls, optional</span>
<span class="sd">            potential function of state A (default: harmonic oscillator)</span>
<span class="sd">        Vb: _potential1DCls, optional</span>
<span class="sd">            potential function of state B (default: harmonic oscillator)</span>
<span class="sd">        eoffA: float, optional</span>
<span class="sd">            Energy offset of state A in the reference potential (default: 0)</span>
<span class="sd">        eoffB: float, optional</span>
<span class="sd">            Energy offset of state B in the reference potential (default: 0)</span>
<span class="sd">        s: float, optional</span>
<span class="sd">            smoothing factor of the reference potential (default: 1.0)</span>
<span class="sd">        temp: float, optional</span>
<span class="sd">            Temperature of the reference state. (default: 298)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Va</span><span class="p">:</span> <span class="n">Va</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vb</span><span class="p">:</span> <span class="n">Vb</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Va</span><span class="p">:</span> <span class="n">Va</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vb</span><span class="p">:</span> <span class="n">Vb</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eoffA</span><span class="p">:</span> <span class="n">eoffA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eoffB</span><span class="p">:</span> <span class="n">eoffB</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">temp</span><span class="p">:</span> <span class="n">temp</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupling</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nStates</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="exponentialCoupledPotentials.set_s"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.exponentialCoupledPotentials.set_s">[docs]</a>    <span class="k">def</span> <span class="nf">set_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            set_s</span>
<span class="sd">                sets a new s-value. (please only use this function to change s)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s: float</span>
<span class="sd">            the new sval.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span></div>

<div class="viewcode-block" id="exponentialCoupledPotentials.set_Eoff"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.exponentialCoupledPotentials.set_Eoff">[docs]</a>    <span class="k">def</span> <span class="nf">set_Eoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eoffA</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eoffB</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            set_Eoff</span>
<span class="sd">                set the energy offsets for the states in the reference state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eoffA: float, optional</span>
<span class="sd">            set a new offset for state A (default: None)</span>
<span class="sd">        eoffB: float, optional</span>
<span class="sd">            set a new E offset for state B in the reference state (default: None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eoffA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">eoffA</span><span class="p">:</span> <span class="n">eoffA</span><span class="p">})</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eoffB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">eoffB</span><span class="p">:</span> <span class="n">eoffB</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="envelopedPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential">[docs]</a><span class="k">class</span> <span class="nc">envelopedPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation of exponential Coupling for EDS is a more numeric robust and variable implementation, it allows N states.</span>
<span class="sd">    Therefore the computation of energies and the deviation is not symbolic.</span>

<span class="sd">    Here N-states are coupled by the log-sum-exp resulting in a new reference state $V_R$,</span>

<span class="sd">    $V_R = -1/{\beta} * \ln(\sum_i^Ne^(-\beta*s*(V_i-E^R_i)))$</span>

<span class="sd">    This potential coupling is for example used in EDS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Enveloping Potential&quot;</span>

    <span class="n">T</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;T kb r&quot;</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">kb</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>

    <span class="n">Vis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;V_i&quot;</span><span class="p">])</span>
    <span class="n">Eoffis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;Eoff_i&quot;</span><span class="p">])</span>
    <span class="n">sis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;s_i&quot;</span><span class="p">])</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">nStates</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;i N&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Vis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Eoffis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nStates</span><span class="p">)))</span>

<div class="viewcode-block" id="envelopedPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V_is</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">_potential1DCls</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">harmonicOscillatorPotential</span><span class="p">(),</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">x_shift</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
                 <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">eoff</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            __init__</span>
<span class="sd">                This function constructs a enveloped potential, enveloping all given states.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        V_is: List[_potential1DCls], optional</span>
<span class="sd">            The states(potential classes) to be enveloped (default: [harmonicOscillatorPotential(), harmonicOscillatorPotential(x_shift=3)])</span>

<span class="sd">        s: float, optional</span>
<span class="sd">            the smoothing parameter, lowering the barriers between the states</span>
<span class="sd">        eoff: List[float], optional</span>
<span class="sd">            the energy offsets of the individual states in the reference potential. These can be used to allow a more uniform sampling. (default: seta ll to 0)</span>
<span class="sd">        T: float, optional</span>
<span class="sd">            the temperature of the reference state (default: 1 = T)</span>
<span class="sd">        kb: float, optional</span>
<span class="sd">            the boltzman constant (default: 1 = kb)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">:</span> <span class="n">kb</span><span class="p">}</span>
        <span class="n">nStates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V_is</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Eoff_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_V_is</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>

        <span class="c1"># for calculate implementations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span> <span class="o">=</span> <span class="n">V_is</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span> <span class="o">=</span> <span class="n">eoff</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nStates</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">V_is</span><span class="p">))</span></div>

<div class="viewcode-block" id="envelopedPotential._initialize_functions"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential._initialize_functions">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        build the symbolic functionality.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for sympy Sympy Updates - Check!:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;state_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">Eoffis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Eoff_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">sis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Eoffis</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sis</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">**</span><span class="p">{</span><span class="n">state</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">V</span> <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span> <span class="o">**</span><span class="n">Eoffis</span><span class="p">,</span> <span class="o">**</span><span class="n">sis</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">sp</span><span class="o">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nStates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span>

        <span class="c1"># also make sure that states are up to work:</span>
        <span class="p">[</span><span class="n">V</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span> <span class="k">for</span> <span class="n">V</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies_singlePos_overwrite_oneS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies_singlePos_overwrite_multiS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dvdpos_singlePos_overwrite</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">V_is</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">_potential1DCls</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        V_is are the state potential classes enveloped by the reference state.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        V_is: t.List[_potential1DCls]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V_is</span>

    <span class="nd">@V_is</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">V_is</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V_is</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">_potential1DCls</span><span class="p">]):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">V_is</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Vi</span><span class="p">,</span> <span class="n">_potential1DCls</span><span class="p">)</span> <span class="k">for</span> <span class="n">Vi</span> <span class="ow">in</span> <span class="n">V_is</span><span class="p">])):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_V_is</span> <span class="o">=</span> <span class="n">V_is</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">V_is</span><span class="p">)})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Please give the enveloped potential for V_is only 1D-Potential classes in a list.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="envelopedPotential.set_Eoff"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential.set_Eoff">[docs]</a>    <span class="k">def</span> <span class="nf">set_Eoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Eoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is setting the Energy offsets of the states enveloped by the reference state.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Eoff: Union[Number, Iterable[Number]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span> <span class="o">=</span> <span class="n">Eoff</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Eoff</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Energy offsets are used to bias the single states in the reference potential by a constant offset.</span>
<span class="sd">        Therefore each state of the enveloping potential has its own energy offset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Eoff:t.List[Number]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span>

    <span class="nd">@Eoff</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">Eoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Eoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span> <span class="o">=</span> <span class="n">Eoff</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Eoff_i</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Energy offsets are used to bias the single states in the reference potential by a constant offset.</span>
<span class="sd">        Therefore each state of the enveloping potential has its own energy offset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Eoff:t.List[Number]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Eoff_i</span>

    <span class="nd">@Eoff_i</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">Eoff_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Eoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">],</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Eoff</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Eoff_i</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])]</span>
            <span class="n">Eoffis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Eoff_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">**</span><span class="n">Eoffis</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Eoff</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Eoff_i</span> <span class="o">=</span> <span class="n">Eoff</span>
            <span class="n">Eoffis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Eoff_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">**</span><span class="n">Eoffis</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                <span class="s2">&quot;Energy offset Vector and state potentials don&#39;t have the same length!</span><span class="se">\n</span><span class="s2"> states in Eoff &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">Eoff</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> states in Vi&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">)))</span>

<div class="viewcode-block" id="envelopedPotential.set_s"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential.set_s">[docs]</a>    <span class="k">def</span> <span class="nf">set_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            set_s</span>
<span class="sd">            is a function used to set an smoothing parameter.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s:Union[Number, Iterable[Number]]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span> <span class="o">=</span> <span class="n">s</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span>

    <span class="nd">@s</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span> <span class="o">=</span> <span class="n">s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">s_i</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_s</span>

    <span class="nd">@s_i</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">s_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])]</span>
            <span class="n">sis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">**</span><span class="n">sis</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently Only one s runs supported!&quot;</span><span class="p">)</span>
            <span class="c1"># self._s = s</span>
            <span class="c1"># self.constants.update({self.sis: self._s})</span>
            <span class="c1"># sis = {&quot;s_&quot; + str(i): self.s_i[i] for i in range(self.constants[self.nStates])}</span>
            <span class="c1"># self.constants.update({**sis})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;s Vector/Number and state potentials don&#39;t have the same length!</span><span class="se">\n</span><span class="s2"> states in s &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> states in Vi&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_calculate_energies_singlePos_overwrite_multiS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsumexp_calc_gromos</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">]</span>  <span class="c1"># kT - *self.constants[self.T]</span>
        <span class="n">Vr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span><span class="p">))</span> <span class="o">*</span> <span class="n">sum_prefactors</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Vr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_energies_singlePos_overwrite_oneS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsumexp_calc</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">]</span>
        <span class="n">Vr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">sum_prefactors</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Vr</span><span class="p">)</span>

<div class="viewcode-block" id="envelopedPotential._calculate_dvdpos_singlePos_overwrite"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential._calculate_dvdpos_singlePos_overwrite">[docs]</a>    <span class="k">def</span> <span class="nf">_calculate_dvdpos_singlePos_overwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]))</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># print(&quot;Pos: &quot;, position)</span>

        <span class="n">V_R_part</span><span class="p">,</span> <span class="n">V_Is_ene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsumexp_calc_gromos</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">V_R_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V_R_part</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># print(&quot;V_R_part: &quot;, V_R_part.shape, V_R_part)</span>
        <span class="c1"># print(&quot;V_I_ene: &quot;,V_Is_ene.shape, V_Is_ene)</span>
        <span class="n">V_Is_dhdpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">statePot</span><span class="o">.</span><span class="n">force</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="k">for</span> <span class="n">statePot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># print(&quot;V_I_force: &quot;,V_Is_dhdpos.shape, V_Is_dhdpos)</span>

        <span class="n">adapt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">V_R_part</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(&quot;ADAPT: &quot;,adapt.shape, adapt)</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">V_Is_ene</span> <span class="o">-</span> <span class="n">adapt</span><span class="p">)</span>
        <span class="c1"># print(&quot;scaling: &quot;, scaling.shape, scaling)</span>
        <span class="n">dVdpos_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">scaling</span><span class="p">,</span>
                                   <span class="n">V_Is_dhdpos</span><span class="p">)</span>  <span class="c1"># np.array([(ene/V_R_part) * force for ene, force in zip(V_Is_ene, V_Is_dhdpos)])</span>
        <span class="c1"># print(&quot;state_contributions: &quot;,dVdpos_state.shape, dVdpos_state)</span>
        <span class="n">dVdpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dVdpos_state</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(&quot;forces: &quot;,dVdpos.shape, dVdpos)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dVdpos</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_logsumexp_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">prefactors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]):</span>
            <span class="n">prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">ene</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">state</span><span class="p">]),</span>
                                 <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">prefactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)</span>
        <span class="n">prefactors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">logsumexp</span>
        <span class="c1"># print(&quot;Prefactors&quot;, prefactors)</span>
        <span class="n">sum_prefactors</span> <span class="o">=</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(&quot;logexpsum: &quot;, np.squeeze(sum_prefactors))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sum_prefactors</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="envelopedPotential._logsumexp_calc_gromos"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.envelopedPotential._logsumexp_calc_gromos">[docs]</a>    <span class="k">def</span> <span class="nf">_logsumexp_calc_gromos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        code from gromos:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        position</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefactors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">]</span>  <span class="c1"># kT - *self.constants[self.T]</span>
        <span class="n">partA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ene</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">partB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ene</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">partAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">partA</span><span class="p">,</span> <span class="n">partB</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">log_prefac</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">partAB</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">partAB</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sum_prefactors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">partAB</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">log_prefac</span><span class="p">)</span>

        <span class="n">prefactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partA</span><span class="p">)</span>
        <span class="n">prefactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partB</span><span class="p">)</span>

        <span class="c1"># more than two states!</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]):</span>
            <span class="n">partN</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">ene</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">state</span><span class="p">]),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">prefactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partN</span><span class="p">)</span>
            <span class="n">sum_prefactors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">partN</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">partN</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">partN</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
            <span class="c1"># print(&quot;prefactors: &quot;, sum_prefactors)</span>
        <span class="k">return</span> <span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div></div>


<div class="viewcode-block" id="hybridCoupledPotentials"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.hybridCoupledPotentials">[docs]</a><span class="k">class</span> <span class="nc">hybridCoupledPotentials</span><span class="p">(</span><span class="n">_potential1DClsPerturbed</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation of exponential Coupling combined with linear compling is called $\lambda$-EDS this function is the purely symbolic class and therefore note very numerical stable (see lambda EDS).</span>

<span class="sd">    Here two-states are coupled by the log-sum-exp and weighted by lambda resulting in a new reference state $V_R$,</span>

<span class="sd">    $V_R = -\frac{1}{\beta*s} * \ln(\lambda * e^(-\beta*s*(V_A-E^R_A)) + (1-\lambda)*e^(-\beta*s*(V_B-E^R_B)))$</span>

<span class="sd">    This potential coupling is for example used in $\lambda$-EDS.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hybrid Coupled Potential&quot;</span>
    <span class="n">lam</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;λ r s T&#39;</span><span class="p">)</span>
    <span class="n">Va</span><span class="p">,</span> <span class="n">Vb</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;V_a&quot;</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;V_b&quot;</span><span class="p">))</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># const.gas_constant / 1000.0 * temp</span>
    <span class="n">coupling</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">lam</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">Vb</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">s</span> <span class="o">*</span> <span class="n">Va</span><span class="p">))</span>

<div class="viewcode-block" id="hybridCoupledPotentials.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.hybridCoupledPotentials.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Va</span><span class="p">:</span> <span class="n">_potential1DCls</span> <span class="o">=</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
                 <span class="n">Vb</span><span class="p">:</span> <span class="n">_potential1DCls</span> <span class="o">=</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mf">11.0</span><span class="p">,</span> <span class="n">x_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">),</span>
                 <span class="n">lam</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">temp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">298</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            __init__</span>
<span class="sd">                This function constructs a $\lambda$-enveloped potential, enveloping all given states and weighting them by $\lambda$.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        V_is: List[_potential1DCls], optional</span>
<span class="sd">            The states(potential classes) to be enveloped (default: [harmonicOscillatorPotential(), harmonicOscillatorPotential(x_shift=3)])</span>

<span class="sd">        s: float, optional</span>
<span class="sd">            the smoothing parameter, lowering the barriers between the states</span>
<span class="sd">        Eoff_i: List[float], optional</span>
<span class="sd">            the energy offsets of the individual states in the reference potential. These can be used to allow a more uniform sampling. (default: seta ll to 0)</span>
<span class="sd">        T: float, optional</span>
<span class="sd">            the temperature of the reference state (default: 1 = T)</span>
<span class="sd">        kb: float, optional</span>
<span class="sd">            the boltzman constant (default: 1 = kb)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Va</span><span class="p">:</span> <span class="n">Va</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vb</span><span class="p">:</span> <span class="n">Vb</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Va</span><span class="p">:</span> <span class="n">Va</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Vb</span><span class="p">:</span> <span class="n">Vb</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">:</span> <span class="n">lam</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">:</span> <span class="n">temp</span><span class="p">}</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>

<div class="viewcode-block" id="hybridCoupledPotentials.set_s"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.hybridCoupledPotentials.set_s">[docs]</a>    <span class="k">def</span> <span class="nf">set_s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span></div>

<div class="viewcode-block" id="hybridCoupledPotentials.set_Eoff"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.hybridCoupledPotentials.set_Eoff">[docs]</a>    <span class="k">def</span> <span class="nf">set_Eoff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Eoff</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">Eoff</span><span class="p">:</span> <span class="n">Eoff</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="lambdaEDSPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.lambdaEDSPotential">[docs]</a><span class="k">class</span> <span class="nc">lambdaEDSPotential</span><span class="p">(</span><span class="n">envelopedPotential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This implementation of exponential Coupling combined with linear compling is called $\lambda$-EDS the implementation of function is more numerical robust to the hybrid coupling class.</span>


<span class="sd">    Here two-states are coupled by the log-sum-exp and weighted by lambda resulting in a new reference state $V_R$,</span>

<span class="sd">    $V_R = -\frac{1}{\beta*s} * \ln(\lambda * e^(-\beta*s*(V_A-E^R_A)) + (1-\lambda)*e^(-\beta*s*(V_B-E^R_B)))$</span>

<span class="sd">    This potential coupling is for example used in $\lambda$-EDS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lambda enveloped Potential&quot;</span>

    <span class="n">T</span><span class="p">,</span> <span class="n">kb</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;T kb r&quot;</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">kb</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>

    <span class="n">Vis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;V_i&quot;</span><span class="p">])</span>
    <span class="n">Eoffis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;Eoff_i&quot;</span><span class="p">])</span>
    <span class="n">sis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;s_i&quot;</span><span class="p">])</span>
    <span class="n">lamis</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="s2">&quot;λ&quot;</span><span class="p">])</span>

    <span class="n">i</span><span class="p">,</span> <span class="n">nStates</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;i N&quot;</span><span class="p">)</span>
    <span class="n">V_functional</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">lamis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">Vis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">Eoffis</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nStates</span><span class="p">)))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V_is</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">_potential1DCls</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">harmonicOscillatorPotential</span><span class="p">(),</span> <span class="n">harmonicOscillatorPotential</span><span class="p">(</span><span class="n">x_shift</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span> <span class="n">lam</span><span class="p">:</span> <span class="n">Number</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">eoff</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>

        <span class="n">nStates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">V_is</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">:</span> <span class="n">nStates</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Eoff_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_s</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_V_is</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lam_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nStates</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span> <span class="o">=</span> <span class="n">lam</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">V_is</span><span class="o">=</span><span class="n">V_is</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">eoff</span><span class="o">=</span><span class="n">eoff</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">kb</span><span class="o">=</span><span class="n">kb</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># for sympy Sympy Updates - Check!:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;state_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">Eoffis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Eoff_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">sis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">lamis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lam_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Eoffis</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sis</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="n">state</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">V</span> <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">statePotentials</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span> <span class="o">**</span><span class="n">Eoffis</span><span class="p">,</span> <span class="o">**</span><span class="n">sis</span><span class="p">,</span> <span class="o">**</span><span class="n">lamis</span><span class="p">})</span>
        <span class="n">inner_log</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lamis</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nStates</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">inner_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span>

        <span class="c1"># also make sure that states are up to work:</span>
        <span class="p">[</span><span class="n">V</span><span class="o">.</span><span class="n">_update_functions</span><span class="p">()</span> <span class="k">for</span> <span class="n">V</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies_singlePos_overwrite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dvdpos_singlePos_overwrite</span>

<div class="viewcode-block" id="lambdaEDSPotential.set_lam"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.lambdaEDSPotential.set_lam">[docs]</a>    <span class="k">def</span> <span class="nf">set_lam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span> <span class="o">=</span> <span class="n">lam</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lam</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span>

    <span class="nd">@lam</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span> <span class="o">=</span> <span class="n">lam</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lam_i</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">Number</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lam_i</span>

    <span class="nd">@lam_i</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lam_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lam</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Number</span><span class="p">]]):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lam_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lam</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">lam</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lamis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lam_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">**</span><span class="n">lamis</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lam_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])],</span>
                                   <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lamis</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;lam_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="o">**</span><span class="n">lamis</span><span class="p">})</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently Only one lam runs supported!&quot;</span><span class="p">)</span>
            <span class="c1"># self._lam_i = np.array(lam, ndmin=1)</span>
            <span class="c1"># self.constants.update({self.lamis: self._lam_i})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;s Vector/Number and state potentials don&#39;t have the same length!</span><span class="se">\n</span><span class="s2"> states in s &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span>
                <span class="n">lam</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> states in Vi&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_calculate_energies_singlePos_overwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="c1"># print(&quot;Positions: &quot;,position)</span>
        <span class="c1"># print(&quot;s_i: &quot;,self.s_i)</span>
        <span class="n">sum_prefactors</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsumexp_calc</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">]</span>  <span class="c1"># kT - *self.constants[self.T]</span>
        <span class="n">Vr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="n">sum_prefactors</span>
        <span class="c1"># print(&quot;finalVR&quot;, Vr)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Vr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_dvdpos_singlePos_overwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]))</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># print(&quot;Pos: &quot;, position)</span>
        <span class="n">V_R_part</span><span class="p">,</span> <span class="n">V_Is_ene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logsumexp_calc</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="c1"># print(&quot;V_I_ene: &quot;,V_Is_ene.shape, V_Is_ene)</span>
        <span class="n">V_R_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V_R_part</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># print(&quot;V_R_part: &quot;, V_R_part.shape, V_R_part)</span>
        <span class="n">V_Is_dhdpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">statePot</span><span class="o">.</span><span class="n">force</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="k">for</span> <span class="n">statePot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">],</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># print(&quot;V_I_force: &quot;,V_Is_dhdpos.shape, V_Is_dhdpos)</span>
        <span class="n">adapt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">V_R_part</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># print(&quot;ADAPT: &quot;,adapt.shape, adapt)</span>
        <span class="c1"># print(self.lam_i)</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lam_i</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">V_Is_ene</span> <span class="o">-</span> <span class="n">adapt</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># print(&quot;scaling: &quot;, scaling.shape, scaling)</span>
        <span class="n">dVdpos_state</span> <span class="o">=</span> <span class="n">scaling</span> <span class="o">*</span> <span class="n">V_Is_dhdpos</span>
        <span class="c1"># print(&quot;state_contributions: &quot;,dVdpos_state.shape, dVdpos_state)</span>
        <span class="n">dVdpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dVdpos_state</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(&quot;forces: &quot;,dVdpos.shape, dVdpos)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dVdpos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_logsumexp_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">prefactors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">kb</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">]):</span>
            <span class="n">prefactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_i</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_is</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">ene</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eoff_i</span><span class="p">[</span><span class="n">state</span><span class="p">]),</span>
                                 <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">prefactors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefactor</span><span class="p">)</span>
        <span class="n">prefactors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">logsumexp</span>
        <span class="n">sum_prefactors</span> <span class="o">=</span> <span class="n">logsumexp</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">sum_prefactors</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">prefactors</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">special potentials</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="dummyPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.dummyPotential">[docs]</a><span class="k">class</span> <span class="nc">dummyPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Dummy potential returns a simple constant value for each position</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Dummy Potential&quot;</span>
    <span class="n">position</span><span class="p">,</span> <span class="n">y_shift</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r Voffset&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="dummyPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.dummyPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This Class is representing the a dummy potential.</span>
<span class="sd">        It returns a constant value equalling the y_shift parameter.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y_shift: float, optional</span>
<span class="sd">            This will be the constant return value, defaults to 0</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Lambda</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_shift</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">y_shift</span><span class="p">:</span> <span class="n">y_shift</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">positions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">y_shift</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">positions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)))</span></div></div>


<div class="viewcode-block" id="flatwellPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.flatwellPotential">[docs]</a><span class="k">class</span> <span class="nc">flatwellPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A flatwell potential returns a simple constant value (y_max) for each position except positions in the range x_min-x_max.</span>
<span class="sd">    In the defined phase space range the potential always returns a second defined value (y_min)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Flat Well&quot;</span>

    <span class="n">x_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">x_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">y_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">y_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="flatwellPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.flatwellPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_range</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">y_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __init__ This potential is a flatwell potential.</span>
<span class="sd">        The flatwell potential is a function similar to an if case.</span>
<span class="sd">        If a position is inside a the x_range, it returns the y_min val.</span>
<span class="sd">        If a position is outside, the y_max val will be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_range:  (list, range), optional</span>
<span class="sd">        range inside this the y_min val will be returned, defaults to (0, 1)</span>
<span class="sd">        y_max:  float, optional</span>
<span class="sd">        outside of the range this value will be returned, defaults to 1000</span>
<span class="sd">        y_min: float, optional</span>
<span class="sd">        inside the range this value will be returned, defaults to 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">y_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">y_min</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nStates</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nDimensions</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_functions</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_calculate_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">position</span><span class="p">),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_calculate_dVdpos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Number</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setting up after pickling. Catch special features fo function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">state</span></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Biased potentials</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TIME INDEPENDENT BIASES </span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="addedPotentials"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.addedPotentials">[docs]</a><span class="k">class</span> <span class="nc">addedPotentials</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Adds two different potentials on top of each other. Can be used to generate</span>
<span class="sd">    harmonic potential umbrella sampling or scaled potentials</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Added Potential Enhanced Sampling System&quot;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">bias_potential</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="addedPotentials.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.addedPotentials.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origPotential</span><span class="o">=</span><span class="n">harmonicOscillatorPotential</span><span class="p">(),</span> <span class="n">addPotential</span><span class="o">=</span><span class="n">gaussPotential</span><span class="p">()):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        __init__</span>
<span class="sd">              This is the Constructor of the addedPotential class.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origPotential: potential type</span>
<span class="sd">            The unbiased potential</span>
<span class="sd">        addPotential: potential type</span>
<span class="sd">            The potential added on top of the unbiased potential to</span>
<span class="sd">            bias the system</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">origPotential</span> <span class="o">=</span> <span class="n">origPotential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPotential</span> <span class="o">=</span> <span class="n">addPotential</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">origPotential</span><span class="o">.</span><span class="n">constants</span><span class="p">,</span> <span class="o">**</span><span class="n">addPotential</span><span class="o">.</span><span class="n">constants</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="n">origPotential</span><span class="o">.</span><span class="n">V</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">addPotential</span><span class="o">.</span><span class="n">V</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div></div>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TIME DEPENDENT BIASES </span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="metadynamicsPotential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential">[docs]</a><span class="k">class</span> <span class="nc">metadynamicsPotential</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The metadynamics bias potential adds 1D Gaussian potentials on top of</span>
<span class="sd">    the original 1D potential. The added gaussian potential is centered on the current position.</span>
<span class="sd">    Thereby the valleys of the potential &quot;flooded&quot; and barrier crossing is easier.</span>

<span class="sd">    This implementation uses a grid to store the biasing. This is much faster than calculating</span>
<span class="sd">    an ever increasing potential with sympy</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Metadynamics Enhanced Sampling System using grid bias&quot;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">bias_potential</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="metadynamicsPotential.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origPotential</span><span class="o">=</span><span class="n">harmonicOscillatorPotential</span><span class="p">(),</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_trigger</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">bias_grid_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bias_grid_max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">numbins</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is the Constructor of the metadynamicsPotential class.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origPotential: potential type</span>
<span class="sd">            The unbiased potential</span>
<span class="sd">        amplitude : float</span>
<span class="sd">            scaling of the gaussian potential added in the metadynamcis step</span>
<span class="sd">        sigma: float</span>
<span class="sd">            standard deviation of the gaussian potential added in the metadynamcis step</span>
<span class="sd">        n_trigger : int</span>
<span class="sd">            Metadynamics potential will be added after every n_trigger&#39;th steps</span>
<span class="sd">        bias_grid_min: float</span>
<span class="sd">            min value of the bias grid</span>
<span class="sd">        bias_grid_max: float</span>
<span class="sd">            max value of the bias grid</span>
<span class="sd">        numbins: float</span>
<span class="sd">            size of the grid bias and forces are saved in</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">origPotential</span> <span class="o">=</span> <span class="n">origPotential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trigger</span> <span class="o">=</span> <span class="n">n_trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">amplitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">biasPotentialType</span> <span class="o">=</span> <span class="n">gaussPotential</span>

        <span class="c1"># grid where the bias is stored</span>
        <span class="c1"># currently only for 1D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numbins</span><span class="p">)</span>  <span class="c1"># energy grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numbins</span><span class="p">)</span>  <span class="c1"># force grid</span>
        <span class="c1"># get center value for each bin</span>
        <span class="n">bin_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">bias_grid_max</span> <span class="o">-</span> <span class="n">bias_grid_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">numbins</span><span class="p">)</span>  <span class="c1"># half bin width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bias_grid_min</span> <span class="o">+</span> <span class="n">bin_half</span><span class="p">,</span> <span class="n">bias_grid_max</span> <span class="o">-</span> <span class="n">bin_half</span><span class="p">,</span> <span class="n">numbins</span><span class="p">)</span>
        <span class="c1"># current_n counts when next metadynamic step should be applied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># count how often the potential was updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished_steps</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">origPotential</span><span class="o">.</span><span class="n">constants</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="n">origPotential</span><span class="o">.</span><span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_orig_part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>


        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BIAS</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Beautiful integration to system as Condition.</span>
<div class="viewcode-block" id="metadynamicsPotential.apply"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">currentPosition</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_for_metastep</span><span class="p">(</span><span class="n">currentPosition</span><span class="p">)</span></div>

<div class="viewcode-block" id="metadynamicsPotential.apply_coupled"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.apply_coupled">[docs]</a>    <span class="k">def</span> <span class="nf">apply_coupled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">_currentPosition</span><span class="p">)</span></div>

<div class="viewcode-block" id="metadynamicsPotential.couple_system"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.couple_system">[docs]</a>    <span class="k">def</span> <span class="nf">couple_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">systemCls</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">system</span></div>

<div class="viewcode-block" id="metadynamicsPotential.check_for_metastep"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.check_for_metastep">[docs]</a>    <span class="k">def</span> <span class="nf">check_for_metastep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_position</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks if the bias potential should be added at the current step</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curr_position: tuple</span>
<span class="sd">            current x,y position</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">step</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trigger</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_potential</span><span class="p">(</span><span class="n">curr_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finished_steps</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="metadynamicsPotential._update_potential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential._update_potential">[docs]</a>    <span class="k">def</span> <span class="nf">_update_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_position</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Is triggered by check_for_metastep(). Adds a gaussian centered on the</span>
<span class="sd">        current position to the potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curr_position: float</span>
<span class="sd">            current x position</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># do gaussian metadynamics</span>
        <span class="c1">#print(&quot;A &quot;, self.amplitude, &quot;mu &quot;, curr_position, &quot;sigma &quot;, self.sigma)</span>
        <span class="n">biasPotential</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">biasPotentialType</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">curr_position</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="c1">#print(biasPotential)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_bias_bin_energy</span> <span class="o">=</span> <span class="n">biasPotential</span><span class="o">.</span><span class="n">ene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">)</span>
            <span class="n">new_bias_bin_force</span> <span class="o">=</span> <span class="n">biasPotential</span><span class="o">.</span><span class="n">force</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gaussian Overflows!&quot;</span><span class="p">)</span>
        <span class="c1">#print(&quot;newENE&quot;, new_bias_bin_energy.shape, new_bias_bin_energy)</span>
        <span class="c1">#print(&quot;newForce&quot;, new_bias_bin_force.shape, new_bias_bin_force)</span>
        <span class="c1"># update bias grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_energy</span> <span class="o">+</span> <span class="n">new_bias_bin_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_force</span> <span class="o">+</span> <span class="n">new_bias_bin_force</span></div>

    <span class="c1"># overwrite the energy and force</span>
<div class="viewcode-block" id="metadynamicsPotential.ene"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.ene">[docs]</a>    <span class="k">def</span> <span class="nf">ene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        calculates energy of particle also takes bias into account</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions: tuple</span>
<span class="sd">            position on 1D potential energy surface</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        current energy</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">current_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">positions</span><span class="p">)</span>
            <span class="c1">#print(current_bin, len(self.bias_grid_energy))</span>
            <span class="n">bias_contribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_energy</span><span class="p">[</span><span class="n">current_bin</span><span class="p">]</span>
            <span class="n">orig_potential</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="c1">#print(bias_contribution, orig_potential)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">orig_potential</span> <span class="o">+</span> <span class="n">bias_contribution</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bias_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
                <span class="n">current_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
                <span class="n">bias_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_energy</span><span class="p">[</span><span class="n">current_bin</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_energies</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bias_list</span><span class="p">))</span></div>

<div class="viewcode-block" id="metadynamicsPotential.force"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential.force">[docs]</a>    <span class="k">def</span> <span class="nf">force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        calculates derivative with respect to position also takes bias into account</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        positions: tuple</span>
<span class="sd">            position on 1D potential energy surface</span>

<span class="sd">        Returns</span>
<span class="sd">        current derivative dh/dpos</span>
<span class="sd">        -------</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">current_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_centers</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>
        <span class="n">force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_dVdpos</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias_grid_force</span><span class="p">[</span><span class="n">current_bin</span><span class="p">])</span>
        <span class="c1">#print(&quot;Force: &quot;,current_bin, self.bias_grid_force[current_bin], force)</span>
        <span class="k">return</span> <span class="n">force</span></div>

<div class="viewcode-block" id="metadynamicsPotential._find_nearest"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD.metadynamicsPotential._find_nearest">[docs]</a>    <span class="k">def</span> <span class="nf">_find_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Function that finds position of the closest entry to a given value in an array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array: np.array</span>
<span class="sd">            1D array containing the midpoints of the metadynamics grid</span>
<span class="sd">        value: int or float</span>
<span class="sd">            search value</span>
<span class="sd">        Returns</span>

<span class="sd">        Index of the entry closest to the given value</span>
<span class="sd">        -------</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>  <span class="c1">#Why, looks like an earlier version?: or np.abs(value - array[idx - 1]) &lt; np.abs(value - array[idx])</span>
            <span class="k">return</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">idx</span></div></div>


<span class="c1">#### OLD FUNCTIONS ###</span>

<div class="viewcode-block" id="_timedependendBias"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._timedependendBias">[docs]</a><span class="k">class</span> <span class="nc">_timedependendBias</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The timedependend bias potential adds a user defined potential on top of</span>
<span class="sd">    the original potential.</span>

<span class="sd">    This implementation uses sympy instead of a grid and is therefore super slow</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Metadynamics Enhanced Sampling System&quot;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="_timedependendBias.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._timedependendBias.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origPotential</span><span class="p">,</span> <span class="n">addPotential</span><span class="p">,</span> <span class="n">n_trigger</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        __init__</span>
<span class="sd">              This is the Constructor of the addedPotential class.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origPotential: potential type</span>
<span class="sd">            The unbiased potential</span>
<span class="sd">        addPotential: potential type</span>
<span class="sd">            The potential added on top of the unbiased potential to</span>
<span class="sd">            bias the system, usually of gaussian type</span>
<span class="sd">        n_trigger : int</span>
<span class="sd">            Added potential will be added after every n_trigger&#39;th steps</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origPotential</span> <span class="o">=</span> <span class="n">origPotential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trigger</span> <span class="o">=</span> <span class="n">n_trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPotential</span> <span class="o">=</span> <span class="n">addPotential</span>
        <span class="c1"># current_n counts when next potential adding step should be applied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">origPotential</span><span class="o">.</span><span class="n">constants</span><span class="p">,</span> <span class="o">**</span><span class="n">addPotential</span><span class="o">.</span><span class="n">constants</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V_orig</span> <span class="o">=</span> <span class="n">origPotential</span><span class="o">.</span><span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_orig</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>

<div class="viewcode-block" id="_timedependendBias.check_for_metastep"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._timedependendBias.check_for_metastep">[docs]</a>    <span class="k">def</span> <span class="nf">check_for_metastep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_position</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks if the bias potential should be added at the current step</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curr_position: flaot</span>
<span class="sd">            current x position</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trigger</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_potential</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="_timedependendBias._update_potential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._timedependendBias._update_potential">[docs]</a>    <span class="k">def</span> <span class="nf">_update_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Is triggered by check_for_metastep(). Adds the pre-defined potential on the</span>
<span class="sd">        current position to the potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># add potential to the system</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">addPotential</span><span class="o">.</span><span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="_metadynamicsPotentialSympy"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._metadynamicsPotentialSympy">[docs]</a><span class="k">class</span> <span class="nc">_metadynamicsPotentialSympy</span><span class="p">(</span><span class="n">_potential1DCls</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    The metadynamics bias potential adds Gaussian potentials on top of</span>
<span class="sd">    the original potential. The added gaussian potential is centered on the current position.</span>
<span class="sd">    Thereby the valleys of the potential &quot;flooded&quot; and barrier crossing is easier</span>

<span class="sd">    This implementation uses sympy instead of a grid and is therefore super slow</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Metadynamics Enhanced Sampling System using sympy&quot;</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="_metadynamicsPotentialSympy.__init__"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._metadynamicsPotentialSympy.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origPotential</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">n_trigger</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This is the Constructor of the metadynamicsPotential class.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origPotential: potential type</span>
<span class="sd">            The unbiased potential</span>
<span class="sd">        amplitude : float</span>
<span class="sd">            scaling of the gaussian potential added in the metadynamcis step</span>
<span class="sd">        sigma: float</span>
<span class="sd">            standard deviation of the gaussian potential added in the metadynamcis step</span>
<span class="sd">        n_trigger : int</span>
<span class="sd">            Metadynamics potential will be added after every n_trigger&#39;th steps</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">origPotential</span> <span class="o">=</span> <span class="n">origPotential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">biasPotential</span> <span class="o">=</span> <span class="n">gaussPotential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trigger</span> <span class="o">=</span> <span class="n">n_trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">amplitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="c1"># current_n counts when next metadynamic step should be applied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># count how often the potential was updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished_steps</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">origPotential</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">biasPotential</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">V_orig</span> <span class="o">=</span> <span class="n">origPotential</span><span class="o">.</span><span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_orig</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>

<div class="viewcode-block" id="_metadynamicsPotentialSympy.check_for_metastep"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._metadynamicsPotentialSympy.check_for_metastep">[docs]</a>    <span class="k">def</span> <span class="nf">check_for_metastep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_position</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks if the bias potential should be added at the current step</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curr_position: flaot</span>
<span class="sd">            current x position</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trigger</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_potential</span><span class="p">(</span><span class="n">curr_position</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finished_steps</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_n</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="_metadynamicsPotentialSympy._update_potential"><a class="viewcode-back" href="../../../_source/ensembler.potentials.html#ensembler.potentials.OneD._metadynamicsPotentialSympy._update_potential">[docs]</a>    <span class="k">def</span> <span class="nf">_update_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr_position</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Is triggered by check_for_metastep(). Adds a gaussian centered on the</span>
<span class="sd">        current position to the potential</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        curr_position: float</span>
<span class="sd">            current x position</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># add potential to the system</span>
        <span class="c1"># do gaussian metadynamics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">biasPotential</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">curr_position</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">V</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_functional</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dVdpos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Benjamin Ries, Stephanie Linker, David Hahn. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.3

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>