

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pandas.core.frame &mdash; Ensembler beta documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> Ensembler
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../_source/index.html">Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Ensembler</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pandas.core.frame</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pandas.core.frame</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">DataFrame</span>
<span class="sd">---------</span>
<span class="sd">An efficient 2D container for potentially mixed-type time series or other</span>
<span class="sd">labeled data series.</span>

<span class="sd">Similar to its R counterpart, data.frame, except providing automatic data</span>
<span class="sd">alignment and a host of useful data manipulation methods having to do with the</span>
<span class="sd">labeling information</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">abc</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">IO</span><span class="p">,</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">FrozenSet</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>

<span class="kn">from</span> <span class="nn">pandas._config</span> <span class="kn">import</span> <span class="n">get_option</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">algos</span> <span class="k">as</span> <span class="n">libalgos</span><span class="p">,</span> <span class="n">lib</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="n">Axes</span><span class="p">,</span> <span class="n">Axis</span><span class="p">,</span> <span class="n">Dtype</span><span class="p">,</span> <span class="n">FilePathOrBuffer</span><span class="p">,</span> <span class="n">Level</span><span class="p">,</span> <span class="n">Renamer</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="kn">import</span> <span class="n">PY37</span>
<span class="kn">from</span> <span class="nn">pandas.compat._optional</span> <span class="kn">import</span> <span class="n">import_optional_dependency</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="kn">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Appender</span><span class="p">,</span>
    <span class="n">Substitution</span><span class="p">,</span>
    <span class="n">deprecate_kwarg</span><span class="p">,</span>
    <span class="n">rewrite_axis_style_signature</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">validate_axis_style_args</span><span class="p">,</span>
    <span class="n">validate_bool_kwarg</span><span class="p">,</span>
    <span class="n">validate_percentile</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">cast_scalar_to_array</span><span class="p">,</span>
    <span class="n">coerce_to_dtypes</span><span class="p">,</span>
    <span class="n">find_common_type</span><span class="p">,</span>
    <span class="n">infer_dtype_from_scalar</span><span class="p">,</span>
    <span class="n">invalidate_string_dtypes</span><span class="p">,</span>
    <span class="n">maybe_cast_to_datetime</span><span class="p">,</span>
    <span class="n">maybe_convert_platform</span><span class="p">,</span>
    <span class="n">maybe_downcast_to_dtype</span><span class="p">,</span>
    <span class="n">maybe_infer_to_datetimelike</span><span class="p">,</span>
    <span class="n">maybe_upcast</span><span class="p">,</span>
    <span class="n">maybe_upcast_putmask</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_float64</span><span class="p">,</span>
    <span class="n">ensure_int64</span><span class="p">,</span>
    <span class="n">ensure_platform_int</span><span class="p">,</span>
    <span class="n">infer_dtype_from_object</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_hashable</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_iterator</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_named_tuple</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_sequence</span><span class="p">,</span>
    <span class="n">needs_i8_conversion</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ABCDataFrame</span><span class="p">,</span>
    <span class="n">ABCIndexClass</span><span class="p">,</span>
    <span class="n">ABCMultiIndex</span><span class="p">,</span>
    <span class="n">ABCSeries</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="n">isna</span><span class="p">,</span> <span class="n">notna</span>

<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="n">algorithms</span><span class="p">,</span> <span class="n">common</span> <span class="k">as</span> <span class="n">com</span><span class="p">,</span> <span class="n">nanops</span><span class="p">,</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="kn">import</span> <span class="n">CachedAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="n">Categorical</span><span class="p">,</span> <span class="n">ExtensionArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.datetimelike</span> <span class="kn">import</span> <span class="n">DatetimeLikeArrayMixin</span> <span class="k">as</span> <span class="n">DatetimeLikeArray</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.sparse</span> <span class="kn">import</span> <span class="n">SparseFrameAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.core.generic</span> <span class="kn">import</span> <span class="n">NDFrame</span><span class="p">,</span> <span class="n">_shared_docs</span>
<span class="kn">from</span> <span class="nn">pandas.core.groupby</span> <span class="kn">import</span> <span class="n">generic</span> <span class="k">as</span> <span class="n">groupby_generic</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes</span> <span class="kn">import</span> <span class="n">base</span> <span class="k">as</span> <span class="n">ibase</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ensure_index</span><span class="p">,</span> <span class="n">ensure_index_from_sequences</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimes</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="n">maybe_droplevels</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.period</span> <span class="kn">import</span> <span class="n">PeriodIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="kn">import</span> <span class="n">check_bool_indexer</span><span class="p">,</span> <span class="n">convert_to_index_sliceable</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="n">BlockManager</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">arrays_to_mgr</span><span class="p">,</span>
    <span class="n">get_names_from_index</span><span class="p">,</span>
    <span class="n">init_dict</span><span class="p">,</span>
    <span class="n">init_ndarray</span><span class="p">,</span>
    <span class="n">masked_rec_array_to_mgr</span><span class="p">,</span>
    <span class="n">reorder_arrays</span><span class="p">,</span>
    <span class="n">sanitize_index</span><span class="p">,</span>
    <span class="n">to_arrays</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops.missing</span> <span class="kn">import</span> <span class="n">dispatch_fill_zeros</span>
<span class="kn">from</span> <span class="nn">pandas.core.series</span> <span class="kn">import</span> <span class="n">Series</span>

<span class="kn">from</span> <span class="nn">pandas.io.common</span> <span class="kn">import</span> <span class="n">get_filepath_or_buffer</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats</span> <span class="kn">import</span> <span class="n">console</span><span class="p">,</span> <span class="nb">format</span> <span class="k">as</span> <span class="n">fmt</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="kn">import</span> <span class="n">pprint_thing</span>
<span class="kn">import</span> <span class="nn">pandas.plotting</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas.io.formats.style</span> <span class="kn">import</span> <span class="n">Styler</span>

<span class="c1"># ---------------------------------------------------------------------</span>
<span class="c1"># Docstring templates</span>

<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">=</span><span class="s2">&quot;index, columns&quot;</span><span class="p">,</span>
    <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span>
    <span class="n">axes_single_arg</span><span class="o">=</span><span class="s2">&quot;{0 or &#39;index&#39;, 1 or &#39;columns&#39;}&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="s2">        If 0 or &#39;index&#39;: apply function to each column.</span>
<span class="s2">        If 1 or &#39;columns&#39;: apply function to each row.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">optional_by</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        by : str or list of str</span>
<span class="s2">            Name or list of names to sort by.</span>

<span class="s2">            - if `axis` is 0 or `&#39;index&#39;` then `by` may contain index</span>
<span class="s2">              levels and/or column labels.</span>
<span class="s2">            - if `axis` is 1 or `&#39;columns&#39;` then `by` may contain column</span>
<span class="s2">              levels and/or index labels.</span>

<span class="s2">            .. versionchanged:: 0.23.0</span>

<span class="s2">               Allow specifying index or column level names.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">versionadded_to_excel</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">optional_labels</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;labels : array-like, optional</span>
<span class="s2">            New labels / index to conform the axis specified by &#39;axis&#39; to.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">optional_axis</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;axis : int or str, optional</span>
<span class="s2">            Axis to target. Can be either the axis name (&#39;index&#39;, &#39;columns&#39;)</span>
<span class="s2">            or number (0, 1).&quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">_numeric_only_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;numeric_only : boolean, default None</span>
<span class="s2">    Include only float, int, boolean data. If None, will attempt to use</span>
<span class="s2">    everything, then use only numeric data</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_merge_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Merge DataFrame or named Series objects with a database-style join.</span>

<span class="s2">The join is done on columns or indexes. If joining columns on</span>
<span class="s2">columns, the DataFrame indexes *will be ignored*. Otherwise if joining indexes</span>
<span class="s2">on indexes or indexes on a column or columns, the index will be passed on.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span><span class="si">%s</span><span class="s2"></span>
<span class="s2">right : DataFrame or named Series</span>
<span class="s2">    Object to merge with.</span>
<span class="s2">how : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}, default &#39;inner&#39;</span>
<span class="s2">    Type of merge to be performed.</span>

<span class="s2">    * left: use only keys from left frame, similar to a SQL left outer join;</span>
<span class="s2">      preserve key order.</span>
<span class="s2">    * right: use only keys from right frame, similar to a SQL right outer join;</span>
<span class="s2">      preserve key order.</span>
<span class="s2">    * outer: use union of keys from both frames, similar to a SQL full outer</span>
<span class="s2">      join; sort keys lexicographically.</span>
<span class="s2">    * inner: use intersection of keys from both frames, similar to a SQL inner</span>
<span class="s2">      join; preserve the order of the left keys.</span>
<span class="s2">on : label or list</span>
<span class="s2">    Column or index level names to join on. These must be found in both</span>
<span class="s2">    DataFrames. If `on` is None and not merging on indexes then this defaults</span>
<span class="s2">    to the intersection of the columns in both DataFrames.</span>
<span class="s2">left_on : label or list, or array-like</span>
<span class="s2">    Column or index level names to join on in the left DataFrame. Can also</span>
<span class="s2">    be an array or list of arrays of the length of the left DataFrame.</span>
<span class="s2">    These arrays are treated as if they are columns.</span>
<span class="s2">right_on : label or list, or array-like</span>
<span class="s2">    Column or index level names to join on in the right DataFrame. Can also</span>
<span class="s2">    be an array or list of arrays of the length of the right DataFrame.</span>
<span class="s2">    These arrays are treated as if they are columns.</span>
<span class="s2">left_index : bool, default False</span>
<span class="s2">    Use the index from the left DataFrame as the join key(s). If it is a</span>
<span class="s2">    MultiIndex, the number of keys in the other DataFrame (either the index</span>
<span class="s2">    or a number of columns) must match the number of levels.</span>
<span class="s2">right_index : bool, default False</span>
<span class="s2">    Use the index from the right DataFrame as the join key. Same caveats as</span>
<span class="s2">    left_index.</span>
<span class="s2">sort : bool, default False</span>
<span class="s2">    Sort the join keys lexicographically in the result DataFrame. If False,</span>
<span class="s2">    the order of the join keys depends on the join type (how keyword).</span>
<span class="s2">suffixes : tuple of (str, str), default (&#39;_x&#39;, &#39;_y&#39;)</span>
<span class="s2">    Suffix to apply to overlapping column names in the left and right</span>
<span class="s2">    side, respectively. To raise an exception on overlapping columns use</span>
<span class="s2">    (False, False).</span>
<span class="s2">copy : bool, default True</span>
<span class="s2">    If False, avoid copy if possible.</span>
<span class="s2">indicator : bool or str, default False</span>
<span class="s2">    If True, adds a column to output DataFrame called &quot;_merge&quot; with</span>
<span class="s2">    information on the source of each row.</span>
<span class="s2">    If string, column with information on source of each row will be added to</span>
<span class="s2">    output DataFrame, and column will be named value of string.</span>
<span class="s2">    Information column is Categorical-type and takes on a value of &quot;left_only&quot;</span>
<span class="s2">    for observations whose merge key only appears in &#39;left&#39; DataFrame,</span>
<span class="s2">    &quot;right_only&quot; for observations whose merge key only appears in &#39;right&#39;</span>
<span class="s2">    DataFrame, and &quot;both&quot; if the observation&#39;s merge key is found in both.</span>

<span class="s2">validate : str, optional</span>
<span class="s2">    If specified, checks if merge is of specified type.</span>

<span class="s2">    * &quot;one_to_one&quot; or &quot;1:1&quot;: check if merge keys are unique in both</span>
<span class="s2">      left and right datasets.</span>
<span class="s2">    * &quot;one_to_many&quot; or &quot;1:m&quot;: check if merge keys are unique in left</span>
<span class="s2">      dataset.</span>
<span class="s2">    * &quot;many_to_one&quot; or &quot;m:1&quot;: check if merge keys are unique in right</span>
<span class="s2">      dataset.</span>
<span class="s2">    * &quot;many_to_many&quot; or &quot;m:m&quot;: allowed, but does not result in checks.</span>

<span class="s2">    .. versionadded:: 0.21.0</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">DataFrame</span>
<span class="s2">    A DataFrame of the two merged objects.</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">merge_ordered : Merge with optional filling/interpolation.</span>
<span class="s2">merge_asof : Merge on nearest keys.</span>
<span class="s2">DataFrame.join : Similar method using indices.</span>

<span class="s2">Notes</span>
<span class="s2">-----</span>
<span class="s2">Support for specifying index levels as the `on`, `left_on`, and</span>
<span class="s2">`right_on` parameters was added in version 0.23.0</span>
<span class="s2">Support for merging named Series objects was added in version 0.24.0</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>

<span class="s2">&gt;&gt;&gt; df1 = pd.DataFrame({&#39;lkey&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;],</span>
<span class="s2">...                     &#39;value&#39;: [1, 2, 3, 5]})</span>
<span class="s2">&gt;&gt;&gt; df2 = pd.DataFrame({&#39;rkey&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;],</span>
<span class="s2">...                     &#39;value&#39;: [5, 6, 7, 8]})</span>
<span class="s2">&gt;&gt;&gt; df1</span>
<span class="s2">    lkey value</span>
<span class="s2">0   foo      1</span>
<span class="s2">1   bar      2</span>
<span class="s2">2   baz      3</span>
<span class="s2">3   foo      5</span>
<span class="s2">&gt;&gt;&gt; df2</span>
<span class="s2">    rkey value</span>
<span class="s2">0   foo      5</span>
<span class="s2">1   bar      6</span>
<span class="s2">2   baz      7</span>
<span class="s2">3   foo      8</span>

<span class="s2">Merge df1 and df2 on the lkey and rkey columns. The value columns have</span>
<span class="s2">the default suffixes, _x and _y, appended.</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;)</span>
<span class="s2">  lkey  value_x rkey  value_y</span>
<span class="s2">0  foo        1  foo        5</span>
<span class="s2">1  foo        1  foo        8</span>
<span class="s2">2  foo        5  foo        5</span>
<span class="s2">3  foo        5  foo        8</span>
<span class="s2">4  bar        2  bar        6</span>
<span class="s2">5  baz        3  baz        7</span>

<span class="s2">Merge DataFrames df1 and df2 with specified left and right suffixes</span>
<span class="s2">appended to any overlapping columns.</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;,</span>
<span class="s2">...           suffixes=(&#39;_left&#39;, &#39;_right&#39;))</span>
<span class="s2">  lkey  value_left rkey  value_right</span>
<span class="s2">0  foo           1  foo            5</span>
<span class="s2">1  foo           1  foo            8</span>
<span class="s2">2  foo           5  foo            5</span>
<span class="s2">3  foo           5  foo            8</span>
<span class="s2">4  bar           2  bar            6</span>
<span class="s2">5  baz           3  baz            7</span>

<span class="s2">Merge DataFrames df1 and df2, but raise an exception if the DataFrames have</span>
<span class="s2">any overlapping columns.</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;, suffixes=(False, False))</span>
<span class="s2">Traceback (most recent call last):</span>
<span class="s2">...</span>
<span class="s2">ValueError: columns overlap but no suffix specified:</span>
<span class="s2">    Index([&#39;value&#39;], dtype=&#39;object&#39;)</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="c1"># -----------------------------------------------------------------------</span>
<span class="c1"># DataFrame class</span>


<span class="k">class</span> <span class="nc">DataFrame</span><span class="p">(</span><span class="n">NDFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Two-dimensional, size-mutable, potentially heterogeneous tabular data.</span>

<span class="sd">    Data structure also contains labeled axes (rows and columns).</span>
<span class="sd">    Arithmetic operations align on both row and column labels. Can be</span>
<span class="sd">    thought of as a dict-like container for Series objects. The primary</span>
<span class="sd">    pandas data structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray (structured or homogeneous), Iterable, dict, or DataFrame</span>
<span class="sd">        Dict can contain Series, arrays, constants, or list-like objects.</span>

<span class="sd">        .. versionchanged:: 0.23.0</span>
<span class="sd">           If data is a dict, column order follows insertion-order for</span>
<span class="sd">           Python 3.6 and later.</span>

<span class="sd">        .. versionchanged:: 0.25.0</span>
<span class="sd">           If data is a list of dicts, column order follows insertion-order</span>
<span class="sd">           for Python 3.6 and later.</span>

<span class="sd">    index : Index or array-like</span>
<span class="sd">        Index to use for resulting frame. Will default to RangeIndex if</span>
<span class="sd">        no indexing information part of input data and no index provided.</span>
<span class="sd">    columns : Index or array-like</span>
<span class="sd">        Column labels to use for resulting frame. Will default to</span>
<span class="sd">        RangeIndex (0, 1, 2, ..., n) if no column labels are provided.</span>
<span class="sd">    dtype : dtype, default None</span>
<span class="sd">        Data type to force. Only a single dtype is allowed. If None, infer.</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">        Copy data from inputs. Only affects DataFrame / 2d ndarray input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DataFrame.from_records : Constructor from tuples, also record arrays.</span>
<span class="sd">    DataFrame.from_dict : From dicts of Series, arrays, or dicts.</span>
<span class="sd">    read_csv</span>
<span class="sd">    read_table</span>
<span class="sd">    read_clipboard</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Constructing DataFrame from a dictionary.</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame(data=d)</span>
<span class="sd">    &gt;&gt;&gt; df</span>
<span class="sd">       col1  col2</span>
<span class="sd">    0     1     3</span>
<span class="sd">    1     2     4</span>

<span class="sd">    Notice that the inferred dtype is int64.</span>

<span class="sd">    &gt;&gt;&gt; df.dtypes</span>
<span class="sd">    col1    int64</span>
<span class="sd">    col2    int64</span>
<span class="sd">    dtype: object</span>

<span class="sd">    To enforce a single dtype:</span>

<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame(data=d, dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; df.dtypes</span>
<span class="sd">    col1    int8</span>
<span class="sd">    col2    int8</span>
<span class="sd">    dtype: object</span>

<span class="sd">    Constructing DataFrame from numpy ndarray:</span>

<span class="sd">    &gt;&gt;&gt; df2 = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),</span>
<span class="sd">    ...                    columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    &gt;&gt;&gt; df2</span>
<span class="sd">       a  b  c</span>
<span class="sd">    0  1  2  3</span>
<span class="sd">    1  4  5  6</span>
<span class="sd">    2  7  8  9</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_typ</span> <span class="o">=</span> <span class="s2">&quot;dataframe&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">DataFrame</span>

    <span class="n">_constructor_sliced</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span>
    <span class="n">_deprecations</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">_deprecations</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">([])</span>
    <span class="n">_accessors</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sparse&quot;</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not supported for DataFrames!&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dtype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_data</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_mgr</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">numpy.ma.mrecords</span> <span class="k">as</span> <span class="nn">mrecords</span>

            <span class="c1"># masked recarray</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mrecords</span><span class="o">.</span><span class="n">MaskedRecords</span><span class="p">):</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">masked_rec_array_to_mgr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

            <span class="c1"># a masked array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maybe_upcast</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">soften_mask</span><span class="p">()</span>  <span class="c1"># set hardmask False if it was True</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_ndarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">data_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data_columns</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">columns</span> <span class="o">=</span> <span class="n">data_columns</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_dict</span><span class="p">({</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">data</span><span class="p">},</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_ndarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="c1"># For data is list-like, or Iterable (will consume into list)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">)):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_named_tuple</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">columns</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_fields</span>
                    <span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">to_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

                    <span class="c1"># set the index</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Series</span><span class="p">):</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="n">get_names_from_index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Categorical</span><span class="p">):</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

                    <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_ndarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_dict</span><span class="p">({},</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">exc</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;DataFrame constructor called with &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;incompatible data and dtype: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">exc</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">cast_scalar_to_array</span><span class="p">(</span>
                    <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)),</span> <span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span>
                <span class="p">)</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">init_ndarray</span><span class="p">(</span>
                    <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataFrame constructor not properly called!&quot;</span><span class="p">)</span>

        <span class="n">NDFrame</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Index</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list representing the axes of the DataFrame.</span>

<span class="sd">        It has the row axis labels and column axis labels as the only members.</span>
<span class="sd">        They are returned in that order.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.axes</span>
<span class="sd">        [RangeIndex(start=0, stop=2, step=1), Index([&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">        dtype=&#39;object&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple representing the dimensionality of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.shape</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.shape</span>
<span class="sd">        (2, 2)</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4],</span>
<span class="sd">        ...                    &#39;col3&#39;: [5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.shape</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_homogeneous_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether all the columns in a DataFrame have the same type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index._is_homogeneous_type : Whether the object has a single</span>
<span class="sd">            dtype.</span>
<span class="sd">        MultiIndex._is_homogeneous_type : Whether all the levels of a</span>
<span class="sd">            MultiIndex have the same dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3, 4]})._is_homogeneous_type</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3.0, 4.0]})._is_homogeneous_type</span>
<span class="sd">        False</span>

<span class="sd">        Items with the same type but different sizes are considered</span>
<span class="sd">        different types.</span>

<span class="sd">        &gt;&gt;&gt; DataFrame({</span>
<span class="sd">        ...    &quot;A&quot;: np.array([1, 2], dtype=np.int32),</span>
<span class="sd">        ...    &quot;B&quot;: np.array([1, 2], dtype=np.int64)})._is_homogeneous_type</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">any_extension_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="n">block</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_mixed_type</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">_repr_fits_vertical_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check length against max_rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_rows</span>

    <span class="k">def</span> <span class="nf">_repr_fits_horizontal_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_width</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if full repr fits in horizontal boundaries imposed by the display</span>
<span class="sd">        options width and max_columns.</span>

<span class="sd">        In case off non-interactive session, no boundaries apply.</span>

<span class="sd">        `ignore_width` is here so ipnb+HTML output can behave the way</span>
<span class="sd">        users expect. display.max_columns remains in effect.</span>
<span class="sd">        GH3541, GH3573</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">console</span><span class="o">.</span><span class="n">get_console_size</span><span class="p">()</span>
        <span class="n">max_columns</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_columns&quot;</span><span class="p">)</span>
        <span class="n">nb_columns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># exceed max columns</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_columns</span> <span class="ow">and</span> <span class="n">nb_columns</span> <span class="o">&gt;</span> <span class="n">max_columns</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="n">ignore_width</span><span class="p">)</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">and</span> <span class="n">nb_columns</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># used by repr_html under IPython notebook or scripts ignore terminal</span>
        <span class="c1"># dims</span>
        <span class="k">if</span> <span class="n">ignore_width</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">console</span><span class="o">.</span><span class="n">in_interactive_session</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.width&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">console</span><span class="o">.</span><span class="n">in_ipython_frontend</span><span class="p">():</span>
            <span class="c1"># check at least the column row for excessive width</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>

        <span class="c1"># when auto-detecting, so width=None and not in ipython front end</span>
        <span class="c1"># check whether repr fits horizontal by actually checking</span>
        <span class="c1"># the width of the rendered repr</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>

        <span class="c1"># only care about the stuff we&#39;ll actually print out</span>
        <span class="c1"># and to_string on entire frame may be expensive</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">max_rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>  <span class="c1"># unlimited rows</span>
            <span class="c1"># min of two, where one may be None</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_rows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">d</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="n">repr_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">repr_width</span> <span class="o">&lt;</span> <span class="n">width</span>

    <span class="k">def</span> <span class="nf">_info_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the repr should show the info view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info_repr_option</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.large_repr&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;info&quot;</span>
        <span class="k">return</span> <span class="n">info_repr_option</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repr_fits_horizontal_</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_fits_vertical_</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for a particular DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_repr</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

        <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
        <span class="n">min_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.min_rows&quot;</span><span class="p">)</span>
        <span class="n">max_cols</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_columns&quot;</span><span class="p">)</span>
        <span class="n">max_colwidth</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_colwidth&quot;</span><span class="p">)</span>
        <span class="n">show_dimensions</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.show_dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.expand_frame_repr&quot;</span><span class="p">):</span>
            <span class="n">width</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">console</span><span class="o">.</span><span class="n">get_console_size</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span>
            <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
            <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
            <span class="n">min_rows</span><span class="o">=</span><span class="n">min_rows</span><span class="p">,</span>
            <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
            <span class="n">line_width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">max_colwidth</span><span class="o">=</span><span class="n">max_colwidth</span><span class="p">,</span>
            <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a html representation for a particular DataFrame.</span>

<span class="sd">        Mainly for IPython notebook.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_repr</span><span class="p">():</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
            <span class="c1"># need to escape the &lt;class&gt;, should be the first line.</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;&amp;lt;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;&amp;gt;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;pre&gt;&quot;</span> <span class="o">+</span> <span class="n">val</span> <span class="o">+</span> <span class="s2">&quot;&lt;/pre&gt;&quot;</span>

        <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.notebook_repr_html&quot;</span><span class="p">):</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
            <span class="n">min_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.min_rows&quot;</span><span class="p">)</span>
            <span class="n">max_cols</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_columns&quot;</span><span class="p">)</span>
            <span class="n">show_dimensions</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.show_dimensions&quot;</span><span class="p">)</span>

            <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameFormatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">col_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">na_rep</span><span class="o">=</span><span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
                <span class="n">formatters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">sparsify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">justify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">index_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">bold_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">escape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
                <span class="n">min_rows</span><span class="o">=</span><span class="n">min_rows</span><span class="p">,</span>
                <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
                <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
                <span class="n">decimal</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
                <span class="n">table_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">render_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span><span class="n">notebook</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">header_type</span><span class="o">=</span><span class="s2">&quot;bool or sequence&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Write out the column names. If a list of strings &quot;</span>
        <span class="s2">&quot;is given, it is assumed to be aliases for the &quot;</span>
        <span class="s2">&quot;column names&quot;</span><span class="p">,</span>
        <span class="n">col_space_type</span><span class="o">=</span><span class="s2">&quot;int&quot;</span><span class="p">,</span>
        <span class="n">col_space</span><span class="o">=</span><span class="s2">&quot;The minimum width of each column&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">shared_params</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">common_docstring</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">return_docstring</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FilePathOrBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">fmt</span><span class="o">.</span><span class="n">formatters_type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">fmt</span><span class="o">.</span><span class="n">float_format_type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_rows</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">line_width</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_colwidth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a DataFrame to a console-friendly tabular output.</span>
<span class="sd">        %(shared_params)s</span>
<span class="sd">        line_width : int, optional</span>
<span class="sd">            Width to wrap a line in characters.</span>
<span class="sd">        max_colwidth : int, optional</span>
<span class="sd">            Max width to truncate each column in characters. By default, no limit.</span>

<span class="sd">            .. versionadded:: 1.0.0</span>
<span class="sd">        encoding : str, default &quot;utf-8&quot;</span>
<span class="sd">            Set character encoding.</span>

<span class="sd">            .. versionadded:: 1.0</span>
<span class="sd">        %(returns)s</span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_html : Convert DataFrame to HTML.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2, 3], &#39;col2&#39;: [4, 5, 6]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(d)</span>
<span class="sd">        &gt;&gt;&gt; print(df.to_string())</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     4</span>
<span class="sd">        1     2     5</span>
<span class="sd">        2     3     6</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">option_context</span>

        <span class="k">with</span> <span class="n">option_context</span><span class="p">(</span><span class="s2">&quot;display.max_colwidth&quot;</span><span class="p">,</span> <span class="n">max_colwidth</span><span class="p">):</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameFormatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">col_space</span><span class="o">=</span><span class="n">col_space</span><span class="p">,</span>
                <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                <span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">,</span>
                <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                <span class="n">sparsify</span><span class="o">=</span><span class="n">sparsify</span><span class="p">,</span>
                <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
                <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">min_rows</span><span class="o">=</span><span class="n">min_rows</span><span class="p">,</span>
                <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
                <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
                <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
                <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
                <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">style</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Styler&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Styler object.</span>

<span class="sd">        Contains methods for building a styled HTML representation of the DataFrame.</span>
<span class="sd">        a styled HTML representation fo the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        io.formats.style.Styler</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.style</span> <span class="kn">import</span> <span class="n">Styler</span>

        <span class="k">return</span> <span class="n">Styler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;items&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Iterate over (column name, Series) pairs.</span>

<span class="s2">        Iterates over the DataFrame columns, returning a tuple with</span>
<span class="s2">        the column name and the content as a Series.</span>

<span class="s2">        Yields</span>
<span class="s2">        ------</span>
<span class="s2">        label : object</span>
<span class="s2">            The column names for the DataFrame being iterated over.</span>
<span class="s2">        content : Series</span>
<span class="s2">            The column entries belonging to each label, as a Series.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.iterrows : Iterate over DataFrame rows as</span>
<span class="s2">            (index, Series) pairs.</span>
<span class="s2">        DataFrame.itertuples : Iterate over DataFrame rows as namedtuples</span>
<span class="s2">            of the values.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;species&#39;: [&#39;bear&#39;, &#39;bear&#39;, &#39;marsupial&#39;],</span>
<span class="s2">        ...                   &#39;population&#39;: [1864, 22000, 80000]},</span>
<span class="s2">        ...                   index=[&#39;panda&#39;, &#39;polar&#39;, &#39;koala&#39;])</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">                species   population</span>
<span class="s2">        panda   bear      1864</span>
<span class="s2">        polar   bear      22000</span>
<span class="s2">        koala   marsupial 80000</span>
<span class="s2">        &gt;&gt;&gt; for label, content in df.items():</span>
<span class="s2">        ...     print(&#39;label:&#39;, label)</span>
<span class="s2">        ...     print(&#39;content:&#39;, content, sep=&#39;\n&#39;)</span>
<span class="s2">        ...</span>
<span class="s2">        label: species</span>
<span class="s2">        content:</span>
<span class="s2">        panda         bear</span>
<span class="s2">        polar         bear</span>
<span class="s2">        koala    marsupial</span>
<span class="s2">        Name: species, dtype: object</span>
<span class="s2">        label: population</span>
<span class="s2">        content:</span>
<span class="s2">        panda     1864</span>
<span class="s2">        polar    22000</span>
<span class="s2">        koala    80000</span>
<span class="s2">        Name: population, dtype: int64</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">Series</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_item_cache&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">Series</span><span class="p">]]:</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterrows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">],</span> <span class="n">Series</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over DataFrame rows as (index, Series) pairs.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        index : label or tuple of label</span>
<span class="sd">            The index of the row. A tuple for a `MultiIndex`.</span>
<span class="sd">        data : Series</span>
<span class="sd">            The data of the row as a Series.</span>

<span class="sd">        it : generator</span>
<span class="sd">            A generator that iterates over the rows of the frame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.itertuples : Iterate over DataFrame rows as namedtuples of the values.</span>
<span class="sd">        DataFrame.items : Iterate over (column name, Series) pairs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        1. Because ``iterrows`` returns a Series for each row,</span>
<span class="sd">           it does **not** preserve dtypes across the rows (dtypes are</span>
<span class="sd">           preserved across columns for DataFrames). For example,</span>

<span class="sd">           &gt;&gt;&gt; df = pd.DataFrame([[1, 1.5]], columns=[&#39;int&#39;, &#39;float&#39;])</span>
<span class="sd">           &gt;&gt;&gt; row = next(df.iterrows())[1]</span>
<span class="sd">           &gt;&gt;&gt; row</span>
<span class="sd">           int      1.0</span>
<span class="sd">           float    1.5</span>
<span class="sd">           Name: 0, dtype: float64</span>
<span class="sd">           &gt;&gt;&gt; print(row[&#39;int&#39;].dtype)</span>
<span class="sd">           float64</span>
<span class="sd">           &gt;&gt;&gt; print(df[&#39;int&#39;].dtype)</span>
<span class="sd">           int64</span>

<span class="sd">           To preserve dtypes while iterating over the rows, it is better</span>
<span class="sd">           to use :meth:`itertuples` which returns namedtuples of the values</span>
<span class="sd">           and which is generally faster than ``iterrows``.</span>

<span class="sd">        2. You should **never modify** something you are iterating over.</span>
<span class="sd">           This is not guaranteed to work in all cases. Depending on the</span>
<span class="sd">           data types, the iterator returns a copy and not a view, and writing</span>
<span class="sd">           to it will have no effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">klass</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">itertuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Pandas&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over DataFrame rows as namedtuples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            If True, return the index as the first element of the tuple.</span>
<span class="sd">        name : str or None, default &quot;Pandas&quot;</span>
<span class="sd">            The name of the returned namedtuples or None to return regular</span>
<span class="sd">            tuples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator</span>
<span class="sd">            An object to iterate over namedtuples for each row in the</span>
<span class="sd">            DataFrame with the first field possibly being the index and</span>
<span class="sd">            following fields being the column values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.iterrows : Iterate over DataFrame rows as (index, Series)</span>
<span class="sd">            pairs.</span>
<span class="sd">        DataFrame.items : Iterate over (column name, Series) pairs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The column names will be renamed to positional names if they are</span>
<span class="sd">        invalid Python identifiers, repeated, or start with an underscore.</span>
<span class="sd">        On python versions &lt; 3.7 regular tuples are returned for DataFrames</span>
<span class="sd">        with a large number of columns (&gt;254).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [4, 2], &#39;num_wings&#39;: [0, 2]},</span>
<span class="sd">        ...                   index=[&#39;dog&#39;, &#39;hawk&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              num_legs  num_wings</span>
<span class="sd">        dog          4          0</span>
<span class="sd">        hawk         2          2</span>
<span class="sd">        &gt;&gt;&gt; for row in df.itertuples():</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        ...</span>
<span class="sd">        Pandas(Index=&#39;dog&#39;, num_legs=4, num_wings=0)</span>
<span class="sd">        Pandas(Index=&#39;hawk&#39;, num_legs=2, num_wings=2)</span>

<span class="sd">        By setting the `index` parameter to False we can remove the index</span>
<span class="sd">        as the first element of the tuple:</span>

<span class="sd">        &gt;&gt;&gt; for row in df.itertuples(index=False):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        ...</span>
<span class="sd">        Pandas(num_legs=4, num_wings=0)</span>
<span class="sd">        Pandas(num_legs=2, num_wings=2)</span>

<span class="sd">        With the `name` parameter set we set a custom name for the yielded</span>
<span class="sd">        namedtuples:</span>

<span class="sd">        &gt;&gt;&gt; for row in df.itertuples(name=&#39;Animal&#39;):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        ...</span>
<span class="sd">        Animal(Index=&#39;dog&#39;, num_legs=4, num_wings=0)</span>
<span class="sd">        Animal(Index=&#39;hawk&#39;, num_legs=2, num_wings=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Index&quot;</span><span class="p">)</span>

        <span class="c1"># use integer indexing because of possible duplicate column names</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)))</span>

        <span class="c1"># Python versions before 3.7 support at most 255 arguments to constructors</span>
        <span class="n">can_return_named_tuples</span> <span class="o">=</span> <span class="n">PY37</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">255</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">can_return_named_tuples</span><span class="p">:</span>
            <span class="n">itertuple</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">itertuple</span><span class="o">.</span><span class="n">_make</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">))</span>

        <span class="c1"># fallback to regular tuples</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns length of info axis, but here we use the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix multiplication between the DataFrame and other.</span>

<span class="sd">        This method computes the matrix product between the DataFrame and the</span>
<span class="sd">        values of an other Series, DataFrame or a numpy array.</span>

<span class="sd">        It can also be called using ``self @ other`` in Python &gt;= 3.5.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series, DataFrame or array-like</span>
<span class="sd">            The other object to compute the matrix product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            If other is a Series, return the matrix product between self and</span>
<span class="sd">            other as a Serie. If other is a DataFrame or a numpy.array, return</span>
<span class="sd">            the matrix product of self and other in a DataFrame of a np.array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.dot: Similar method for Series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dimensions of DataFrame and other must be compatible in order to</span>
<span class="sd">        compute the matrix multiplication. In addition, the column names of</span>
<span class="sd">        DataFrame and the index of other must contain the same values, as they</span>
<span class="sd">        will be aligned prior to the multiplication.</span>

<span class="sd">        The dot method for Series computes the inner product, instead of the</span>
<span class="sd">        matrix product here.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we multiply a DataFrame with a Series.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[0, 1, -2, -1], [1, 1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 1, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(s)</span>
<span class="sd">        0    -4</span>
<span class="sd">        1     5</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Here we multiply a DataFrame with another DataFrame.</span>

<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame([[0, 1], [1, 2], [-1, -1], [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(other)</span>
<span class="sd">            0   1</span>
<span class="sd">        0   1   4</span>
<span class="sd">        1   2   2</span>

<span class="sd">        Note that the dot method give the same result as @</span>

<span class="sd">        &gt;&gt;&gt; df @ other</span>
<span class="sd">            0   1</span>
<span class="sd">        0   1   4</span>
<span class="sd">        1   2   2</span>

<span class="sd">        The dot method works also if other is an np.array.</span>

<span class="sd">        &gt;&gt;&gt; arr = np.array([[0, 1], [1, 2], [-1, -1], [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(arr)</span>
<span class="sd">            0   1</span>
<span class="sd">        0   1   4</span>
<span class="sd">        1   2   2</span>

<span class="sd">        Note how shuffling of the objects does not change the result.</span>

<span class="sd">        &gt;&gt;&gt; s2 = s.reindex([1, 0, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(s2)</span>
<span class="sd">        0    -4</span>
<span class="sd">        1     5</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">common</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrices are not aligned&quot;</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dot product shape mismatch, </span><span class="si">{</span><span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix multiplication using binary `@` operator in Python&gt;=3.5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix multiplication using binary `@` operator in Python&gt;=3.5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># IO methods (to / from other formats)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct DataFrame from dict of array-like or dicts.</span>

<span class="sd">        Creates DataFrame object from dictionary by columns or by index</span>
<span class="sd">        allowing dtype specification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : dict</span>
<span class="sd">            Of the form {field : array-like} or {field : dict}.</span>
<span class="sd">        orient : {&#39;columns&#39;, &#39;index&#39;}, default &#39;columns&#39;</span>
<span class="sd">            The &quot;orientation&quot; of the data. If the keys of the passed dict</span>
<span class="sd">            should be the columns of the resulting DataFrame, pass &#39;columns&#39;</span>
<span class="sd">            (default). Otherwise if the keys should be rows, pass &#39;index&#39;.</span>
<span class="sd">        dtype : dtype, default None</span>
<span class="sd">            Data type to force, otherwise infer.</span>
<span class="sd">        columns : list, default None</span>
<span class="sd">            Column labels to use when ``orient=&#39;index&#39;``. Raises a ValueError</span>
<span class="sd">            if used with ``orient=&#39;columns&#39;``.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_records : DataFrame from ndarray (structured</span>
<span class="sd">            dtype), list of tuples, dict, or DataFrame.</span>
<span class="sd">        DataFrame : DataFrame object creation using constructor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        By default the keys of the dict become the DataFrame columns:</span>

<span class="sd">        &gt;&gt;&gt; data = {&#39;col_1&#39;: [3, 2, 1, 0], &#39;col_2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data)</span>
<span class="sd">           col_1 col_2</span>
<span class="sd">        0      3     a</span>
<span class="sd">        1      2     b</span>
<span class="sd">        2      1     c</span>
<span class="sd">        3      0     d</span>

<span class="sd">        Specify ``orient=&#39;index&#39;`` to create the DataFrame using dictionary</span>
<span class="sd">        keys as rows:</span>

<span class="sd">        &gt;&gt;&gt; data = {&#39;row_1&#39;: [3, 2, 1, 0], &#39;row_2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data, orient=&#39;index&#39;)</span>
<span class="sd">               0  1  2  3</span>
<span class="sd">        row_1  3  2  1  0</span>
<span class="sd">        row_2  a  b  c  d</span>

<span class="sd">        When using the &#39;index&#39; orientation, the column names can be</span>
<span class="sd">        specified manually:</span>

<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data, orient=&#39;index&#39;,</span>
<span class="sd">        ...                        columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="sd">               A  B  C  D</span>
<span class="sd">        row_1  3  2  1  0</span>
<span class="sd">        row_2  a  b  c  d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orient</span> <span class="o">=</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">orient</span> <span class="o">==</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># TODO speed up Series case</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">_from_nested_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">orient</span> <span class="o">==</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot use columns parameter with orient=&#39;columns&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only recognize index or columns for orient&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the DataFrame to a NumPy array.</span>

<span class="sd">        .. versionadded:: 0.24.0</span>

<span class="sd">        By default, the dtype of the returned array will be the common NumPy</span>
<span class="sd">        dtype of all types in the DataFrame. For example, if the dtypes are</span>
<span class="sd">        ``float16`` and ``float32``, the results dtype will be ``float32``.</span>
<span class="sd">        This may require copying data and coercing values, which may be</span>
<span class="sd">        expensive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or numpy.dtype, optional</span>
<span class="sd">            The dtype to pass to :meth:`numpy.asarray`.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to ensure that the returned value is a not a view on</span>
<span class="sd">            another array. Note that ``copy=False`` does not *ensure* that</span>
<span class="sd">            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that</span>
<span class="sd">            a copy is made, even if not strictly necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.to_numpy : Similar method for Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3, 4]}).to_numpy()</span>
<span class="sd">        array([[1, 3],</span>
<span class="sd">               [2, 4]])</span>

<span class="sd">        With heterogeneous data, the lowest common type will have to</span>
<span class="sd">        be used.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3.0, 4.5]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_numpy()</span>
<span class="sd">        array([[1. , 3. ],</span>
<span class="sd">               [2. , 4.5]])</span>

<span class="sd">        For a mix of numeric and non-numeric types, the output array will</span>
<span class="sd">        have object dtype.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;C&#39;] = pd.date_range(&#39;2000&#39;, periods=2)</span>
<span class="sd">        &gt;&gt;&gt; df.to_numpy()</span>
<span class="sd">        array([[1, 3.0, Timestamp(&#39;2000-01-01 00:00:00&#39;)],</span>
<span class="sd">               [2, 4.5, Timestamp(&#39;2000-01-02 00:00:00&#39;)]], dtype=object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s2">&quot;dict&quot;</span><span class="p">,</span> <span class="n">into</span><span class="o">=</span><span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the DataFrame to a dictionary.</span>

<span class="sd">        The type of the key-value pairs can be customized with the parameters</span>
<span class="sd">        (see below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orient : str {&#39;dict&#39;, &#39;list&#39;, &#39;series&#39;, &#39;split&#39;, &#39;records&#39;, &#39;index&#39;}</span>
<span class="sd">            Determines the type of the values of the dictionary.</span>

<span class="sd">            - &#39;dict&#39; (default) : dict like {column -&gt; {index -&gt; value}}</span>
<span class="sd">            - &#39;list&#39; : dict like {column -&gt; [values]}</span>
<span class="sd">            - &#39;series&#39; : dict like {column -&gt; Series(values)}</span>
<span class="sd">            - &#39;split&#39; : dict like</span>
<span class="sd">              {&#39;index&#39; -&gt; [index], &#39;columns&#39; -&gt; [columns], &#39;data&#39; -&gt; [values]}</span>
<span class="sd">            - &#39;records&#39; : list like</span>
<span class="sd">              [{column -&gt; value}, ... , {column -&gt; value}]</span>
<span class="sd">            - &#39;index&#39; : dict like {index -&gt; {column -&gt; value}}</span>

<span class="sd">            Abbreviations are allowed. `s` indicates `series` and `sp`</span>
<span class="sd">            indicates `split`.</span>

<span class="sd">        into : class, default dict</span>
<span class="sd">            The collections.abc.Mapping subclass used for all Mappings</span>
<span class="sd">            in the return value.  Can be the actual class or an empty</span>
<span class="sd">            instance of the mapping type you want.  If you want a</span>
<span class="sd">            collections.defaultdict, you must pass it initialized.</span>

<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict, list or collections.abc.Mapping</span>
<span class="sd">            Return a collections.abc.Mapping object representing the DataFrame.</span>
<span class="sd">            The resulting transformation depends on the `orient` parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_dict: Create a DataFrame from a dictionary.</span>
<span class="sd">        DataFrame.to_json: Convert a DataFrame to JSON format.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2],</span>
<span class="sd">        ...                    &#39;col2&#39;: [0.5, 0.75]},</span>
<span class="sd">        ...                   index=[&#39;row1&#39;, &#39;row2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              col1  col2</span>
<span class="sd">        row1     1  0.50</span>
<span class="sd">        row2     2  0.75</span>
<span class="sd">        &gt;&gt;&gt; df.to_dict()</span>
<span class="sd">        {&#39;col1&#39;: {&#39;row1&#39;: 1, &#39;row2&#39;: 2}, &#39;col2&#39;: {&#39;row1&#39;: 0.5, &#39;row2&#39;: 0.75}}</span>

<span class="sd">        You can specify the return orientation.</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;series&#39;)</span>
<span class="sd">        {&#39;col1&#39;: row1    1</span>
<span class="sd">                 row2    2</span>
<span class="sd">        Name: col1, dtype: int64,</span>
<span class="sd">        &#39;col2&#39;: row1    0.50</span>
<span class="sd">                row2    0.75</span>
<span class="sd">        Name: col2, dtype: float64}</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;split&#39;)</span>
<span class="sd">        {&#39;index&#39;: [&#39;row1&#39;, &#39;row2&#39;], &#39;columns&#39;: [&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">         &#39;data&#39;: [[1, 0.5], [2, 0.75]]}</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;records&#39;)</span>
<span class="sd">        [{&#39;col1&#39;: 1, &#39;col2&#39;: 0.5}, {&#39;col1&#39;: 2, &#39;col2&#39;: 0.75}]</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;index&#39;)</span>
<span class="sd">        {&#39;row1&#39;: {&#39;col1&#39;: 1, &#39;col2&#39;: 0.5}, &#39;row2&#39;: {&#39;col1&#39;: 2, &#39;col2&#39;: 0.75}}</span>

<span class="sd">        You can also specify the mapping type.</span>

<span class="sd">        &gt;&gt;&gt; from collections import OrderedDict, defaultdict</span>
<span class="sd">        &gt;&gt;&gt; df.to_dict(into=OrderedDict)</span>
<span class="sd">        OrderedDict([(&#39;col1&#39;, OrderedDict([(&#39;row1&#39;, 1), (&#39;row2&#39;, 2)])),</span>
<span class="sd">                     (&#39;col2&#39;, OrderedDict([(&#39;row1&#39;, 0.5), (&#39;row2&#39;, 0.75)]))])</span>

<span class="sd">        If you want a `defaultdict`, you need to initialize it:</span>

<span class="sd">        &gt;&gt;&gt; dd = defaultdict(list)</span>
<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;records&#39;, into=dd)</span>
<span class="sd">        [defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;col1&#39;: 1, &#39;col2&#39;: 0.5}),</span>
<span class="sd">         defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;col1&#39;: 2, &#39;col2&#39;: 0.75})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;DataFrame columns are not unique, some columns will be omitted.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># GH16122</span>
        <span class="n">into_c</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">standardize_mapping</span><span class="p">(</span><span class="n">into</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">into_c</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">into</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">into_c</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;sp&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">into_c</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                    <span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;data&quot;</span><span class="p">,</span>
                        <span class="p">[</span>
                            <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">maybe_box_datetimelike</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                        <span class="p">],</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">into_c</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_box_datetimelike</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">into_c</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_box_datetimelike</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataFrame index must be unique for orient=&#39;index&#39;.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">into_c</span><span class="p">(</span>
                <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;orient &#39;</span><span class="si">{</span><span class="n">orient</span><span class="si">}</span><span class="s2">&#39; not understood&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_gbq</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">destination_table</span><span class="p">,</span>
        <span class="n">project_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reauth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">if_exists</span><span class="o">=</span><span class="s2">&quot;fail&quot;</span><span class="p">,</span>
        <span class="n">auth_local_webserver</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">table_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">credentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a DataFrame to a Google BigQuery table.</span>

<span class="sd">        This function requires the `pandas-gbq package</span>
<span class="sd">        &lt;https://pandas-gbq.readthedocs.io&gt;`__.</span>

<span class="sd">        See the `How to authenticate with Google BigQuery</span>
<span class="sd">        &lt;https://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html&gt;`__</span>
<span class="sd">        guide for authentication instructions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        destination_table : str</span>
<span class="sd">            Name of table to be written, in the form ``dataset.tablename``.</span>
<span class="sd">        project_id : str, optional</span>
<span class="sd">            Google BigQuery Account project ID. Optional when available from</span>
<span class="sd">            the environment.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Number of rows to be inserted in each chunk from the dataframe.</span>
<span class="sd">            Set to ``None`` to load the whole dataframe at once.</span>
<span class="sd">        reauth : bool, default False</span>
<span class="sd">            Force Google BigQuery to re-authenticate the user. This is useful</span>
<span class="sd">            if multiple accounts are used.</span>
<span class="sd">        if_exists : str, default &#39;fail&#39;</span>
<span class="sd">            Behavior when the destination table exists. Value can be one of:</span>

<span class="sd">            ``&#39;fail&#39;``</span>
<span class="sd">                If table exists raise pandas_gbq.gbq.TableCreationError.</span>
<span class="sd">            ``&#39;replace&#39;``</span>
<span class="sd">                If table exists, drop it, recreate it, and insert data.</span>
<span class="sd">            ``&#39;append&#39;``</span>
<span class="sd">                If table exists, insert data. Create if does not exist.</span>
<span class="sd">        auth_local_webserver : bool, default False</span>
<span class="sd">            Use the `local webserver flow`_ instead of the `console flow`_</span>
<span class="sd">            when getting user credentials.</span>

<span class="sd">            .. _local webserver flow:</span>
<span class="sd">                http://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_local_server</span>
<span class="sd">            .. _console flow:</span>
<span class="sd">                http://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_console</span>

<span class="sd">            *New in version 0.2.0 of pandas-gbq*.</span>
<span class="sd">        table_schema : list of dicts, optional</span>
<span class="sd">            List of BigQuery table fields to which according DataFrame</span>
<span class="sd">            columns conform to, e.g. ``[{&#39;name&#39;: &#39;col1&#39;, &#39;type&#39;:</span>
<span class="sd">            &#39;STRING&#39;},...]``. If schema is not provided, it will be</span>
<span class="sd">            generated according to dtypes of DataFrame columns. See</span>
<span class="sd">            BigQuery API documentation on available names of a field.</span>

<span class="sd">            *New in version 0.3.1 of pandas-gbq*.</span>
<span class="sd">        location : str, optional</span>
<span class="sd">            Location where the load job should run. See the `BigQuery locations</span>
<span class="sd">            documentation</span>
<span class="sd">            &lt;https://cloud.google.com/bigquery/docs/dataset-locations&gt;`__ for a</span>
<span class="sd">            list of available locations. The location must match that of the</span>
<span class="sd">            target dataset.</span>

<span class="sd">            *New in version 0.5.0 of pandas-gbq*.</span>
<span class="sd">        progress_bar : bool, default True</span>
<span class="sd">            Use the library `tqdm` to show the progress bar for the upload,</span>
<span class="sd">            chunk by chunk.</span>

<span class="sd">            *New in version 0.5.0 of pandas-gbq*.</span>
<span class="sd">        credentials : google.auth.credentials.Credentials, optional</span>
<span class="sd">            Credentials for accessing Google APIs. Use this parameter to</span>
<span class="sd">            override default credentials, such as to use Compute Engine</span>
<span class="sd">            :class:`google.auth.compute_engine.Credentials` or Service</span>
<span class="sd">            Account :class:`google.oauth2.service_account.Credentials`</span>
<span class="sd">            directly.</span>

<span class="sd">            *New in version 0.8.0 of pandas-gbq*.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas_gbq.to_gbq : This function in the pandas-gbq library.</span>
<span class="sd">        read_gbq : Read a DataFrame from Google BigQuery.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">gbq</span>

        <span class="n">gbq</span><span class="o">.</span><span class="n">to_gbq</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">destination_table</span><span class="p">,</span>
            <span class="n">project_id</span><span class="o">=</span><span class="n">project_id</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">reauth</span><span class="o">=</span><span class="n">reauth</span><span class="p">,</span>
            <span class="n">if_exists</span><span class="o">=</span><span class="n">if_exists</span><span class="p">,</span>
            <span class="n">auth_local_webserver</span><span class="o">=</span><span class="n">auth_local_webserver</span><span class="p">,</span>
            <span class="n">table_schema</span><span class="o">=</span><span class="n">table_schema</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
            <span class="n">credentials</span><span class="o">=</span><span class="n">credentials</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_records</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coerce_float</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nrows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert structured or record ndarray to DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : ndarray (structured dtype), list of tuples, dict, or DataFrame</span>
<span class="sd">        index : str, list of fields, array-like</span>
<span class="sd">            Field of array to use as the index, alternately a specific set of</span>
<span class="sd">            input labels to use.</span>
<span class="sd">        exclude : sequence, default None</span>
<span class="sd">            Columns or fields to exclude.</span>
<span class="sd">        columns : sequence, default None</span>
<span class="sd">            Column names to use. If the passed data do not have names</span>
<span class="sd">            associated with them, this argument provides names for the</span>
<span class="sd">            columns. Otherwise this argument indicates the order of the columns</span>
<span class="sd">            in the result (any names not found in the data will become all-NA</span>
<span class="sd">            columns).</span>
<span class="sd">        coerce_float : bool, default False</span>
<span class="sd">            Attempt to convert values of non-string, non-numeric objects (like</span>
<span class="sd">            decimal.Decimal) to floating point, useful for SQL result sets.</span>
<span class="sd">        nrows : int, default None</span>
<span class="sd">            Number of rows to read if data is an iterator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make a copy of the input columns so we can modify it</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nrows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">first_row</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">first_row</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">first_row</span><span class="o">.</span><span class="n">dtype</span>

            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_row</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">nrows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">+=</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">values</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">arr_columns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                        <span class="n">arr_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">reorder_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">to_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">to_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">coerce_float</span><span class="o">=</span><span class="n">coerce_float</span><span class="p">)</span>

            <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">arr_columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">arr_columns</span>

        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">result_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">exclude</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">[</span><span class="n">arr_columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">field</span><span class="p">)]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                    <span class="c1"># raised by get_loc, see GH#29258</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">ensure_index_from_sequences</span><span class="p">(</span><span class="n">index_data</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">exclude</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="n">arr_exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exclude</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr_columns</span><span class="p">]</span>
            <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr_columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">arr_exclude</span><span class="p">]</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">]</span>

            <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">arr_columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">arr_exclude</span><span class="p">)</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">result_index</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_records</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">column_dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_dtypes</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert DataFrame to a NumPy record array.</span>

<span class="sd">        Index will be included as the first field of the record array if</span>
<span class="sd">        requested.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Include index in resulting record array, stored in &#39;index&#39;</span>
<span class="sd">            field or using the index label, if set.</span>
<span class="sd">        column_dtypes : str, type, dict, default None</span>
<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">            If a string or type, the data type to store all columns. If</span>
<span class="sd">            a dictionary, a mapping of column names and indices (zero-indexed)</span>
<span class="sd">            to specific data types.</span>
<span class="sd">        index_dtypes : str, type, dict, default None</span>
<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">            If a string or type, the data type to store all index levels. If</span>
<span class="sd">            a dictionary, a mapping of index level names and indices</span>
<span class="sd">            (zero-indexed) to specific data types.</span>

<span class="sd">            This mapping is applied only if `index=True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.recarray</span>
<span class="sd">            NumPy ndarray with the DataFrame labels as fields and each row</span>
<span class="sd">            of the DataFrame as entries.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_records: Convert structured or record ndarray</span>
<span class="sd">            to DataFrame.</span>
<span class="sd">        numpy.recarray: An ndarray that allows field access using</span>
<span class="sd">            attributes, analogous to typed columns in a</span>
<span class="sd">            spreadsheet.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2], &#39;B&#39;: [0.5, 0.75]},</span>
<span class="sd">        ...                   index=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A     B</span>
<span class="sd">        a  1  0.50</span>
<span class="sd">        b  2  0.75</span>
<span class="sd">        &gt;&gt;&gt; df.to_records()</span>
<span class="sd">        rec.array([(&#39;a&#39;, 1, 0.5 ), (&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;index&#39;, &#39;O&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        If the DataFrame index has no label then the recarray field name</span>
<span class="sd">        is set to &#39;index&#39;. If the index has a label then this is used as the</span>
<span class="sd">        field name:</span>

<span class="sd">        &gt;&gt;&gt; df.index = df.index.rename(&quot;I&quot;)</span>
<span class="sd">        &gt;&gt;&gt; df.to_records()</span>
<span class="sd">        rec.array([(&#39;a&#39;, 1, 0.5 ), (&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;O&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        The index can be excluded from the record array:</span>

<span class="sd">        &gt;&gt;&gt; df.to_records(index=False)</span>
<span class="sd">        rec.array([(1, 0.5 ), (2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        Data types can be specified for the columns:</span>

<span class="sd">        &gt;&gt;&gt; df.to_records(column_dtypes={&quot;A&quot;: &quot;int32&quot;})</span>
<span class="sd">        rec.array([(&#39;a&#39;, 1, 0.5 ), (&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;O&#39;), (&#39;A&#39;, &#39;&lt;i4&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        As well as for the index:</span>

<span class="sd">        &gt;&gt;&gt; df.to_records(index_dtypes=&quot;&lt;S2&quot;)</span>
<span class="sd">        rec.array([(b&#39;a&#39;, 1, 0.5 ), (b&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;S2&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        &gt;&gt;&gt; index_dtypes = f&quot;&lt;S{df.index.str.len().max()}&quot;</span>
<span class="sd">        &gt;&gt;&gt; df.to_records(index_dtypes=index_dtypes)</span>
<span class="sd">        rec.array([(b&#39;a&#39;, 1, 0.5 ), (b&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;S1&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="c1"># array of tuples to numpy cols. copy copy copy</span>
                <span class="n">ix_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ix_vals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

            <span class="n">arrays</span> <span class="o">=</span> <span class="n">ix_vals</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">_internal_get_values</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_names</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">index_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;level_</span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">index_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>

            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">index_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">_internal_get_values</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">index_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_names</span><span class="p">)</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1"># When the names and arrays are collected, we</span>
            <span class="c1"># first collect those in the DataFrame&#39;s index,</span>
            <span class="c1"># followed by those in its columns.</span>
            <span class="c1">#</span>
            <span class="c1"># Thus, the total length of the array is:</span>
            <span class="c1"># len(index_names) + len(DataFrame.columns).</span>
            <span class="c1">#</span>
            <span class="c1"># This check allows us to see whether we are</span>
            <span class="c1"># handling a name / array in the index or column.</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">index_len</span><span class="p">:</span>
                <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">index_dtypes</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">index_names</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">-=</span> <span class="n">index_len</span>
                <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">column_dtypes</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

            <span class="c1"># We have a dictionary, so we get the data type</span>
            <span class="c1"># associated with the index or column (which can</span>
            <span class="c1"># be denoted by its name in the DataFrame or its</span>
            <span class="c1"># position in DataFrame&#39;s array of indices or</span>
            <span class="c1"># columns, whichever is applicable.</span>
            <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">dtype_mapping</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dtype_mapping</span><span class="p">:</span>
                    <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">dtype_mapping</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">dtype_mapping</span><span class="p">:</span>
                    <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">dtype_mapping</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># If no mapping can be found, use the array&#39;s</span>
            <span class="c1"># dtype attribute for formatting.</span>
            <span class="c1">#</span>
            <span class="c1"># A valid dtype must either be a type or</span>
            <span class="c1"># string naming a type.</span>
            <span class="k">if</span> <span class="n">dtype_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">formats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype_mapping</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">formats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtype_mapping</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">element</span> <span class="o">=</span> <span class="s2">&quot;row&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_len</span> <span class="k">else</span> <span class="s2">&quot;column&quot;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid dtype </span><span class="si">{</span><span class="n">dtype_mapping</span><span class="si">}</span><span class="s2"> specified for </span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;formats&quot;</span><span class="p">:</span> <span class="n">formats</span><span class="p">})</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_arrays</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s2">&quot;fname&quot;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_stata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">,</span>
        <span class="n">convert_dates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">write_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">byteorder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_stamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="mi">114</span><span class="p">,</span>
        <span class="n">convert_strl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export DataFrame object to Stata dta format.</span>

<span class="sd">        Writes the DataFrame to a Stata dataset file.</span>
<span class="sd">        &quot;dta&quot; files contain a Stata dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, buffer or path object</span>
<span class="sd">            String, path object (pathlib.Path or py._path.local.LocalPath) or</span>
<span class="sd">            object implementing a binary write() function. If using a buffer</span>
<span class="sd">            then the buffer will not be automatically closed after the file</span>
<span class="sd">            data has been written.</span>

<span class="sd">            .. versionchanged:: 1.0.0</span>

<span class="sd">            Previously this was &quot;fname&quot;</span>

<span class="sd">        convert_dates : dict</span>
<span class="sd">            Dictionary mapping columns containing datetime types to stata</span>
<span class="sd">            internal format to use when writing the dates. Options are &#39;tc&#39;,</span>
<span class="sd">            &#39;td&#39;, &#39;tm&#39;, &#39;tw&#39;, &#39;th&#39;, &#39;tq&#39;, &#39;ty&#39;. Column can be either an integer</span>
<span class="sd">            or a name. Datetime columns that do not have a conversion type</span>
<span class="sd">            specified will be converted to &#39;tc&#39;. Raises NotImplementedError if</span>
<span class="sd">            a datetime column has timezone information.</span>
<span class="sd">        write_index : bool</span>
<span class="sd">            Write the index to Stata dataset.</span>
<span class="sd">        byteorder : str</span>
<span class="sd">            Can be &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;little&quot;, or &quot;big&quot;. default is `sys.byteorder`.</span>
<span class="sd">        time_stamp : datetime</span>
<span class="sd">            A datetime to use as file creation date.  Default is the current</span>
<span class="sd">            time.</span>
<span class="sd">        data_label : str, optional</span>
<span class="sd">            A label for the data set.  Must be 80 characters or smaller.</span>
<span class="sd">        variable_labels : dict</span>
<span class="sd">            Dictionary containing columns as keys and variable labels as</span>
<span class="sd">            values. Each label must be 80 characters or smaller.</span>
<span class="sd">        version : {114, 117, 118, 119, None}, default 114</span>
<span class="sd">            Version to use in the output dta file. Set to None to let pandas</span>
<span class="sd">            decide between 118 or 119 formats depending on the number of</span>
<span class="sd">            columns in the frame. Version 114 can be read by Stata 10 and</span>
<span class="sd">            later. Version 117 can be read by Stata 13 or later. Version 118</span>
<span class="sd">            is supported in Stata 14 and later. Version 119 is supported in</span>
<span class="sd">            Stata 15 and later. Version 114 limits string variables to 244</span>
<span class="sd">            characters or fewer while versions 117 and later allow strings</span>
<span class="sd">            with lengths up to 2,000,000 characters. Versions 118 and 119</span>
<span class="sd">            support Unicode characters, and version 119 supports more than</span>
<span class="sd">            32,767 variables.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>
<span class="sd">            .. versionchanged:: 1.0.0</span>

<span class="sd">                Added support for formats 118 and 119.</span>

<span class="sd">        convert_strl : list, optional</span>
<span class="sd">            List of column names to convert to string columns to Stata StrL</span>
<span class="sd">            format. Only available if version is 117.  Storing strings in the</span>
<span class="sd">            StrL format can produce smaller dta files if strings have more than</span>
<span class="sd">            8 characters and values are repeated.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            * If datetimes contain timezone information</span>
<span class="sd">            * Column dtype is not representable in Stata</span>
<span class="sd">        ValueError</span>
<span class="sd">            * Columns listed in convert_dates are neither datetime64[ns]</span>
<span class="sd">              or datetime.datetime</span>
<span class="sd">            * Column listed in convert_dates is not in DataFrame</span>
<span class="sd">            * Categorical label contains more than 32,000 characters</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_stata : Import Stata data files.</span>
<span class="sd">        io.stata.StataWriter : Low-level writer for Stata data files.</span>
<span class="sd">        io.stata.StataWriter117 : Low-level writer for version 117 files.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;animal&#39;: [&#39;falcon&#39;, &#39;parrot&#39;, &#39;falcon&#39;,</span>
<span class="sd">        ...                               &#39;parrot&#39;],</span>
<span class="sd">        ...                    &#39;speed&#39;: [350, 18, 361, 15]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_stata(&#39;animals.dta&#39;)  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">118</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only formats 114, 117, 118 and 119 are supported.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">114</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">convert_strl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;strl is not supported in format 114&quot;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">pandas.io.stata</span> <span class="kn">import</span> <span class="n">StataWriter</span> <span class="k">as</span> <span class="n">statawriter</span>
        <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">117</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.io.stata</span> <span class="kn">import</span> <span class="n">StataWriter117</span> <span class="k">as</span> <span class="n">statawriter</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># versions 118 and 119</span>
            <span class="kn">from</span> <span class="nn">pandas.io.stata</span> <span class="kn">import</span> <span class="n">StataWriterUTF8</span> <span class="k">as</span> <span class="n">statawriter</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">117</span><span class="p">:</span>
            <span class="c1"># strl conversion is only supported &gt;= 117</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;convert_strl&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_strl</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">118</span><span class="p">:</span>
            <span class="c1"># Specifying the version is only supported for UTF8 (118 or 119)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">version</span>

        <span class="n">writer</span> <span class="o">=</span> <span class="n">statawriter</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">convert_dates</span><span class="o">=</span><span class="n">convert_dates</span><span class="p">,</span>
            <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">,</span>
            <span class="n">time_stamp</span><span class="o">=</span><span class="n">time_stamp</span><span class="p">,</span>
            <span class="n">data_label</span><span class="o">=</span><span class="n">data_label</span><span class="p">,</span>
            <span class="n">write_index</span><span class="o">=</span><span class="n">write_index</span><span class="p">,</span>
            <span class="n">variable_labels</span><span class="o">=</span><span class="n">variable_labels</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write_file</span><span class="p">()</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s2">&quot;fname&quot;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_feather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write out the binary feather-format for DataFrames.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            String file path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.feather_format</span> <span class="kn">import</span> <span class="n">to_feather</span>

        <span class="n">to_feather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     data={&quot;animal_1&quot;: [&quot;elk&quot;, &quot;pig&quot;], &quot;animal_2&quot;: [&quot;dog&quot;, &quot;quetzal&quot;]}</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(df.to_markdown())</span>
<span class="sd">        |    | animal_1   | animal_2   |</span>
<span class="sd">        |---:|:-----------|:-----------|</span>
<span class="sd">        |  0 | elk        | dog        |</span>
<span class="sd">        |  1 | pig        | quetzal    |</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;to_markdown&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">to_markdown</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">IO</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;headers&quot;</span><span class="p">,</span> <span class="s2">&quot;keys&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;tablefmt&quot;</span><span class="p">,</span> <span class="s2">&quot;pipe&quot;</span><span class="p">)</span>
        <span class="n">tabulate</span> <span class="o">=</span> <span class="n">import_optional_dependency</span><span class="p">(</span><span class="s2">&quot;tabulate&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_filepath_or_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">buf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># Help mypy.</span>
        <span class="n">buf</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s2">&quot;fname&quot;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s2">&quot;path&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_parquet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="s2">&quot;snappy&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a DataFrame to the binary parquet format.</span>

<span class="sd">        .. versionadded:: 0.21.0</span>

<span class="sd">        This function writes the dataframe as a `parquet file</span>
<span class="sd">        &lt;https://parquet.apache.org/&gt;`_. You can choose different parquet</span>
<span class="sd">        backends, and have the option of compression. See</span>
<span class="sd">        :ref:`the user guide &lt;io.parquet&gt;` for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            File path or Root Directory path. Will be used as Root Directory</span>
<span class="sd">            path while writing a partitioned dataset.</span>

<span class="sd">            .. versionchanged:: 1.0.0</span>

<span class="sd">            Previously this was &quot;fname&quot;</span>

<span class="sd">        engine : {&#39;auto&#39;, &#39;pyarrow&#39;, &#39;fastparquet&#39;}, default &#39;auto&#39;</span>
<span class="sd">            Parquet library to use. If &#39;auto&#39;, then the option</span>
<span class="sd">            ``io.parquet.engine`` is used. The default ``io.parquet.engine``</span>
<span class="sd">            behavior is to try &#39;pyarrow&#39;, falling back to &#39;fastparquet&#39; if</span>
<span class="sd">            &#39;pyarrow&#39; is unavailable.</span>
<span class="sd">        compression : {&#39;snappy&#39;, &#39;gzip&#39;, &#39;brotli&#39;, None}, default &#39;snappy&#39;</span>
<span class="sd">            Name of the compression to use. Use ``None`` for no compression.</span>
<span class="sd">        index : bool, default None</span>
<span class="sd">            If ``True``, include the dataframe&#39;s index(es) in the file output.</span>
<span class="sd">            If ``False``, they will not be written to the file.</span>
<span class="sd">            If ``None``, similar to ``True`` the dataframe&#39;s index(es)</span>
<span class="sd">            will be saved. However, instead of being saved as values,</span>
<span class="sd">            the RangeIndex will be stored as a range in the metadata so it</span>
<span class="sd">            doesn&#39;t require much space and is faster. Other indexes will</span>
<span class="sd">            be included as columns in the file output.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        partition_cols : list, optional, default None</span>
<span class="sd">            Column names by which to partition the dataset.</span>
<span class="sd">            Columns are partitioned in the order they are given.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments passed to the parquet library. See</span>
<span class="sd">            :ref:`pandas io &lt;io.parquet&gt;` for more details.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_parquet : Read a parquet file.</span>
<span class="sd">        DataFrame.to_csv : Write a csv file.</span>
<span class="sd">        DataFrame.to_sql : Write to a sql table.</span>
<span class="sd">        DataFrame.to_hdf : Write to hdf.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function requires either the `fastparquet</span>
<span class="sd">        &lt;https://pypi.org/project/fastparquet&gt;`_ or `pyarrow</span>
<span class="sd">        &lt;https://arrow.apache.org/docs/python/&gt;`_ library.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data={&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_parquet(&#39;df.parquet.gzip&#39;,</span>
<span class="sd">        ...               compression=&#39;gzip&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; pd.read_parquet(&#39;df.parquet.gzip&#39;)  # doctest: +SKIP</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     3</span>
<span class="sd">        1     2     4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.parquet</span> <span class="kn">import</span> <span class="n">to_parquet</span>

        <span class="n">to_parquet</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="n">engine</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="o">=</span><span class="n">partition_cols</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">header_type</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Whether to print column labels, default True&quot;</span><span class="p">,</span>
        <span class="n">col_space_type</span><span class="o">=</span><span class="s2">&quot;str or int&quot;</span><span class="p">,</span>
        <span class="n">col_space</span><span class="o">=</span><span class="s2">&quot;The minimum width of each column in CSS length &quot;</span>
        <span class="s2">&quot;units.  An int is assumed to be px units.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;            .. versionadded:: 0.25.0</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;                Ability to use str&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">shared_params</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">common_docstring</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">return_docstring</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">col_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="o">=</span><span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
        <span class="n">formatters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">justify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">decimal</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">classes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">escape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">notebook</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">border</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">table_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">render_links</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a DataFrame as an HTML table.</span>
<span class="sd">        %(shared_params)s</span>
<span class="sd">        bold_rows : bool, default True</span>
<span class="sd">            Make the row labels bold in the output.</span>
<span class="sd">        classes : str or list or tuple, default None</span>
<span class="sd">            CSS class(es) to apply to the resulting html table.</span>
<span class="sd">        escape : bool, default True</span>
<span class="sd">            Convert the characters &lt;, &gt;, and &amp; to HTML-safe sequences.</span>
<span class="sd">        notebook : {True, False}, default False</span>
<span class="sd">            Whether the generated HTML is for IPython Notebook.</span>
<span class="sd">        border : int</span>
<span class="sd">            A ``border=border`` attribute is included in the opening</span>
<span class="sd">            `&lt;table&gt;` tag. Default ``pd.options.display.html.border``.</span>
<span class="sd">        encoding : str, default &quot;utf-8&quot;</span>
<span class="sd">            Set character encoding.</span>

<span class="sd">            .. versionadded:: 1.0</span>

<span class="sd">        table_id : str, optional</span>
<span class="sd">            A css id is included in the opening `&lt;table&gt;` tag if specified.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>

<span class="sd">        render_links : bool, default False</span>
<span class="sd">            Convert URLs to HTML links.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>
<span class="sd">        %(returns)s</span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_string : Convert DataFrame to a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">justify</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">justify</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fmt</span><span class="o">.</span><span class="n">_VALID_JUSTIFY_PARAMETERS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for justify parameter&quot;</span><span class="p">)</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameFormatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">col_space</span><span class="o">=</span><span class="n">col_space</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">sparsify</span><span class="o">=</span><span class="n">sparsify</span><span class="p">,</span>
            <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">bold_rows</span><span class="o">=</span><span class="n">bold_rows</span><span class="p">,</span>
            <span class="n">escape</span><span class="o">=</span><span class="n">escape</span><span class="p">,</span>
            <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
            <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
            <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
            <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
            <span class="n">table_id</span><span class="o">=</span><span class="n">table_id</span><span class="p">,</span>
            <span class="n">render_links</span><span class="o">=</span><span class="n">render_links</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># TODO: a generic formatter wld b in DataFrameFormatter</span>
        <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span>
            <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
            <span class="n">classes</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span>
            <span class="n">notebook</span><span class="o">=</span><span class="n">notebook</span><span class="p">,</span>
            <span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">memory_usage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">null_counts</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a concise summary of a DataFrame.</span>

<span class="sd">        This method prints information about a DataFrame including</span>
<span class="sd">        the index dtype and column dtypes, non-null values and memory usage.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            Whether to print the full summary. By default, the setting in</span>
<span class="sd">            ``pandas.options.display.max_info_columns`` is followed.</span>
<span class="sd">        buf : writable buffer, defaults to sys.stdout</span>
<span class="sd">            Where to send the output. By default, the output is printed to</span>
<span class="sd">            sys.stdout. Pass a writable buffer if you need to further process</span>
<span class="sd">            the output.</span>
<span class="sd">        max_cols : int, optional</span>
<span class="sd">            When to switch from the verbose to the truncated output. If the</span>
<span class="sd">            DataFrame has more than `max_cols` columns, the truncated output</span>
<span class="sd">            is used. By default, the setting in</span>
<span class="sd">            ``pandas.options.display.max_info_columns`` is used.</span>
<span class="sd">        memory_usage : bool, str, optional</span>
<span class="sd">            Specifies whether total memory usage of the DataFrame</span>
<span class="sd">            elements (including the index) should be displayed. By default,</span>
<span class="sd">            this follows the ``pandas.options.display.memory_usage`` setting.</span>

<span class="sd">            True always show memory usage. False never shows memory usage.</span>
<span class="sd">            A value of &#39;deep&#39; is equivalent to &quot;True with deep introspection&quot;.</span>
<span class="sd">            Memory usage is shown in human-readable units (base-2</span>
<span class="sd">            representation). Without deep introspection a memory estimation is</span>
<span class="sd">            made based in column dtype and number of rows assuming values</span>
<span class="sd">            consume the same memory amount for corresponding dtypes. With deep</span>
<span class="sd">            memory introspection, a real memory usage calculation is performed</span>
<span class="sd">            at the cost of computational resources.</span>
<span class="sd">        null_counts : bool, optional</span>
<span class="sd">            Whether to show the non-null counts. By default, this is shown</span>
<span class="sd">            only if the frame is smaller than</span>
<span class="sd">            ``pandas.options.display.max_info_rows`` and</span>
<span class="sd">            ``pandas.options.display.max_info_columns``. A value of True always</span>
<span class="sd">            shows the counts, and False never shows the counts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            This method prints a summary of a DataFrame and returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.describe: Generate descriptive statistics of DataFrame</span>
<span class="sd">            columns.</span>
<span class="sd">        DataFrame.memory_usage: Memory usage of DataFrame columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; int_values = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; text_values = [&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;, &#39;delta&#39;, &#39;epsilon&#39;]</span>
<span class="sd">        &gt;&gt;&gt; float_values = [0.0, 0.25, 0.5, 0.75, 1.0]</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;int_col&quot;: int_values, &quot;text_col&quot;: text_values,</span>
<span class="sd">        ...                   &quot;float_col&quot;: float_values})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           int_col text_col  float_col</span>
<span class="sd">        0        1    alpha       0.00</span>
<span class="sd">        1        2     beta       0.25</span>
<span class="sd">        2        3    gamma       0.50</span>
<span class="sd">        3        4    delta       0.75</span>
<span class="sd">        4        5  epsilon       1.00</span>

<span class="sd">        Prints information of all columns:</span>

<span class="sd">        &gt;&gt;&gt; df.info(verbose=True)</span>
<span class="sd">        &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="sd">        RangeIndex: 5 entries, 0 to 4</span>
<span class="sd">        Data columns (total 3 columns):</span>
<span class="sd">         #   Column     Non-Null Count  Dtype</span>
<span class="sd">        ---  ------     --------------  -----</span>
<span class="sd">         0   int_col    5 non-null      int64</span>
<span class="sd">         1   text_col   5 non-null      object</span>
<span class="sd">         2   float_col  5 non-null      float64</span>
<span class="sd">        dtypes: float64(1), int64(1), object(1)</span>
<span class="sd">        memory usage: 248.0+ bytes</span>

<span class="sd">        Prints a summary of columns count and its dtypes but not per column</span>
<span class="sd">        information:</span>

<span class="sd">        &gt;&gt;&gt; df.info(verbose=False)</span>
<span class="sd">        &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="sd">        RangeIndex: 5 entries, 0 to 4</span>
<span class="sd">        Columns: 3 entries, int_col to float_col</span>
<span class="sd">        dtypes: float64(1), int64(1), object(1)</span>
<span class="sd">        memory usage: 248.0+ bytes</span>

<span class="sd">        Pipe output of DataFrame.info to buffer instead of sys.stdout, get</span>
<span class="sd">        buffer content and writes to a text file:</span>

<span class="sd">        &gt;&gt;&gt; import io</span>
<span class="sd">        &gt;&gt;&gt; buffer = io.StringIO()</span>
<span class="sd">        &gt;&gt;&gt; df.info(buf=buffer)</span>
<span class="sd">        &gt;&gt;&gt; s = buffer.getvalue()</span>
<span class="sd">        &gt;&gt;&gt; with open(&quot;df_info.txt&quot;, &quot;w&quot;,</span>
<span class="sd">        ...           encoding=&quot;utf-8&quot;) as f:  # doctest: +SKIP</span>
<span class="sd">        ...     f.write(s)</span>
<span class="sd">        260</span>

<span class="sd">        The `memory_usage` parameter allows deep introspection mode, specially</span>
<span class="sd">        useful for big DataFrames and fine-tune memory optimization:</span>

<span class="sd">        &gt;&gt;&gt; random_strings_array = np.random.choice([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 10 ** 6)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;column_1&#39;: np.random.choice([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 10 ** 6),</span>
<span class="sd">        ...     &#39;column_2&#39;: np.random.choice([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 10 ** 6),</span>
<span class="sd">        ...     &#39;column_3&#39;: np.random.choice([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 10 ** 6)</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df.info()</span>
<span class="sd">        &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="sd">        RangeIndex: 1000000 entries, 0 to 999999</span>
<span class="sd">        Data columns (total 3 columns):</span>
<span class="sd">         #   Column    Non-Null Count    Dtype</span>
<span class="sd">        ---  ------    --------------    -----</span>
<span class="sd">         0   column_1  1000000 non-null  object</span>
<span class="sd">         1   column_2  1000000 non-null  object</span>
<span class="sd">         2   column_3  1000000 non-null  object</span>
<span class="sd">        dtypes: object(3)</span>
<span class="sd">        memory usage: 22.9+ MB</span>

<span class="sd">        &gt;&gt;&gt; df.info(memory_usage=&#39;deep&#39;)</span>
<span class="sd">        &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
<span class="sd">        RangeIndex: 1000000 entries, 0 to 999999</span>
<span class="sd">        Data columns (total 3 columns):</span>
<span class="sd">         #   Column    Non-Null Count    Dtype</span>
<span class="sd">        ---  ------    --------------    -----</span>
<span class="sd">         0   column_1  1000000 non-null  object</span>
<span class="sd">         1   column_2  1000000 non-null  object</span>
<span class="sd">         2   column_3  1000000 non-null  object</span>
<span class="sd">        dtypes: object(3)</span>
<span class="sd">        memory usage: 188.8 MB</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_summary</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Empty </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fmt</span><span class="o">.</span><span class="n">buffer_put_lines</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">col_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># hack</span>
        <span class="k">if</span> <span class="n">max_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_cols</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_info_columns&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_info_rows&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">null_counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">show_counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">col_count</span> <span class="o">&lt;=</span> <span class="n">max_cols</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_rows</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">show_counts</span> <span class="o">=</span> <span class="n">null_counts</span>
        <span class="n">exceeds_info_cols</span> <span class="o">=</span> <span class="n">col_count</span> <span class="o">&gt;</span> <span class="n">max_cols</span>

        <span class="k">def</span> <span class="nf">_verbose_repr</span><span class="p">():</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data columns (total </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="si">}</span><span class="s2"> columns):&quot;</span><span class="p">)</span>

            <span class="n">id_head</span> <span class="o">=</span> <span class="s2">&quot; # &quot;</span>
            <span class="n">column_head</span> <span class="o">=</span> <span class="s2">&quot;Column&quot;</span>
            <span class="n">col_space</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="n">max_col</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">)</span>
            <span class="n">len_column</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">column_head</span><span class="p">))</span>
            <span class="n">space</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_col</span><span class="p">,</span> <span class="n">len_column</span><span class="p">)</span> <span class="o">+</span> <span class="n">col_space</span>

            <span class="n">max_id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">col_count</span><span class="p">))</span>
            <span class="n">len_id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">id_head</span><span class="p">))</span>
            <span class="n">space_num</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_id</span><span class="p">,</span> <span class="n">len_id</span><span class="p">)</span> <span class="o">+</span> <span class="n">col_space</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">header</span> <span class="o">=</span> <span class="n">_put_str</span><span class="p">(</span><span class="n">id_head</span><span class="p">,</span> <span class="n">space_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="n">column_head</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">show_counts</span><span class="p">:</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Columns must equal counts (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                <span class="n">count_header</span> <span class="o">=</span> <span class="s2">&quot;Non-Null Count&quot;</span>
                <span class="n">len_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">count_header</span><span class="p">)</span>
                <span class="n">non_null</span> <span class="o">=</span> <span class="s2">&quot; non-null&quot;</span>
                <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_null</span><span class="p">)</span>
                <span class="n">space_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_count</span><span class="p">,</span> <span class="n">max_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">col_space</span>
                <span class="n">count_temp</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{count}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">non_null</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count_header</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">space_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">count_header</span><span class="p">)</span>
                <span class="n">len_count</span> <span class="o">=</span> <span class="n">space_count</span>
                <span class="n">count_temp</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{count}</span><span class="s2">&quot;</span>

            <span class="n">dtype_header</span> <span class="o">=</span> <span class="s2">&quot;Dtype&quot;</span>
            <span class="n">len_dtype</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype_header</span><span class="p">)</span>
            <span class="n">max_dtypes</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>
            <span class="n">space_dtype</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">len_dtype</span><span class="p">,</span> <span class="n">max_dtypes</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="n">_put_str</span><span class="p">(</span><span class="n">count_header</span><span class="p">,</span> <span class="n">space_count</span><span class="p">)</span> <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span>
                <span class="n">dtype_header</span><span class="p">,</span> <span class="n">space_dtype</span>
            <span class="p">)</span>

            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_put_str</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">len_id</span><span class="p">,</span> <span class="n">space_num</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">len_column</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">len_count</span><span class="p">,</span> <span class="n">space_count</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">len_dtype</span><span class="p">,</span> <span class="n">space_dtype</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">pprint_thing</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

                <span class="n">line_no</span> <span class="o">=</span> <span class="n">_put_str</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">{num}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="n">i</span><span class="p">),</span> <span class="n">space_num</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="n">show_counts</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">line_no</span>
                    <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="n">count_temp</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">),</span> <span class="n">space_count</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">_put_str</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">space_dtype</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_non_verbose_repr</span><span class="p">():</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_summary</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Columns&quot;</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">_sizeof_fmt</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">size_qualifier</span><span class="p">):</span>
            <span class="c1"># returns size in human readable format</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;KB&quot;</span><span class="p">,</span> <span class="s2">&quot;MB&quot;</span><span class="p">,</span> <span class="s2">&quot;GB&quot;</span><span class="p">,</span> <span class="s2">&quot;TB&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mf">1024.0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="s2">3.1f</span><span class="si">}{</span><span class="n">size_qualifier</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">num</span> <span class="o">/=</span> <span class="mf">1024.0</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num</span><span class="si">:</span><span class="s2">3.1f</span><span class="si">}{</span><span class="n">size_qualifier</span><span class="si">}</span><span class="s2"> PB&quot;</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">_verbose_repr</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># specifically set to False, not nesc None</span>
            <span class="n">_non_verbose_repr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exceeds_info_cols</span><span class="p">:</span>
                <span class="n">_non_verbose_repr</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_verbose_repr</span><span class="p">()</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">()</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dtypes: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">memory_usage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memory_usage</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.memory_usage&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">memory_usage</span><span class="p">:</span>
            <span class="c1"># append memory usage of df to display</span>
            <span class="n">size_qualifier</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">memory_usage</span> <span class="o">==</span> <span class="s2">&quot;deep&quot;</span><span class="p">:</span>
                <span class="n">deep</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># size_qualifier is just a best effort; not guaranteed to catch</span>
                <span class="c1"># all cases (e.g., it misses categorical data even with object</span>
                <span class="c1"># categories)</span>
                <span class="n">deep</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="s2">&quot;object&quot;</span> <span class="ow">in</span> <span class="n">counts</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_is_memory_usage_qualified</span><span class="p">():</span>
                    <span class="n">size_qualifier</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
            <span class="n">mem_usage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;memory usage: </span><span class="si">{</span><span class="n">_sizeof_fmt</span><span class="p">(</span><span class="n">mem_usage</span><span class="p">,</span> <span class="n">size_qualifier</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">buffer_put_lines</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the memory usage of each column in bytes.</span>

<span class="sd">        The memory usage can optionally include the contribution of</span>
<span class="sd">        the index and elements of `object` dtype.</span>

<span class="sd">        This value is displayed in `DataFrame.info` by default. This can be</span>
<span class="sd">        suppressed by setting ``pandas.options.display.memory_usage`` to False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Specifies whether to include the memory usage of the DataFrame&#39;s</span>
<span class="sd">            index in returned Series. If ``index=True``, the memory usage of</span>
<span class="sd">            the index is the first item in the output.</span>
<span class="sd">        deep : bool, default False</span>
<span class="sd">            If True, introspect the data deeply by interrogating</span>
<span class="sd">            `object` dtypes for system-level memory consumption, and include</span>
<span class="sd">            it in the returned values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A Series whose index is the original column names and whose values</span>
<span class="sd">            is the memory usage of each column in bytes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.nbytes : Total bytes consumed by the elements of an</span>
<span class="sd">            ndarray.</span>
<span class="sd">        Series.memory_usage : Bytes consumed by a Series.</span>
<span class="sd">        Categorical : Memory-efficient array for string values with</span>
<span class="sd">            many repeated values.</span>
<span class="sd">        DataFrame.info : Concise summary of a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dtypes = [&#39;int64&#39;, &#39;float64&#39;, &#39;complex128&#39;, &#39;object&#39;, &#39;bool&#39;]</span>
<span class="sd">        &gt;&gt;&gt; data = dict([(t, np.ones(shape=5000).astype(t))</span>
<span class="sd">        ...              for t in dtypes])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; df.head()</span>
<span class="sd">           int64  float64            complex128  object  bool</span>
<span class="sd">        0      1      1.0    1.000000+0.000000j       1  True</span>
<span class="sd">        1      1      1.0    1.000000+0.000000j       1  True</span>
<span class="sd">        2      1      1.0    1.000000+0.000000j       1  True</span>
<span class="sd">        3      1      1.0    1.000000+0.000000j       1  True</span>
<span class="sd">        4      1      1.0    1.000000+0.000000j       1  True</span>

<span class="sd">        &gt;&gt;&gt; df.memory_usage()</span>
<span class="sd">        Index           128</span>
<span class="sd">        int64         40000</span>
<span class="sd">        float64       40000</span>
<span class="sd">        complex128    80000</span>
<span class="sd">        object        40000</span>
<span class="sd">        bool           5000</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.memory_usage(index=False)</span>
<span class="sd">        int64         40000</span>
<span class="sd">        float64       40000</span>
<span class="sd">        complex128    80000</span>
<span class="sd">        object        40000</span>
<span class="sd">        bool           5000</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        The memory footprint of `object` dtype columns is ignored by default:</span>

<span class="sd">        &gt;&gt;&gt; df.memory_usage(deep=True)</span>
<span class="sd">        Index            128</span>
<span class="sd">        int64          40000</span>
<span class="sd">        float64        40000</span>
<span class="sd">        complex128     80000</span>
<span class="sd">        object        160000</span>
<span class="sd">        bool            5000</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Use a Categorical for efficient storage of an object-dtype column with</span>
<span class="sd">        many repeated values.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;object&#39;].astype(&#39;category&#39;).memory_usage(deep=True)</span>
<span class="sd">        5216</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span>
            <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">result</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transpose index and columns.</span>

<span class="sd">        Reflect the DataFrame over its main diagonal by writing rows as columns</span>
<span class="sd">        and vice-versa. The property :attr:`.T` is an accessor to the method</span>
<span class="sd">        :meth:`transpose`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : tuple, optional</span>
<span class="sd">            Accepted for compatibility with NumPy.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to copy the data after transposing, even for DataFrames</span>
<span class="sd">            with a single dtype.</span>

<span class="sd">            Note that a copy is always required for mixed dtype DataFrames,</span>
<span class="sd">            or for DataFrames with any extension types.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The transposed DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.transpose : Permute the dimensions of a given array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Transposing a DataFrame with mixed dtypes will result in a homogeneous</span>
<span class="sd">        DataFrame with the `object` dtype. In such a case, a copy of the data</span>
<span class="sd">        is always made.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Square DataFrame with homogeneous dtype**</span>

<span class="sd">        &gt;&gt;&gt; d1 = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame(data=d1)</span>
<span class="sd">        &gt;&gt;&gt; df1</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     3</span>
<span class="sd">        1     2     4</span>

<span class="sd">        &gt;&gt;&gt; df1_transposed = df1.T # or df1.transpose()</span>
<span class="sd">        &gt;&gt;&gt; df1_transposed</span>
<span class="sd">              0  1</span>
<span class="sd">        col1  1  2</span>
<span class="sd">        col2  3  4</span>

<span class="sd">        When the dtype is homogeneous in the original DataFrame, we get a</span>
<span class="sd">        transposed DataFrame with the same dtype:</span>

<span class="sd">        &gt;&gt;&gt; df1.dtypes</span>
<span class="sd">        col1    int64</span>
<span class="sd">        col2    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df1_transposed.dtypes</span>
<span class="sd">        0    int64</span>
<span class="sd">        1    int64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        **Non-square DataFrame with mixed dtypes**</span>

<span class="sd">        &gt;&gt;&gt; d2 = {&#39;name&#39;: [&#39;Alice&#39;, &#39;Bob&#39;],</span>
<span class="sd">        ...       &#39;score&#39;: [9.5, 8],</span>
<span class="sd">        ...       &#39;employed&#39;: [False, True],</span>
<span class="sd">        ...       &#39;kids&#39;: [0, 0]}</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(data=d2)</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">            name  score  employed  kids</span>
<span class="sd">        0  Alice    9.5     False     0</span>
<span class="sd">        1    Bob    8.0      True     0</span>

<span class="sd">        &gt;&gt;&gt; df2_transposed = df2.T # or df2.transpose()</span>
<span class="sd">        &gt;&gt;&gt; df2_transposed</span>
<span class="sd">                      0     1</span>
<span class="sd">        name      Alice   Bob</span>
<span class="sd">        score       9.5     8</span>
<span class="sd">        employed  False  True</span>
<span class="sd">        kids          0     0</span>

<span class="sd">        When the DataFrame has mixed dtypes, we get a transposed DataFrame with</span>
<span class="sd">        the `object` dtype:</span>

<span class="sd">        &gt;&gt;&gt; df2.dtypes</span>
<span class="sd">        name         object</span>
<span class="sd">        score       float64</span>
<span class="sd">        employed       bool</span>
<span class="sd">        kids          int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df2_transposed.dtypes</span>
<span class="sd">        0    object</span>
<span class="sd">        1    object</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_transpose</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="c1"># construct the args</span>

        <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_homogeneous_type</span> <span class="ow">and</span> <span class="n">dtypes</span> <span class="ow">and</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># We have EAs with the same dtype. We can preserve that dtype in transpose.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">arr_type</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">construct_array_type</span><span class="p">()</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

            <span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr_type</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">new_values</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Indexing Methods</span>

    <span class="k">def</span> <span class="nf">_ixs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">        axis : int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If slice passed, the resulting data will be a view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># irow</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fast_xs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># if we are a copy, mark as such</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_values</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">new_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># icol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># if the values returned are not the same length</span>
            <span class="c1"># as the index (iow a not found value), iget returns</span>
            <span class="c1"># a 0-len ndarray. This is effectively catching</span>
            <span class="c1"># a numpy error (as numpy should really raise)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">iget</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_col_values</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>

            <span class="c1"># this is a cached value, mark it so</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_set_as_cached</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># shortcut if the key is in columns</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_multilevel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Do we have a slicer (on rows)?</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">convert_to_index_sliceable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># either we have a slice or we have a string that can be converted</span>
            <span class="c1">#  to a slice for partial-string date indexing</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Do we have a (boolean) DataFrame?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Do we have a (boolean) 1d indexer?</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_bool_array</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># We are left with two options: a single key, and a collection of keys,</span>
        <span class="c1"># We interpret tuples as collections only for non-MultiIndex</span>
        <span class="n">is_single_key</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single_key</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_multilevel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">indexer</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">_get_listlike_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">raise_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># take() does not accept boolean indexers</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indexer</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single_key</span><span class="p">:</span>
            <span class="c1"># What does looking for a single key in a non-unique index return?</span>
            <span class="c1"># The behavior is inconsistent. It returns a Series, except when</span>
            <span class="c1"># - the key itself is repeated (test on data.shape, #9519), or</span>
            <span class="c1"># - we have a MultiIndex on columns (test on self.columns, #21309)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_getitem_bool_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># also raises Exception if object array with NA values</span>
        <span class="c1"># warning here just in case -- previously __setitem__ was</span>
        <span class="c1"># reindexing but __getitem__ was not; it seems more reasonable to</span>
        <span class="c1"># go with the __setitem__ behavior since that is more consistent</span>
        <span class="c1"># with all other indexing behavior</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Boolean Series key will be reindexed to match DataFrame index.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Item wrong length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check_bool_indexer will throw exception if Series key cannot</span>
        <span class="c1"># be reindexed to match DataFrame rows</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem_multilevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># self.columns is a MultiIndex</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="n">new_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result_columns</span> <span class="o">=</span> <span class="n">maybe_droplevels</span><span class="p">(</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">new_columns</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">result_columns</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="n">loc</span><span class="p">]</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                    <span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">result_columns</span>
                <span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># If there is only one column being returned, and its name is</span>
            <span class="c1"># either an empty string, or a tuple with an empty string as its</span>
            <span class="c1"># first element, then treat the empty string as a placeholder</span>
            <span class="c1"># and return the column as if the user had provided that empty</span>
            <span class="c1"># string in the key. If the result is a Series, exclude the</span>
            <span class="c1"># implied empty string from its name.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                            <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span>
                        <span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">takeable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quickly retrieve single value at passed column and index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : row label</span>
<span class="sd">        col : column label</span>
<span class="sd">        takeable : interpret the index/col as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iget_item_cache</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">maybe_box_datetimelike</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>

        <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">engine</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># GH 20629</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># partial indexing forbidden</span>
                <span class="k">raise</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="c1"># we cannot handle direct indexing</span>
        <span class="c1"># use positional</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># see if we can slice the rows</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="n">convert_to_index_sliceable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># either we have a slice or we have a string that can be converted</span>
            <span class="c1">#  to a slice for partial-string date indexing</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_slice</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_frame</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_array</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set column</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_item</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setitem_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># NB: we can&#39;t just use self.loc[key] = value because that</span>
        <span class="c1">#  operates on labels and we need to operate positional for</span>
        <span class="c1">#  backwards-compat, xref GH#31469</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">_setitem_with_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setitem_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># also raises Exception if object array with NA values</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Item wrong length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span>
                <span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">_setitem_with_indexer</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns must be same length as key&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">_get_listlike_indexer</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">raise_missing</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">_setitem_with_indexer</span><span class="p">((</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">indexer</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setitem_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># support boolean setting with DataFrame input, e.g.</span>
        <span class="c1"># df[df &gt; df2] = 0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array conditional must be same shape as self&quot;</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Must pass DataFrame or 2-d ndarray with boolean values only&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_setting</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="o">-</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add series to DataFrame in specified column.</span>

<span class="sd">        If series is a numpy-array (not a Series/TimeSeries), it must be the</span>
<span class="sd">        same length as the DataFrames index or an error will be thrown.</span>

<span class="sd">        Series/TimeSeries will be conformed to the DataFrames index to</span>
<span class="sd">        ensure homogeneity.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_valid_index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">NDFrame</span><span class="o">.</span><span class="n">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># check if we are modifying a copy</span>
        <span class="c1"># try to set first as we want an invalid</span>
        <span class="c1"># value exception to occur first</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">takeable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put single value at passed column and index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : row label</span>
<span class="sd">        col : column label</span>
<span class="sd">        value : scalar</span>
<span class="sd">        takeable : interpret the index/col as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            If label pair is contained, will be reference to calling DataFrame,</span>
<span class="sd">            otherwise a new object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">takeable</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iget_item_cache</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">_set_value</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">takeable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span>
            <span class="n">engine</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>

            <span class="c1"># set using a non-recursive method &amp; reset the cache</span>
            <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_ensure_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that if we don&#39;t have an index, that we can create one from the</span>
<span class="sd">        passed value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GH5632, make sure that we are a Series convertible</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot set a frame with no defined index &quot;</span>
                    <span class="s2">&quot;and a value that cannot be converted to a &quot;</span>
                    <span class="s2">&quot;Series&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span>
                <span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_box_item_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_col_values</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_box_col_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide boxed values for a column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span>
        <span class="k">return</span> <span class="n">klass</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">items</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Unsorted</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query the columns of a DataFrame with a boolean expression.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : str</span>
<span class="sd">            The query string to evaluate.</span>

<span class="sd">            You can refer to variables</span>
<span class="sd">            in the environment by prefixing them with an &#39;@&#39; character like</span>
<span class="sd">            ``@a + b``.</span>

<span class="sd">            You can refer to column names that contain spaces or operators by</span>
<span class="sd">            surrounding them in backticks. This way you can also escape</span>
<span class="sd">            names that start with a digit, or those that  are a Python keyword.</span>
<span class="sd">            Basically when it is not valid Python identifier. See notes down</span>
<span class="sd">            for more details.</span>

<span class="sd">            For example, if one of your columns is called ``a a`` and you want</span>
<span class="sd">            to sum it with ``b``, your query should be ```a a` + b``.</span>

<span class="sd">            .. versionadded:: 0.25.0</span>
<span class="sd">                Backtick quoting introduced.</span>

<span class="sd">            .. versionadded:: 1.0.0</span>
<span class="sd">                Expanding functionality of backtick quoting for more than only spaces.</span>

<span class="sd">        inplace : bool</span>
<span class="sd">            Whether the query should modify the data in place or return</span>
<span class="sd">            a modified copy.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            See the documentation for :func:`eval` for complete details</span>
<span class="sd">            on the keyword arguments accepted by :meth:`DataFrame.query`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame resulting from the provided query expression.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        eval : Evaluate a string describing operations on</span>
<span class="sd">            DataFrame columns.</span>
<span class="sd">        DataFrame.eval : Evaluate a string describing operations on</span>
<span class="sd">            DataFrame columns.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result of the evaluation of this expression is first passed to</span>
<span class="sd">        :attr:`DataFrame.loc` and if that fails because of a</span>
<span class="sd">        multidimensional key (e.g., a DataFrame) then the result will be passed</span>
<span class="sd">        to :meth:`DataFrame.__getitem__`.</span>

<span class="sd">        This method uses the top-level :func:`eval` function to</span>
<span class="sd">        evaluate the passed query.</span>

<span class="sd">        The :meth:`~pandas.DataFrame.query` method uses a slightly</span>
<span class="sd">        modified Python syntax by default. For example, the ``&amp;`` and ``|``</span>
<span class="sd">        (bitwise) operators have the precedence of their boolean cousins,</span>
<span class="sd">        :keyword:`and` and :keyword:`or`. This *is* syntactically valid Python,</span>
<span class="sd">        however the semantics are different.</span>

<span class="sd">        You can change the semantics of the expression by passing the keyword</span>
<span class="sd">        argument ``parser=&#39;python&#39;``. This enforces the same semantics as</span>
<span class="sd">        evaluation in Python space. Likewise, you can pass ``engine=&#39;python&#39;``</span>
<span class="sd">        to evaluate an expression using Python itself as a backend. This is not</span>
<span class="sd">        recommended as it is inefficient compared to using ``numexpr`` as the</span>
<span class="sd">        engine.</span>

<span class="sd">        The :attr:`DataFrame.index` and</span>
<span class="sd">        :attr:`DataFrame.columns` attributes of the</span>
<span class="sd">        :class:`~pandas.DataFrame` instance are placed in the query namespace</span>
<span class="sd">        by default, which allows you to treat both the index and columns of the</span>
<span class="sd">        frame as a column in the frame.</span>
<span class="sd">        The identifier ``index`` is used for the frame index; you can also</span>
<span class="sd">        use the name of the index to identify it in a query. Please note that</span>
<span class="sd">        Python keywords may not be used as identifiers.</span>

<span class="sd">        For further details and examples see the ``query`` documentation in</span>
<span class="sd">        :ref:`indexing &lt;indexing.query&gt;`.</span>

<span class="sd">        *Backtick quoted variables*</span>

<span class="sd">        Backtick quoted variables are parsed as literal Python code and</span>
<span class="sd">        are converted internally to a Python valid identifier.</span>
<span class="sd">        This can lead to the following problems.</span>

<span class="sd">        During parsing a number of disallowed characters inside the backtick</span>
<span class="sd">        quoted string are replaced by strings that are allowed as a Python identifier.</span>
<span class="sd">        These characters include all operators in Python, the space character, the</span>
<span class="sd">        question mark, the exclamation mark, the dollar sign, and the euro sign.</span>
<span class="sd">        For other characters that fall outside the ASCII range (U+0001..U+007F)</span>
<span class="sd">        and those that are not further specified in PEP 3131,</span>
<span class="sd">        the query parser will raise an error.</span>
<span class="sd">        This excludes whitespace different than the space character,</span>
<span class="sd">        but also the hashtag (as it is used for comments) and the backtick</span>
<span class="sd">        itself (backtick can also not be escaped).</span>

<span class="sd">        In a special case, quotes that make a pair around a backtick can</span>
<span class="sd">        confuse the parser.</span>
<span class="sd">        For example, ```it&#39;s` &gt; `that&#39;s``` will raise an error,</span>
<span class="sd">        as it forms a quoted string (``&#39;s &gt; `that&#39;``) with a backtick inside.</span>

<span class="sd">        See also the Python documentation about lexical analysis</span>
<span class="sd">        (https://docs.python.org/3/reference/lexical_analysis.html)</span>
<span class="sd">        in combination with the source code in :mod:`pandas.core.computation.parsing`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: range(1, 6),</span>
<span class="sd">        ...                    &#39;B&#39;: range(10, 0, -2),</span>
<span class="sd">        ...                    &#39;C C&#39;: range(10, 5, -1)})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B  C C</span>
<span class="sd">        0  1  10   10</span>
<span class="sd">        1  2   8    9</span>
<span class="sd">        2  3   6    8</span>
<span class="sd">        3  4   4    7</span>
<span class="sd">        4  5   2    6</span>
<span class="sd">        &gt;&gt;&gt; df.query(&#39;A &gt; B&#39;)</span>
<span class="sd">           A  B  C C</span>
<span class="sd">        4  5  2    6</span>

<span class="sd">        The previous expression is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; df[df.A &gt; df.B]</span>
<span class="sd">           A  B  C C</span>
<span class="sd">        4  5  2    6</span>

<span class="sd">        For columns with spaces in their name, you can use backtick quoting.</span>

<span class="sd">        &gt;&gt;&gt; df.query(&#39;B == `C C`&#39;)</span>
<span class="sd">           A   B  C C</span>
<span class="sd">        0  1  10   10</span>

<span class="sd">        The previous expression is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; df[df.B == df[&#39;C C&#39;]]</span>
<span class="sd">           A   B  C C</span>
<span class="sd">        0  1  10   10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expr must be a string to be evaluated, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2"> given&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">res</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># when res is multi-dimensional loc raises, but this is sometimes a</span>
            <span class="c1"># valid query</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">res</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_data</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a string describing operations on DataFrame columns.</span>

<span class="sd">        Operates on columns only, not specific rows or elements.  This allows</span>
<span class="sd">        `eval` to run arbitrary code, which can make you vulnerable to code</span>
<span class="sd">        injection if you pass user input to this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : str</span>
<span class="sd">            The expression string to evaluate.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If the expression contains an assignment, whether to perform the</span>
<span class="sd">            operation inplace and mutate the existing DataFrame. Otherwise,</span>
<span class="sd">            a new DataFrame is returned.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            See the documentation for :func:`eval` for complete details</span>
<span class="sd">            on the keyword arguments accepted by</span>
<span class="sd">            :meth:`~pandas.DataFrame.query`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, scalar, or pandas object</span>
<span class="sd">            The result of the evaluation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.query : Evaluates a boolean expression to query the columns</span>
<span class="sd">            of a frame.</span>
<span class="sd">        DataFrame.assign : Can evaluate an expression or function to create new</span>
<span class="sd">            values for a column.</span>
<span class="sd">        eval : Evaluate a Python expression as a string using various</span>
<span class="sd">            backends.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For more details see the API documentation for :func:`~eval`.</span>
<span class="sd">        For detailed examples see :ref:`enhancing performance with eval</span>
<span class="sd">        &lt;enhancingperf.eval&gt;`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: range(1, 6), &#39;B&#39;: range(10, 0, -2)})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  1  10</span>
<span class="sd">        1  2   8</span>
<span class="sd">        2  3   6</span>
<span class="sd">        3  4   4</span>
<span class="sd">        4  5   2</span>
<span class="sd">        &gt;&gt;&gt; df.eval(&#39;A + B&#39;)</span>
<span class="sd">        0    11</span>
<span class="sd">        1    10</span>
<span class="sd">        2     9</span>
<span class="sd">        3     8</span>
<span class="sd">        4     7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Assignment is allowed though by default the original DataFrame is not</span>
<span class="sd">        modified.</span>

<span class="sd">        &gt;&gt;&gt; df.eval(&#39;C = A + B&#39;)</span>
<span class="sd">           A   B   C</span>
<span class="sd">        0  1  10  11</span>
<span class="sd">        1  2   8  10</span>
<span class="sd">        2  3   6   9</span>
<span class="sd">        3  4   4   8</span>
<span class="sd">        4  5   2   7</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  1  10</span>
<span class="sd">        1  2   8</span>
<span class="sd">        2  3   6</span>
<span class="sd">        3  4   4</span>
<span class="sd">        4  5   2</span>

<span class="sd">        Use ``inplace=True`` to modify the original DataFrame.</span>

<span class="sd">        &gt;&gt;&gt; df.eval(&#39;C = A + B&#39;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B   C</span>
<span class="sd">        0  1  10  11</span>
<span class="sd">        1  2   8  10</span>
<span class="sd">        2  3   6   9</span>
<span class="sd">        3  4   4   8</span>
<span class="sd">        4  5   2   7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation.eval</span> <span class="kn">import</span> <span class="nb">eval</span> <span class="k">as</span> <span class="n">_eval</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">resolvers</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;resolvers&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">resolvers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index_resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_resolvers</span><span class="p">()</span>
            <span class="n">column_resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cleaned_column_resolvers</span><span class="p">()</span>
            <span class="n">resolvers</span> <span class="o">=</span> <span class="n">column_resolvers</span><span class="p">,</span> <span class="n">index_resolvers</span>
        <span class="k">if</span> <span class="s2">&quot;target&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;resolvers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;resolvers&quot;</span><span class="p">,</span> <span class="p">())</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">resolvers</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a subset of the DataFrame&#39;s columns based on the column dtypes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include, exclude : scalar or list-like</span>
<span class="sd">            A selection of dtypes or strings to be included/excluded. At least</span>
<span class="sd">            one of these parameters must be supplied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The subset of the frame including the dtypes in ``include`` and</span>
<span class="sd">            excluding the dtypes in ``exclude``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If both of ``include`` and ``exclude`` are empty</span>
<span class="sd">            * If ``include`` and ``exclude`` have overlapping elements</span>
<span class="sd">            * If any kind of string dtype is passed in.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * To select all *numeric* types, use ``np.number`` or ``&#39;number&#39;``</span>
<span class="sd">        * To select strings you must use the ``object`` dtype, but note that</span>
<span class="sd">          this will return *all* object dtype columns</span>
<span class="sd">        * See the `numpy dtype hierarchy</span>
<span class="sd">          &lt;http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html&gt;`__</span>
<span class="sd">        * To select datetimes, use ``np.datetime64``, ``&#39;datetime&#39;`` or</span>
<span class="sd">          ``&#39;datetime64&#39;``</span>
<span class="sd">        * To select timedeltas, use ``np.timedelta64``, ``&#39;timedelta&#39;`` or</span>
<span class="sd">          ``&#39;timedelta64&#39;``</span>
<span class="sd">        * To select Pandas categorical dtypes, use ``&#39;category&#39;``</span>
<span class="sd">        * To select Pandas datetimetz dtypes, use ``&#39;datetimetz&#39;`` (new in</span>
<span class="sd">          0.20.0) or ``&#39;datetime64[ns, tz]&#39;``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [1, 2] * 3,</span>
<span class="sd">        ...                    &#39;b&#39;: [True, False] * 3,</span>
<span class="sd">        ...                    &#39;c&#39;: [1.0, 2.0] * 3})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                a      b  c</span>
<span class="sd">        0       1   True  1.0</span>
<span class="sd">        1       2  False  2.0</span>
<span class="sd">        2       1   True  1.0</span>
<span class="sd">        3       2  False  2.0</span>
<span class="sd">        4       1   True  1.0</span>
<span class="sd">        5       2  False  2.0</span>

<span class="sd">        &gt;&gt;&gt; df.select_dtypes(include=&#39;bool&#39;)</span>
<span class="sd">           b</span>
<span class="sd">        0  True</span>
<span class="sd">        1  False</span>
<span class="sd">        2  True</span>
<span class="sd">        3  False</span>
<span class="sd">        4  True</span>
<span class="sd">        5  False</span>

<span class="sd">        &gt;&gt;&gt; df.select_dtypes(include=[&#39;float64&#39;])</span>
<span class="sd">           c</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  2.0</span>
<span class="sd">        2  1.0</span>
<span class="sd">        3  2.0</span>
<span class="sd">        4  1.0</span>
<span class="sd">        5  2.0</span>

<span class="sd">        &gt;&gt;&gt; df.select_dtypes(exclude=[&#39;int&#39;])</span>
<span class="sd">               b    c</span>
<span class="sd">        0   True  1.0</span>
<span class="sd">        1  False  2.0</span>
<span class="sd">        2   True  1.0</span>
<span class="sd">        3  False  2.0</span>
<span class="sd">        4   True  1.0</span>
<span class="sd">        5  False  2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">include</span><span class="p">):</span>
            <span class="n">include</span> <span class="o">=</span> <span class="p">(</span><span class="n">include</span><span class="p">,)</span> <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">(</span><span class="n">exclude</span><span class="p">,)</span> <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">()</span>

        <span class="n">selection</span> <span class="o">=</span> <span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">include</span><span class="p">),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">exclude</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least one of include or exclude must be nonempty&quot;</span><span class="p">)</span>

        <span class="c1"># convert the myriad valid dtypes object to a single representation</span>
        <span class="n">include</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">infer_dtype_from_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">include</span><span class="p">)</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">infer_dtype_from_object</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dtypes</span> <span class="ow">in</span> <span class="p">(</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="p">):</span>
            <span class="n">invalidate_string_dtypes</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>

        <span class="c1"># can&#39;t both include AND exclude!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;include and exclude overlap on </span><span class="si">{</span><span class="p">(</span><span class="n">include</span> <span class="o">&amp;</span> <span class="n">exclude</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># We raise when both include and exclude are empty</span>
        <span class="c1"># Hence, we can just shrink the columns we want to keep</span>
        <span class="n">keep_these</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">extract_unique_dtypes_from_dtypes_set</span><span class="p">(</span>
            <span class="n">dtypes_set</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">Dtype</span><span class="p">],</span> <span class="n">unique_dtypes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dtype</span><span class="p">]:</span>
            <span class="n">extracted_dtypes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">unique_dtype</span>
                <span class="k">for</span> <span class="n">unique_dtype</span> <span class="ow">in</span> <span class="n">unique_dtypes</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">unique_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dtypes_set</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">extracted_dtypes</span>

        <span class="n">unique_dtypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">include</span><span class="p">:</span>
            <span class="n">included_dtypes</span> <span class="o">=</span> <span class="n">extract_unique_dtypes_from_dtypes_set</span><span class="p">(</span>
                <span class="n">include</span><span class="p">,</span> <span class="n">unique_dtypes</span>
            <span class="p">)</span>
            <span class="n">keep_these</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">included_dtypes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="n">excluded_dtypes</span> <span class="o">=</span> <span class="n">extract_unique_dtypes_from_dtypes_set</span><span class="p">(</span>
                <span class="n">exclude</span><span class="p">,</span> <span class="n">unique_dtypes</span>
            <span class="p">)</span>
            <span class="n">keep_these</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">excluded_dtypes</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">keep_these</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">allow_duplicates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert column into DataFrame at specified location.</span>

<span class="sd">        Raises a ValueError if `column` is already contained in the DataFrame,</span>
<span class="sd">        unless `allow_duplicates` is set to True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">            Insertion index. Must verify 0 &lt;= loc &lt;= len(columns).</span>
<span class="sd">        column : str, number, or hashable object</span>
<span class="sd">            Label of the inserted column.</span>
<span class="sd">        value : int, Series, or array-like</span>
<span class="sd">        allow_duplicates : bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_valid_index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">allow_duplicates</span><span class="o">=</span><span class="n">allow_duplicates</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign new columns to a DataFrame.</span>

<span class="sd">        Returns a new object with all original columns in addition to new ones.</span>
<span class="sd">        Existing columns that are re-assigned will be overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict of {str: callable or Series}</span>
<span class="sd">            The column names are keywords. If the values are</span>
<span class="sd">            callable, they are computed on the DataFrame and</span>
<span class="sd">            assigned to the new columns. The callable must not</span>
<span class="sd">            change input DataFrame (though pandas doesn&#39;t check it).</span>
<span class="sd">            If the values are not callable, (e.g. a Series, scalar, or array),</span>
<span class="sd">            they are simply assigned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A new DataFrame with the new columns in addition to</span>
<span class="sd">            all the existing columns.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assigning multiple columns within the same ``assign`` is possible.</span>
<span class="sd">        Later items in &#39;\*\*kwargs&#39; may refer to newly created or modified</span>
<span class="sd">        columns in &#39;df&#39;; items are computed and assigned into &#39;df&#39; in order.</span>

<span class="sd">        .. versionchanged:: 0.23.0</span>

<span class="sd">           Keyword argument order is maintained.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;temp_c&#39;: [17.0, 25.0]},</span>
<span class="sd">        ...                   index=[&#39;Portland&#39;, &#39;Berkeley&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  temp_c</span>
<span class="sd">        Portland    17.0</span>
<span class="sd">        Berkeley    25.0</span>

<span class="sd">        Where the value is a callable, evaluated on `df`:</span>

<span class="sd">        &gt;&gt;&gt; df.assign(temp_f=lambda x: x.temp_c * 9 / 5 + 32)</span>
<span class="sd">                  temp_c  temp_f</span>
<span class="sd">        Portland    17.0    62.6</span>
<span class="sd">        Berkeley    25.0    77.0</span>

<span class="sd">        Alternatively, the same behavior can be achieved by directly</span>
<span class="sd">        referencing an existing Series or sequence:</span>

<span class="sd">        &gt;&gt;&gt; df.assign(temp_f=df[&#39;temp_c&#39;] * 9 / 5 + 32)</span>
<span class="sd">                  temp_c  temp_f</span>
<span class="sd">        Portland    17.0    62.6</span>
<span class="sd">        Berkeley    25.0    77.0</span>

<span class="sd">        You can create multiple columns within the same assign where one</span>
<span class="sd">        of the columns depends on another one defined within the same assign:</span>

<span class="sd">        &gt;&gt;&gt; df.assign(temp_f=lambda x: x[&#39;temp_c&#39;] * 9 / 5 + 32,</span>
<span class="sd">        ...           temp_k=lambda x: (x[&#39;temp_f&#39;] +  459.67) * 5 / 9)</span>
<span class="sd">                  temp_c  temp_f  temp_k</span>
<span class="sd">        Portland    17.0    62.6  290.15</span>
<span class="sd">        Berkeley    25.0    77.0  298.15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_sanitize_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures new columns (which go into the BlockManager as new blocks) are</span>
<span class="sd">        always copied and converted into an array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>
<span class="sd">        value : scalar, Series, or array-like</span>
<span class="sd">        broadcast : bool, default True</span>
<span class="sd">            If ``key`` matches multiple duplicate column names in the</span>
<span class="sd">            DataFrame, this parameter indicates whether ``value`` should be</span>
<span class="sd">            tiled so that the returned array contains a (duplicated) column for</span>
<span class="sd">            each occurrence of the key. If False, ``value`` will not be tiled.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">reindexer</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="c1"># reindex if necessary</span>

            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># GH 4107</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1"># raised in MultiIndex.from_tuples, see test_insert_error_msmgs</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                        <span class="c1"># duplicate axis</span>
                        <span class="k">raise</span> <span class="n">err</span>

                    <span class="c1"># other</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;incompatible index of inserted column with frame index&quot;</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">reindexer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># align right-hand-side columns if self.columns</span>
            <span class="c1"># is multi-index and self[key] is a sub-frame</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
                    <span class="n">cols</span> <span class="o">=</span> <span class="n">maybe_droplevels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">key</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cols</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># now align rows</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">reindexer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
            <span class="c1"># Explicitly copy here, instead of in sanitize_index,</span>
            <span class="c1"># as sanitize_index won&#39;t copy an EA, even with copy=True</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">sanitize_index</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>

            <span class="c1"># turn me into an ndarray</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">sanitize_index</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">maybe_convert_platform</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">asarray_tuplesafe</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c1"># possibly infer to datetimelike</span>
            <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">maybe_infer_to_datetimelike</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cast ignores pandas dtypes. so save the dtype first</span>
            <span class="n">infer_dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">infer_dtype_from_scalar</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pandas_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># upcast</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cast_scalar_to_array</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">maybe_cast_to_datetime</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">infer_dtype</span><span class="p">)</span>

        <span class="c1"># return internal types directly</span>
        <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># broadcast across multiple columns if necessary</span>
        <span class="k">if</span> <span class="n">broadcast</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="n">existing_piece</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing_piece</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">existing_piece</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">item</span><span class="p">:</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">iget</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_labels</span><span class="p">,</span> <span class="n">col_labels</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label-based &quot;fancy indexing&quot; function for DataFrame.</span>

<span class="sd">        Given equal-length arrays of row and column labels, return an</span>
<span class="sd">        array of the values corresponding to each (row, col) pair.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row_labels : sequence</span>
<span class="sd">            The row labels to use for lookup.</span>
<span class="sd">        col_labels : sequence</span>
<span class="sd">            The column labels to use for lookup.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">            The found values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Row labels must have same size as column labels&quot;</span><span class="p">)</span>

        <span class="n">thresh</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">row_labels</span><span class="p">)</span>
            <span class="n">cidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">col_labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ridx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;One or more row labels was not found&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cidx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;One or more column labels was not found&quot;</span><span class="p">)</span>
            <span class="n">flat_index</span> <span class="o">=</span> <span class="n">ridx</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">cidx</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">flat_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">row_labels</span><span class="p">,</span> <span class="n">col_labels</span><span class="p">)):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_value</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Reindexing and alignment</span>

    <span class="k">def</span> <span class="nf">_reindex_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_reindex_columns</span><span class="p">(</span>
                <span class="n">columns</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span>
            <span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_reindex_index</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">frame</span>

    <span class="k">def</span> <span class="nf">_reindex_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_index</span><span class="p">,</span>
        <span class="n">method</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">,</span>
        <span class="n">level</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_columns</span><span class="p">,</span>
        <span class="n">method</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">,</span>
        <span class="n">level</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">new_columns</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">new_columns</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We are guaranteed non-Nones in the axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_index</span><span class="p">,</span> <span class="n">row_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
        <span class="n">new_columns</span><span class="p">,</span> <span class="n">col_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">row_indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">col_indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">row_indexer</span><span class="p">,</span> <span class="n">col_indexer</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">take_2d_multi</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
                <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">row_indexer</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">col_indexer</span><span class="p">]},</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;align&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">broadcast_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
            <span class="n">broadcast_axis</span><span class="o">=</span><span class="n">broadcast_axis</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">reindex</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="nd">@rewrite_axis_style_signature</span><span class="p">(</span>
        <span class="s2">&quot;labels&quot;</span><span class="p">,</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;limit&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;tolerance&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">validate_axis_style_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s2">&quot;labels&quot;</span><span class="p">,</span> <span class="s2">&quot;reindex&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="c1"># Pop these, since the values are in `kwargs` under different names</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;labels&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop specified labels from rows or columns.</span>

<span class="sd">        Remove rows or columns by specifying label names and corresponding</span>
<span class="sd">        axis, or by specifying directly index or column names. When using a</span>
<span class="sd">        multi-index, labels on different levels can be removed by specifying</span>
<span class="sd">        the level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">            Index or column labels to drop.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Whether to drop labels from the index (0 or &#39;index&#39;) or</span>
<span class="sd">            columns (1 or &#39;columns&#39;).</span>
<span class="sd">        index : single label or list-like</span>
<span class="sd">            Alternative to specifying axis (``labels, axis=0``</span>
<span class="sd">            is equivalent to ``index=labels``).</span>

<span class="sd">            .. versionadded:: 0.21.0</span>
<span class="sd">        columns : single label or list-like</span>
<span class="sd">            Alternative to specifying axis (``labels, axis=1``</span>
<span class="sd">            is equivalent to ``columns=labels``).</span>

<span class="sd">            .. versionadded:: 0.21.0</span>
<span class="sd">        level : int or level name, optional</span>
<span class="sd">            For MultiIndex, level from which the labels will be removed.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and only existing labels are</span>
<span class="sd">            dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame without the removed index or column labels.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If any of the labels is not found in the selected axis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Label-location based indexer for selection by label.</span>
<span class="sd">        DataFrame.dropna : Return DataFrame with labels on given axis omitted</span>
<span class="sd">            where (all or any) data are missing.</span>
<span class="sd">        DataFrame.drop_duplicates : Return DataFrame with duplicate rows</span>
<span class="sd">            removed, optionally only considering certain columns.</span>
<span class="sd">        Series.drop : Return Series with specified index labels removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.arange(12).reshape(3, 4),</span>
<span class="sd">        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B   C   D</span>
<span class="sd">        0  0  1   2   3</span>
<span class="sd">        1  4  5   6   7</span>
<span class="sd">        2  8  9  10  11</span>

<span class="sd">        Drop columns</span>

<span class="sd">        &gt;&gt;&gt; df.drop([&#39;B&#39;, &#39;C&#39;], axis=1)</span>
<span class="sd">           A   D</span>
<span class="sd">        0  0   3</span>
<span class="sd">        1  4   7</span>
<span class="sd">        2  8  11</span>

<span class="sd">        &gt;&gt;&gt; df.drop(columns=[&#39;B&#39;, &#39;C&#39;])</span>
<span class="sd">           A   D</span>
<span class="sd">        0  0   3</span>
<span class="sd">        1  4   7</span>
<span class="sd">        2  8  11</span>

<span class="sd">        Drop a row by index</span>

<span class="sd">        &gt;&gt;&gt; df.drop([0, 1])</span>
<span class="sd">           A  B   C   D</span>
<span class="sd">        2  8  9  10  11</span>

<span class="sd">        Drop columns and/or rows of MultiIndex DataFrame</span>

<span class="sd">        &gt;&gt;&gt; midx = pd.MultiIndex(levels=[[&#39;lama&#39;, &#39;cow&#39;, &#39;falcon&#39;],</span>
<span class="sd">        ...                              [&#39;speed&#39;, &#39;weight&#39;, &#39;length&#39;]],</span>
<span class="sd">        ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],</span>
<span class="sd">        ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(index=midx, columns=[&#39;big&#39;, &#39;small&#39;],</span>
<span class="sd">        ...                   data=[[45, 30], [200, 100], [1.5, 1], [30, 20],</span>
<span class="sd">        ...                         [250, 150], [1.5, 0.8], [320, 250],</span>
<span class="sd">        ...                         [1, 0.8], [0.3, 0.2]])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        big     small</span>
<span class="sd">        lama    speed   45.0    30.0</span>
<span class="sd">                weight  200.0   100.0</span>
<span class="sd">                length  1.5     1.0</span>
<span class="sd">        cow     speed   30.0    20.0</span>
<span class="sd">                weight  250.0   150.0</span>
<span class="sd">                length  1.5     0.8</span>
<span class="sd">        falcon  speed   320.0   250.0</span>
<span class="sd">                weight  1.0     0.8</span>
<span class="sd">                length  0.3     0.2</span>

<span class="sd">        &gt;&gt;&gt; df.drop(index=&#39;cow&#39;, columns=&#39;small&#39;)</span>
<span class="sd">                        big</span>
<span class="sd">        lama    speed   45.0</span>
<span class="sd">                weight  200.0</span>
<span class="sd">                length  1.5</span>
<span class="sd">        falcon  speed   320.0</span>
<span class="sd">                weight  1.0</span>
<span class="sd">                length  0.3</span>

<span class="sd">        &gt;&gt;&gt; df.drop(index=&#39;length&#39;, level=1)</span>
<span class="sd">                        big     small</span>
<span class="sd">        lama    speed   45.0    30.0</span>
<span class="sd">                weight  200.0   100.0</span>
<span class="sd">        cow     speed   30.0    20.0</span>
<span class="sd">                weight  250.0   150.0</span>
<span class="sd">        falcon  speed   320.0   250.0</span>
<span class="sd">                weight  1.0     0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@rewrite_axis_style_signature</span><span class="p">(</span>
        <span class="s2">&quot;mapper&quot;</span><span class="p">,</span>
        <span class="p">[(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;inplace&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;errors&quot;</span><span class="p">,</span> <span class="s2">&quot;ignore&quot;</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Renamer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Renamer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Renamer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Level</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">]:</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alter axes labels.</span>

<span class="sd">        Function / dict values must be unique (1-to-1). Labels not contained in</span>
<span class="sd">        a dict / Series will be left as-is. Extra labels listed don&#39;t throw an</span>
<span class="sd">        error.</span>

<span class="sd">        See the :ref:`user guide &lt;basics.rename&gt;` for more.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : dict-like or function</span>
<span class="sd">            Dict-like or functions transformations to apply to</span>
<span class="sd">            that axis&#39; values. Use either ``mapper`` and ``axis`` to</span>
<span class="sd">            specify the axis to target with ``mapper``, or ``index`` and</span>
<span class="sd">            ``columns``.</span>
<span class="sd">        index : dict-like or function</span>
<span class="sd">            Alternative to specifying axis (``mapper, axis=0``</span>
<span class="sd">            is equivalent to ``index=mapper``).</span>
<span class="sd">        columns : dict-like or function</span>
<span class="sd">            Alternative to specifying axis (``mapper, axis=1``</span>
<span class="sd">            is equivalent to ``columns=mapper``).</span>
<span class="sd">        axis : int or str</span>
<span class="sd">            Axis to target with ``mapper``. Can be either the axis name</span>
<span class="sd">            (&#39;index&#39;, &#39;columns&#39;) or number (0, 1). The default is &#39;index&#39;.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Also copy underlying data.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to return a new DataFrame. If True then value of copy is</span>
<span class="sd">            ignored.</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            In case of a MultiIndex, only rename labels in the specified</span>
<span class="sd">            level.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;ignore&#39;</span>
<span class="sd">            If &#39;raise&#39;, raise a `KeyError` when a dict-like `mapper`, `index`,</span>
<span class="sd">            or `columns` contains labels that are not present in the Index</span>
<span class="sd">            being transformed.</span>
<span class="sd">            If &#39;ignore&#39;, existing keys will be renamed and extra keys will be</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame with the renamed axis labels.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If any of the labels is not found in the selected axis and</span>
<span class="sd">            &quot;errors=&#39;raise&#39;&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.rename_axis : Set the name of the axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        ``DataFrame.rename`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_mapper, columns=columns_mapper, ...)``</span>
<span class="sd">        * ``(mapper, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        Rename columns using a mapping:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.rename(columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;c&quot;})</span>
<span class="sd">           a  c</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        Rename index using a mapping:</span>

<span class="sd">        &gt;&gt;&gt; df.rename(index={0: &quot;x&quot;, 1: &quot;y&quot;, 2: &quot;z&quot;})</span>
<span class="sd">           A  B</span>
<span class="sd">        x  1  4</span>
<span class="sd">        y  2  5</span>
<span class="sd">        z  3  6</span>

<span class="sd">        Cast index labels to a different type:</span>

<span class="sd">        &gt;&gt;&gt; df.index</span>
<span class="sd">        RangeIndex(start=0, stop=3, step=1)</span>
<span class="sd">        &gt;&gt;&gt; df.rename(index=str).index</span>
<span class="sd">        Index([&#39;0&#39;, &#39;1&#39;, &#39;2&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; df.rename(columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;b&quot;, &quot;C&quot;: &quot;c&quot;}, errors=&quot;raise&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        KeyError: [&#39;C&#39;] not found in axis</span>

<span class="sd">        Using axis-style parameters</span>

<span class="sd">        &gt;&gt;&gt; df.rename(str.lower, axis=&#39;columns&#39;)</span>
<span class="sd">           a  b</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        &gt;&gt;&gt; df.rename({1: 2, 2: 4}, axis=&#39;index&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  4</span>
<span class="sd">        2  2  5</span>
<span class="sd">        4  3  6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">mapper</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">fillna</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;replace&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the DataFrame index using existing columns.</span>

<span class="sd">        Set the DataFrame index (row labels) using one or more existing</span>
<span class="sd">        columns or arrays (of the correct length). The index can replace the</span>
<span class="sd">        existing index or expand on it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : label or array-like or list of labels/arrays</span>
<span class="sd">            This parameter can be either a single column key, a single array of</span>
<span class="sd">            the same length as the calling DataFrame, or a list containing an</span>
<span class="sd">            arbitrary combination of column keys and arrays. Here, &quot;array&quot;</span>
<span class="sd">            encompasses :class:`Series`, :class:`Index`, ``np.ndarray``, and</span>
<span class="sd">            instances of :class:`~collections.abc.Iterator`.</span>
<span class="sd">        drop : bool, default True</span>
<span class="sd">            Delete columns to be used as the new index.</span>
<span class="sd">        append : bool, default False</span>
<span class="sd">            Whether to append columns to existing index.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modify the DataFrame in place (do not create a new object).</span>
<span class="sd">        verify_integrity : bool, default False</span>
<span class="sd">            Check the new index for duplicates. Otherwise defer the check until</span>
<span class="sd">            necessary. Setting to False will improve the performance of this</span>
<span class="sd">            method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Changed row labels.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.reset_index : Opposite of set_index.</span>
<span class="sd">        DataFrame.reindex : Change to new indices or expand indices.</span>
<span class="sd">        DataFrame.reindex_like : Change to same indices as other DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;month&#39;: [1, 4, 7, 10],</span>
<span class="sd">        ...                    &#39;year&#39;: [2012, 2014, 2013, 2014],</span>
<span class="sd">        ...                    &#39;sale&#39;: [55, 40, 84, 31]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           month  year  sale</span>
<span class="sd">        0      1  2012    55</span>
<span class="sd">        1      4  2014    40</span>
<span class="sd">        2      7  2013    84</span>
<span class="sd">        3     10  2014    31</span>

<span class="sd">        Set the index to become the &#39;month&#39; column:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index(&#39;month&#39;)</span>
<span class="sd">               year  sale</span>
<span class="sd">        month</span>
<span class="sd">        1      2012    55</span>
<span class="sd">        4      2014    40</span>
<span class="sd">        7      2013    84</span>
<span class="sd">        10     2014    31</span>

<span class="sd">        Create a MultiIndex using columns &#39;year&#39; and &#39;month&#39;:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index([&#39;year&#39;, &#39;month&#39;])</span>
<span class="sd">                    sale</span>
<span class="sd">        year  month</span>
<span class="sd">        2012  1     55</span>
<span class="sd">        2014  4     40</span>
<span class="sd">        2013  7     84</span>
<span class="sd">        2014  10    31</span>

<span class="sd">        Create a MultiIndex using an Index and a column:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index([pd.Index([1, 2, 3, 4]), &#39;year&#39;])</span>
<span class="sd">                 month  sale</span>
<span class="sd">           year</span>
<span class="sd">        1  2012  1      55</span>
<span class="sd">        2  2014  4      40</span>
<span class="sd">        3  2013  7      84</span>
<span class="sd">        4  2014  10     31</span>

<span class="sd">        Create a MultiIndex using two Series:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; df.set_index([s, s**2])</span>
<span class="sd">              month  year  sale</span>
<span class="sd">        1 1       1  2012    55</span>
<span class="sd">        2 4       4  2014    40</span>
<span class="sd">        3 9       7  2013    84</span>
<span class="sd">        4 16     10  2014    31</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span>

        <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;The parameter &quot;keys&quot; may be a column key, one-dimensional &#39;</span>
            <span class="s2">&quot;array, or a list containing only valid column keys and &quot;</span>
            <span class="s2">&quot;one-dimensional arrays.&quot;</span>
        <span class="p">)</span>

        <span class="n">missing</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCIndexClass</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># arrays are fine as long as they are one-dimensional</span>
                <span class="c1"># iterators get converted to list below</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># everything else gets tried as a key; see GH 24969</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2">. Received column of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                        <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;None of </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2"> are in the columns&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">):</span>
                    <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_values</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">to_remove</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">nlevels</span><span class="p">):</span>
                    <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">_get_level_values</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="n">names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCIndexClass</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="c1"># if Index then not MultiIndex (treated above)</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">):</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># from here, col can only be a column label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">_values</span><span class="p">)</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># check newest element against length of calling frame, since</span>
                <span class="c1"># ensure_index_from_sequences would not raise for append=False.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Length mismatch: Expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> rows, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;received array of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">ensure_index_from_sequences</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verify_integrity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index has duplicate keys: </span><span class="si">{</span><span class="n">duplicates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># use set to handle duplicate column names gracefully in case of drop</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">frame</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="c1"># clear up memory usage</span>
        <span class="n">index</span><span class="o">.</span><span class="n">_cleanup</span><span class="p">()</span>

        <span class="n">frame</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">frame</span>

    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">col_level</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">col_fill</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the index, or a level of it.</span>

<span class="sd">        Reset the index of the DataFrame, and use the default one instead.</span>
<span class="sd">        If the DataFrame has a MultiIndex, this method can remove one or more</span>
<span class="sd">        levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, tuple, or list, default None</span>
<span class="sd">            Only remove the given levels from the index. Removes all levels by</span>
<span class="sd">            default.</span>
<span class="sd">        drop : bool, default False</span>
<span class="sd">            Do not try to insert index into dataframe columns. This resets</span>
<span class="sd">            the index to the default integer index.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modify the DataFrame in place (do not create a new object).</span>
<span class="sd">        col_level : int or str, default 0</span>
<span class="sd">            If the columns have multiple levels, determines which level the</span>
<span class="sd">            labels are inserted into. By default it is inserted into the first</span>
<span class="sd">            level.</span>
<span class="sd">        col_fill : object, default &#39;&#39;</span>
<span class="sd">            If the columns have multiple levels, determines how the other</span>
<span class="sd">            levels are named. If None then the index name is repeated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame with the new index or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.set_index : Opposite of reset_index.</span>
<span class="sd">        DataFrame.reindex : Change to new indices or expand indices.</span>
<span class="sd">        DataFrame.reindex_like : Change to same indices as other DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;parrot&#39;, &#39;lion&#39;, &#39;monkey&#39;],</span>
<span class="sd">        ...                   columns=(&#39;class&#39;, &#39;max_speed&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                 class  max_speed</span>
<span class="sd">        falcon    bird      389.0</span>
<span class="sd">        parrot    bird       24.0</span>
<span class="sd">        lion    mammal       80.5</span>
<span class="sd">        monkey  mammal        NaN</span>

<span class="sd">        When we reset the index, the old index is added as a column, and a</span>
<span class="sd">        new sequential index is used:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index()</span>
<span class="sd">            index   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        3  monkey  mammal        NaN</span>

<span class="sd">        We can use the `drop` parameter to avoid the old index being added as</span>
<span class="sd">        a column:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(drop=True)</span>
<span class="sd">            class  max_speed</span>
<span class="sd">        0    bird      389.0</span>
<span class="sd">        1    bird       24.0</span>
<span class="sd">        2  mammal       80.5</span>
<span class="sd">        3  mammal        NaN</span>

<span class="sd">        You can also use `reset_index` with `MultiIndex`.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.MultiIndex.from_tuples([(&#39;bird&#39;, &#39;falcon&#39;),</span>
<span class="sd">        ...                                    (&#39;bird&#39;, &#39;parrot&#39;),</span>
<span class="sd">        ...                                    (&#39;mammal&#39;, &#39;lion&#39;),</span>
<span class="sd">        ...                                    (&#39;mammal&#39;, &#39;monkey&#39;)],</span>
<span class="sd">        ...                                   names=[&#39;class&#39;, &#39;name&#39;])</span>
<span class="sd">        &gt;&gt;&gt; columns = pd.MultiIndex.from_tuples([(&#39;speed&#39;, &#39;max&#39;),</span>
<span class="sd">        ...                                      (&#39;species&#39;, &#39;type&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(389.0, &#39;fly&#39;),</span>
<span class="sd">        ...                    ( 24.0, &#39;fly&#39;),</span>
<span class="sd">        ...                    ( 80.5, &#39;run&#39;),</span>
<span class="sd">        ...                    (np.nan, &#39;jump&#39;)],</span>
<span class="sd">        ...                   index=index,</span>
<span class="sd">        ...                   columns=columns)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                       speed species</span>
<span class="sd">                         max    type</span>
<span class="sd">        class  name</span>
<span class="sd">        bird   falcon  389.0     fly</span>
<span class="sd">               parrot   24.0     fly</span>
<span class="sd">        mammal lion     80.5     run</span>
<span class="sd">               monkey    NaN    jump</span>

<span class="sd">        If the index has multiple levels, we can reset a subset of them:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;)</span>
<span class="sd">                 class  speed species</span>
<span class="sd">                          max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon    bird  389.0     fly</span>
<span class="sd">        parrot    bird   24.0     fly</span>
<span class="sd">        lion    mammal   80.5     run</span>
<span class="sd">        monkey  mammal    NaN    jump</span>

<span class="sd">        If we are not dropping the index, by default, it is placed in the top</span>
<span class="sd">        level. We can place it in another level:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;, col_level=1)</span>
<span class="sd">                        speed species</span>
<span class="sd">                 class    max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon    bird  389.0     fly</span>
<span class="sd">        parrot    bird   24.0     fly</span>
<span class="sd">        lion    mammal   80.5     run</span>
<span class="sd">        monkey  mammal    NaN    jump</span>

<span class="sd">        When the index is inserted under another level, we can specify under</span>
<span class="sd">        which one with the parameter `col_fill`:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;, col_level=1, col_fill=&#39;species&#39;)</span>
<span class="sd">                      species  speed species</span>
<span class="sd">                        class    max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon           bird  389.0     fly</span>
<span class="sd">        parrot           bird   24.0     fly</span>
<span class="sd">        lion           mammal   80.5     run</span>
<span class="sd">        monkey         mammal    NaN    jump</span>

<span class="sd">        If we specify a nonexistent level for `col_fill`, it is created:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;, col_level=1, col_fill=&#39;genus&#39;)</span>
<span class="sd">                        genus  speed species</span>
<span class="sd">                        class    max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon           bird  389.0     fly</span>
<span class="sd">        parrot           bird   24.0     fly</span>
<span class="sd">        lion           mammal   80.5     run</span>
<span class="sd">        monkey         mammal    NaN    jump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_maybe_casted_values</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_values</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">PeriodIndex</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># if we have the labels, extract the values with a mask</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

                <span class="c1"># we can have situations where the whole mask is -1,</span>
                <span class="c1"># meaning there is nothing found in labels, so make all nan&#39;s</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
                    <span class="n">values</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

                    <span class="c1"># TODO(https://github.com/pandas-dev/pandas/issues/24206)</span>
                    <span class="c1"># Push this into maybe_upcast_putmask?</span>
                    <span class="c1"># We can&#39;t pass EAs there right now. Looks a bit</span>
                    <span class="c1"># complicated.</span>
                    <span class="c1"># So we unbox the ndarray_values, op, re-box.</span>
                    <span class="n">values_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                    <span class="n">values_dtype</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span>

                    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">values_type</span><span class="p">,</span> <span class="n">DatetimeLikeArray</span><span class="p">):</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">_data</span>

                    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="n">values</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">maybe_upcast_putmask</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">values_type</span><span class="p">,</span> <span class="n">DatetimeLikeArray</span><span class="p">):</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">values_type</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values_dtype</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">values</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_obj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">level</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">:</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">drop</span><span class="p">:</span>
            <span class="n">to_insert</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;level_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">to_insert</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;index&quot;</span> <span class="k">if</span> <span class="s2">&quot;index&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">else</span> <span class="s2">&quot;level_0&quot;</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">default</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="n">to_insert</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span>

            <span class="n">multi_col</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">lab</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">to_insert</span><span class="p">))):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">level</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">multi_col</span><span class="p">:</span>
                    <span class="n">col_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">col_fill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;col_fill=None is incompatible &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;with incomplete column name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="n">col_fill</span> <span class="o">=</span> <span class="n">col_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">lev_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">col_level</span><span class="p">)</span>
                    <span class="n">name_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_fill</span><span class="p">]</span> <span class="o">*</span> <span class="n">lev_num</span> <span class="o">+</span> <span class="n">col_name</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_lst</span><span class="p">)</span>
                    <span class="n">name_lst</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col_fill</span><span class="p">]</span> <span class="o">*</span> <span class="n">missing</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">name_lst</span><span class="p">)</span>
                <span class="c1"># to ndarray and maybe infer different dtype</span>
                <span class="n">level_values</span> <span class="o">=</span> <span class="n">_maybe_casted_values</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">lab</span><span class="p">)</span>
                <span class="n">new_obj</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">level_values</span><span class="p">)</span>

        <span class="n">new_obj</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_obj</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Reindex-based selection methods</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;isna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;isna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;notna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;notna&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">notnull</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove missing values.</span>

<span class="sd">        See the :ref:`User Guide &lt;missing_data&gt;` for more on which values are</span>
<span class="sd">        considered missing, and how to work with missing data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Determine if rows or columns which contain missing values are</span>
<span class="sd">            removed.</span>

<span class="sd">            * 0, or &#39;index&#39; : Drop rows which contain missing values.</span>
<span class="sd">            * 1, or &#39;columns&#39; : Drop columns which contain missing value.</span>

<span class="sd">            .. versionchanged:: 1.0.0</span>

<span class="sd">               Pass tuple or list to drop on multiple axes.</span>
<span class="sd">               Only a single axis is allowed.</span>

<span class="sd">        how : {&#39;any&#39;, &#39;all&#39;}, default &#39;any&#39;</span>
<span class="sd">            Determine if row or column is removed from DataFrame, when we have</span>
<span class="sd">            at least one NA or all NA.</span>

<span class="sd">            * &#39;any&#39; : If any NA values are present, drop that row or column.</span>
<span class="sd">            * &#39;all&#39; : If all values are NA, drop that row or column.</span>

<span class="sd">        thresh : int, optional</span>
<span class="sd">            Require that many non-NA values.</span>
<span class="sd">        subset : array-like, optional</span>
<span class="sd">            Labels along other axis to consider, e.g. if you are dropping rows</span>
<span class="sd">            these would be a list of columns to include.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame with NA entries dropped from it.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.isna: Indicate missing values.</span>
<span class="sd">        DataFrame.notna : Indicate existing (non-missing) values.</span>
<span class="sd">        DataFrame.fillna : Replace missing values.</span>
<span class="sd">        Series.dropna : Drop missing values.</span>
<span class="sd">        Index.dropna : Drop missing indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;name&quot;: [&#39;Alfred&#39;, &#39;Batman&#39;, &#39;Catwoman&#39;],</span>
<span class="sd">        ...                    &quot;toy&quot;: [np.nan, &#39;Batmobile&#39;, &#39;Bullwhip&#39;],</span>
<span class="sd">        ...                    &quot;born&quot;: [pd.NaT, pd.Timestamp(&quot;1940-04-25&quot;),</span>
<span class="sd">        ...                             pd.NaT]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        0    Alfred        NaN        NaT</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>

<span class="sd">        Drop the rows where at least one element is missing.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna()</span>
<span class="sd">             name        toy       born</span>
<span class="sd">        1  Batman  Batmobile 1940-04-25</span>

<span class="sd">        Drop the columns where at least one element is missing.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(axis=&#39;columns&#39;)</span>
<span class="sd">               name</span>
<span class="sd">        0    Alfred</span>
<span class="sd">        1    Batman</span>
<span class="sd">        2  Catwoman</span>

<span class="sd">        Drop the rows where all elements are missing.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(how=&#39;all&#39;)</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        0    Alfred        NaN        NaT</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>

<span class="sd">        Keep only the rows with at least 2 non-NA values.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(thresh=2)</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>

<span class="sd">        Define in which columns to look for missing values.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(subset=[&#39;name&#39;, &#39;born&#39;])</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>

<span class="sd">        Keep the DataFrame with valid entries in the same variable.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name        toy       born</span>
<span class="sd">        1  Batman  Batmobile 1940-04-25</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c1"># GH20987</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;supplying multiple axes to axis is no longer supported.&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">agg_axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span>

        <span class="n">agg_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">agg_axis</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">check</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">check</span><span class="p">,</span> <span class="n">subset</span><span class="p">)))</span>
            <span class="n">agg_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">agg_obj</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">thresh</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">agg_obj</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">agg_axis</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">how</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid how option: </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;must specify how or thresh&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return DataFrame with duplicate rows removed.</span>

<span class="sd">        Considering certain columns is optional. Indexes, including time indexes</span>
<span class="sd">        are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : column label or sequence of labels, optional</span>
<span class="sd">            Only consider certain columns for identifying duplicates, by</span>
<span class="sd">            default use all of the columns.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span>
<span class="sd">            Determines which duplicates (if any) to keep.</span>
<span class="sd">            - ``first`` : Drop duplicates except for the first occurrence.</span>
<span class="sd">            - ``last`` : Drop duplicates except for the last occurrence.</span>
<span class="sd">            - False : Drop all duplicates.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to drop duplicates in place or to return a copy.</span>
<span class="sd">        ignore_index : bool, default False</span>
<span class="sd">            If True, the resulting axis will be labeled 0, 1, …, n - 1.</span>

<span class="sd">            .. versionadded:: 1.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame with duplicates removed or None if ``inplace=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">duplicated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="p">(</span><span class="n">inds</span><span class="p">,)</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">duplicated</span><span class="p">)</span><span class="o">.</span><span class="n">_ndarray_values</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="n">duplicated</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Series&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean Series denoting duplicate rows.</span>

<span class="sd">        Considering certain columns is optional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : column label or sequence of labels, optional</span>
<span class="sd">            Only consider certain columns for identifying duplicates, by</span>
<span class="sd">            default use all of the columns.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span>
<span class="sd">            Determines which duplicates (if any) to mark.</span>

<span class="sd">            - ``first`` : Mark duplicates as ``True`` except for the first occurrence.</span>
<span class="sd">            - ``last`` : Mark duplicates as ``True`` except for the last occurrence.</span>
<span class="sd">            - False : Mark all duplicates as ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">get_group_index</span>
        <span class="kn">from</span> <span class="nn">pandas._libs.hashtable</span> <span class="kn">import</span> <span class="n">duplicated_int64</span><span class="p">,</span> <span class="n">_SIZE_HINT_LIMIT</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span>
                <span class="n">vals</span><span class="p">,</span> <span class="n">size_hint</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">_SIZE_HINT_LIMIT</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">subset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">):</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="p">(</span><span class="n">subset</span><span class="p">,)</span>

        <span class="c1">#  needed for mypy since can&#39;t narrow types using np.iterable</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>

        <span class="c1"># Verify all columns in subset exist in the queried dataframe</span>
        <span class="c1"># Otherwise, raise a KeyError, same as if you try to __getitem__ with a</span>
        <span class="c1"># key that doesn&#39;t exist.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">diff</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">)</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">vals</span><span class="p">)))</span>

        <span class="n">ids</span> <span class="o">=</span> <span class="n">get_group_index</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xnull</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">duplicated_int64</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">keep</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Sorting</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">sort_values</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="n">by</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length of ascending (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span><span class="si">}</span><span class="s2">) != length of by (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">lexsort_indexer</span>

            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_label_or_level_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">by</span><span class="p">]</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">lexsort_indexer</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">ensure_platform_int</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">nargsort</span>

            <span class="n">by</span> <span class="o">=</span> <span class="n">by</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_or_level_values</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">ascending</span> <span class="o">=</span> <span class="n">ascending</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span>
            <span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">sort_index</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="o">=</span><span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># TODO: this can be combined with Series.sort_index impl as</span>
        <span class="c1"># almost identical</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># make sure that the axis is lexsorted to start</span>
        <span class="c1"># if not we need to reconstruct to get the correct indexer</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">_sort_levels_monotonic</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">new_axis</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">sortlevel</span><span class="p">(</span>
                <span class="n">level</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="n">sort_remaining</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">lexsort_indexer</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">lexsort_indexer</span><span class="p">(</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">_get_codes_for_sorting</span><span class="p">(),</span>
                <span class="n">orders</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
                <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="n">nargsort</span>

            <span class="c1"># Check monotonic-ness before sort an index</span>
            <span class="c1"># GH11080</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ascending</span> <span class="ow">and</span> <span class="n">labels</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">ascending</span> <span class="ow">and</span> <span class="n">labels</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span>
                <span class="n">labels</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span>
            <span class="p">)</span>

        <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># reconstruct axis if needed</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">baxis</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">baxis</span><span class="p">]</span><span class="o">.</span><span class="n">_sort_levels_monotonic</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ibase</span><span class="o">.</span><span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nlargest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first `n` rows ordered by `columns` in descending order.</span>

<span class="sd">        Return the first `n` rows with the largest values in `columns`, in</span>
<span class="sd">        descending order. The columns that are not specified are returned as</span>
<span class="sd">        well, but not used for ordering.</span>

<span class="sd">        This method is equivalent to</span>
<span class="sd">        ``df.sort_values(columns, ascending=False).head(n)``, but more</span>
<span class="sd">        performant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of rows to return.</span>
<span class="sd">        columns : label or list of labels</span>
<span class="sd">            Column label(s) to order by.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}, default &#39;first&#39;</span>
<span class="sd">            Where there are duplicate values:</span>

<span class="sd">            - `first` : prioritize the first occurrence(s)</span>
<span class="sd">            - `last` : prioritize the last occurrence(s)</span>
<span class="sd">            - ``all`` : do not drop any duplicates, even it means</span>
<span class="sd">                        selecting more than `n` items.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The first `n` rows ordered by the given columns in descending</span>
<span class="sd">            order.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.nsmallest : Return the first `n` rows ordered by `columns` in</span>
<span class="sd">            ascending order.</span>
<span class="sd">        DataFrame.sort_values : Sort DataFrame by the values.</span>
<span class="sd">        DataFrame.head : Return the first `n` rows without re-ordering.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function cannot be used with all column types. For example, when</span>
<span class="sd">        specifying columns with `object` or `category` dtypes, ``TypeError`` is</span>
<span class="sd">        raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;population&#39;: [59000000, 65000000, 434000,</span>
<span class="sd">        ...                                   434000, 434000, 337000, 11300,</span>
<span class="sd">        ...                                   11300, 11300],</span>
<span class="sd">        ...                    &#39;GDP&#39;: [1937894, 2583560 , 12011, 4520, 12128,</span>
<span class="sd">        ...                            17036, 182, 38, 311],</span>
<span class="sd">        ...                    &#39;alpha-2&#39;: [&quot;IT&quot;, &quot;FR&quot;, &quot;MT&quot;, &quot;MV&quot;, &quot;BN&quot;,</span>
<span class="sd">        ...                                &quot;IS&quot;, &quot;NR&quot;, &quot;TV&quot;, &quot;AI&quot;]},</span>
<span class="sd">        ...                   index=[&quot;Italy&quot;, &quot;France&quot;, &quot;Malta&quot;,</span>
<span class="sd">        ...                          &quot;Maldives&quot;, &quot;Brunei&quot;, &quot;Iceland&quot;,</span>
<span class="sd">        ...                          &quot;Nauru&quot;, &quot;Tuvalu&quot;, &quot;Anguilla&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  population      GDP alpha-2</span>
<span class="sd">        Italy       59000000  1937894      IT</span>
<span class="sd">        France      65000000  2583560      FR</span>
<span class="sd">        Malta         434000    12011      MT</span>
<span class="sd">        Maldives      434000     4520      MV</span>
<span class="sd">        Brunei        434000    12128      BN</span>
<span class="sd">        Iceland       337000    17036      IS</span>
<span class="sd">        Nauru          11300      182      NR</span>
<span class="sd">        Tuvalu         11300       38      TV</span>
<span class="sd">        Anguilla       11300      311      AI</span>

<span class="sd">        In the following example, we will use ``nlargest`` to select the three</span>
<span class="sd">        rows having the largest values in column &quot;population&quot;.</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, &#39;population&#39;)</span>
<span class="sd">                population      GDP alpha-2</span>
<span class="sd">        France    65000000  2583560      FR</span>
<span class="sd">        Italy     59000000  1937894      IT</span>
<span class="sd">        Malta       434000    12011      MT</span>

<span class="sd">        When using ``keep=&#39;last&#39;``, ties are resolved in reverse order:</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, &#39;population&#39;, keep=&#39;last&#39;)</span>
<span class="sd">                population      GDP alpha-2</span>
<span class="sd">        France    65000000  2583560      FR</span>
<span class="sd">        Italy     59000000  1937894      IT</span>
<span class="sd">        Brunei      434000    12128      BN</span>

<span class="sd">        When using ``keep=&#39;all&#39;``, all duplicate items are maintained:</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, &#39;population&#39;, keep=&#39;all&#39;)</span>
<span class="sd">                  population      GDP alpha-2</span>
<span class="sd">        France      65000000  2583560      FR</span>
<span class="sd">        Italy       59000000  1937894      IT</span>
<span class="sd">        Malta         434000    12011      MT</span>
<span class="sd">        Maldives      434000     4520      MV</span>
<span class="sd">        Brunei        434000    12128      BN</span>

<span class="sd">        To order by the largest values in column &quot;population&quot; and then &quot;GDP&quot;,</span>
<span class="sd">        we can specify multiple columns like in the next example.</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, [&#39;population&#39;, &#39;GDP&#39;])</span>
<span class="sd">                population      GDP alpha-2</span>
<span class="sd">        France    65000000  2583560      FR</span>
<span class="sd">        Italy     59000000  1937894      IT</span>
<span class="sd">        Brunei      434000    12128      BN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">SelectNFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">nlargest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nsmallest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first `n` rows ordered by `columns` in ascending order.</span>

<span class="sd">        Return the first `n` rows with the smallest values in `columns`, in</span>
<span class="sd">        ascending order. The columns that are not specified are returned as</span>
<span class="sd">        well, but not used for ordering.</span>

<span class="sd">        This method is equivalent to</span>
<span class="sd">        ``df.sort_values(columns, ascending=True).head(n)``, but more</span>
<span class="sd">        performant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of items to retrieve.</span>
<span class="sd">        columns : list or str</span>
<span class="sd">            Column name or names to order by.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}, default &#39;first&#39;</span>
<span class="sd">            Where there are duplicate values:</span>

<span class="sd">            - ``first`` : take the first occurrence.</span>
<span class="sd">            - ``last`` : take the last occurrence.</span>
<span class="sd">            - ``all`` : do not drop any duplicates, even it means</span>
<span class="sd">              selecting more than `n` items.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.nlargest : Return the first `n` rows ordered by `columns` in</span>
<span class="sd">            descending order.</span>
<span class="sd">        DataFrame.sort_values : Sort DataFrame by the values.</span>
<span class="sd">        DataFrame.head : Return the first `n` rows without re-ordering.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;population&#39;: [59000000, 65000000, 434000,</span>
<span class="sd">        ...                                   434000, 434000, 337000, 11300,</span>
<span class="sd">        ...                                   11300, 11300],</span>
<span class="sd">        ...                    &#39;GDP&#39;: [1937894, 2583560 , 12011, 4520, 12128,</span>
<span class="sd">        ...                            17036, 182, 38, 311],</span>
<span class="sd">        ...                    &#39;alpha-2&#39;: [&quot;IT&quot;, &quot;FR&quot;, &quot;MT&quot;, &quot;MV&quot;, &quot;BN&quot;,</span>
<span class="sd">        ...                                &quot;IS&quot;, &quot;NR&quot;, &quot;TV&quot;, &quot;AI&quot;]},</span>
<span class="sd">        ...                   index=[&quot;Italy&quot;, &quot;France&quot;, &quot;Malta&quot;,</span>
<span class="sd">        ...                          &quot;Maldives&quot;, &quot;Brunei&quot;, &quot;Iceland&quot;,</span>
<span class="sd">        ...                          &quot;Nauru&quot;, &quot;Tuvalu&quot;, &quot;Anguilla&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  population      GDP alpha-2</span>
<span class="sd">        Italy       59000000  1937894      IT</span>
<span class="sd">        France      65000000  2583560      FR</span>
<span class="sd">        Malta         434000    12011      MT</span>
<span class="sd">        Maldives      434000     4520      MV</span>
<span class="sd">        Brunei        434000    12128      BN</span>
<span class="sd">        Iceland       337000    17036      IS</span>
<span class="sd">        Nauru          11300      182      NR</span>
<span class="sd">        Tuvalu         11300       38      TV</span>
<span class="sd">        Anguilla       11300      311      AI</span>

<span class="sd">        In the following example, we will use ``nsmallest`` to select the</span>
<span class="sd">        three rows having the smallest values in column &quot;a&quot;.</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, &#39;population&#39;)</span>
<span class="sd">                  population  GDP alpha-2</span>
<span class="sd">        Nauru          11300  182      NR</span>
<span class="sd">        Tuvalu         11300   38      TV</span>
<span class="sd">        Anguilla       11300  311      AI</span>

<span class="sd">        When using ``keep=&#39;last&#39;``, ties are resolved in reverse order:</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, &#39;population&#39;, keep=&#39;last&#39;)</span>
<span class="sd">                  population  GDP alpha-2</span>
<span class="sd">        Anguilla       11300  311      AI</span>
<span class="sd">        Tuvalu         11300   38      TV</span>
<span class="sd">        Nauru          11300  182      NR</span>

<span class="sd">        When using ``keep=&#39;all&#39;``, all duplicate items are maintained:</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, &#39;population&#39;, keep=&#39;all&#39;)</span>
<span class="sd">                  population  GDP alpha-2</span>
<span class="sd">        Nauru          11300  182      NR</span>
<span class="sd">        Tuvalu         11300   38      TV</span>
<span class="sd">        Anguilla       11300  311      AI</span>

<span class="sd">        To order by the largest values in column &quot;a&quot; and then &quot;c&quot;, we can</span>
<span class="sd">        specify multiple columns like in the next example.</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, [&#39;population&#39;, &#39;GDP&#39;])</span>
<span class="sd">                  population  GDP alpha-2</span>
<span class="sd">        Tuvalu         11300   38      TV</span>
<span class="sd">        Nauru          11300  182      NR</span>
<span class="sd">        Anguilla       11300  311      AI</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">SelectNFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span>
        <span class="p">)</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap levels i and j in a MultiIndex on a particular axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int or str</span>
<span class="sd">            Levels of the indices to be swapped. Can pass level name as string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rearrange index levels using input order. May not drop or duplicate levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : list of int or list of str</span>
<span class="sd">            List representing new level order. Reference level by number</span>
<span class="sd">            (position) or by key (label).</span>
<span class="sd">        axis : int</span>
<span class="sd">            Where to reorder levels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only reorder levels on a hierarchical axis.&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Arithmetic / combination related</span>

    <span class="k">def</span> <span class="nf">_combine_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># at this point we have `self._indexed_same(other)`</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># since _arith_op may be called in a loop, avoid function call</span>
            <span class="c1">#  overhead if possible by doing this check once</span>
            <span class="n">_arith_op</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">_arith_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
                <span class="c1"># for the mixed_type case where we iterate over columns,</span>
                <span class="c1"># _arith_op(left, right) is equivalent to</span>
                <span class="c1"># left._binop(right, func, fill_value=fill_value)</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fill_binop</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ops</span><span class="o">.</span><span class="n">should_series_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
            <span class="c1"># iterate over columns</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">dispatch_to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">_arith_op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">res_values</span> <span class="o">=</span> <span class="n">_arith_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">dispatch_fill_zeros</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">res_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_data</span>

    <span class="k">def</span> <span class="nf">_combine_match_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="c1"># at this point we have `self.index.equals(other.index)`</span>

        <span class="k">if</span> <span class="n">ops</span><span class="o">.</span><span class="n">should_series_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
            <span class="c1"># operate column-wise; avoid costly object-casting in `.values`</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">dispatch_to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># fastpath --&gt; operate directly on values</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="k">def</span> <span class="nf">_construct_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap the result of an arithmetic, comparison, or logical operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : DataFrame</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Pin columns instead of passing to constructor for compat with</span>
        <span class="c1">#  non-unique columns case</span>
        <span class="n">out</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform column-wise combine with another DataFrame.</span>

<span class="sd">        Combines a DataFrame with `other` DataFrame using `func`</span>
<span class="sd">        to element-wise combine columns. The row and column indexes of the</span>
<span class="sd">        resulting DataFrame will be the union of the two.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame</span>
<span class="sd">            The DataFrame to merge column-wise.</span>
<span class="sd">        func : function</span>
<span class="sd">            Function that takes two series as inputs and return a Series or a</span>
<span class="sd">            scalar. Used to merge the two dataframes column by columns.</span>
<span class="sd">        fill_value : scalar value, default None</span>
<span class="sd">            The value to fill NaNs with prior to passing any column to the</span>
<span class="sd">            merge func.</span>
<span class="sd">        overwrite : bool, default True</span>
<span class="sd">            If True, columns in `self` that do not exist in `other` will be</span>
<span class="sd">            overwritten with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Combination of the provided DataFrames.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.combine_first : Combine two DataFrame objects and default to</span>
<span class="sd">            non-null values in frame calling the method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Combine using a simple function that chooses the smaller column.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [4, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; take_smaller = lambda s1, s2: s1 if s1.sum() &lt; s2.sum() else s2</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  0  3</span>
<span class="sd">        1  0  3</span>

<span class="sd">        Example using a true element-wise combine function.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [5, 0], &#39;B&#39;: [2, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, np.minimum)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  0  3</span>

<span class="sd">        Using `fill_value` fills Nones prior to passing the column to the</span>
<span class="sd">        merge function.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [None, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller, fill_value=-5)</span>
<span class="sd">           A    B</span>
<span class="sd">        0  0 -5.0</span>
<span class="sd">        1  0  4.0</span>

<span class="sd">        However, if the same element in both dataframes is None, that None</span>
<span class="sd">        is preserved</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [None, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [None, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller, fill_value=-5)</span>
<span class="sd">            A    B</span>
<span class="sd">        0  0 -5.0</span>
<span class="sd">        1  0  3.0</span>

<span class="sd">        Example that demonstrates the use of `overwrite` and behavior when</span>
<span class="sd">        the axis differ between the dataframes.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [4, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;B&#39;: [3, 3], &#39;C&#39;: [-10, 1], }, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller)</span>
<span class="sd">             A    B     C</span>
<span class="sd">        0  NaN  NaN   NaN</span>
<span class="sd">        1  NaN  3.0 -10.0</span>
<span class="sd">        2  NaN  3.0   1.0</span>

<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller, overwrite=False)</span>
<span class="sd">             A    B     C</span>
<span class="sd">        0  0.0  NaN   NaN</span>
<span class="sd">        1  0.0  3.0 -10.0</span>
<span class="sd">        2  NaN  3.0   1.0</span>

<span class="sd">        Demonstrating the preference of the passed in dataframe.</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;B&#39;: [3, 3], &#39;C&#39;: [1, 1], }, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df2.combine(df1, take_smaller)</span>
<span class="sd">           A    B   C</span>
<span class="sd">        0  0.0  NaN NaN</span>
<span class="sd">        1  0.0  3.0 NaN</span>
<span class="sd">        2  NaN  3.0 NaN</span>

<span class="sd">        &gt;&gt;&gt; df2.combine(df1, take_smaller, overwrite=False)</span>
<span class="sd">             A    B   C</span>
<span class="sd">        0  0.0  NaN NaN</span>
<span class="sd">        1  0.0  3.0 1.0</span>
<span class="sd">        2  NaN  3.0 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_idxlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># save for compare</span>

        <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">other_idxlen</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># sorts if possible</span>
        <span class="n">new_columns</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">do_fill</span> <span class="o">=</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">new_columns</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="n">this</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="n">otherSeries</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

            <span class="n">this_dtype</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">other_dtype</span> <span class="o">=</span> <span class="n">otherSeries</span><span class="o">.</span><span class="n">dtype</span>

            <span class="n">this_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
            <span class="n">other_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">otherSeries</span><span class="p">)</span>

            <span class="c1"># don&#39;t overwrite columns unnecessarily</span>
            <span class="c1"># DO propagate if this column is not in the intersection</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">other_mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">this</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">do_fill</span><span class="p">:</span>
                <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">otherSeries</span> <span class="o">=</span> <span class="n">otherSeries</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">series</span><span class="p">[</span><span class="n">this_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="n">otherSeries</span><span class="p">[</span><span class="n">other_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># If self DataFrame does not have col in other DataFrame,</span>
                <span class="c1"># try to promote series, which is all NaN, as other_dtype.</span>
                <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">other_dtype</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># e.g. new_dtype is integer types</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if we have different dtypes, possibly promote</span>
                <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">([</span><span class="n">this_dtype</span><span class="p">,</span> <span class="n">other_dtype</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">this_dtype</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">):</span>
                    <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">other_dtype</span><span class="p">,</span> <span class="n">new_dtype</span><span class="p">):</span>
                    <span class="n">otherSeries</span> <span class="o">=</span> <span class="n">otherSeries</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">)</span>

            <span class="n">arr</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">otherSeries</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">maybe_downcast_to_dtype</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">this_dtype</span><span class="p">)</span>

            <span class="n">result</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>

        <span class="c1"># convert_objects just in case</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update null elements with value in the same location in `other`.</span>

<span class="sd">        Combine two DataFrame objects by filling null values in one DataFrame</span>
<span class="sd">        with non-null values from other DataFrame. The row and column indexes</span>
<span class="sd">        of the resulting DataFrame will be the union of the two.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame</span>
<span class="sd">            Provided DataFrame to use to fill null values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.combine : Perform series-wise operation on two DataFrames</span>
<span class="sd">            using a given function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [None, 0], &#39;B&#39;: [None, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine_first(df2)</span>
<span class="sd">             A    B</span>
<span class="sd">        0  1.0  3.0</span>
<span class="sd">        1  0.0  4.0</span>

<span class="sd">        Null values still persist if the location of that null value</span>
<span class="sd">        does not exist in `other`</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [None, 0], &#39;B&#39;: [4, None]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;B&#39;: [3, 3], &#39;C&#39;: [1, 1]}, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df1.combine_first(df2)</span>
<span class="sd">             A    B    C</span>
<span class="sd">        0  NaN  4.0  NaN</span>
<span class="sd">        1  0.0  3.0  1.0</span>
<span class="sd">        2  NaN  3.0  1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="k">def</span> <span class="nf">extract_values</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="c1"># Does two things:</span>
            <span class="c1"># 1. maybe gets the values from the Series / Index</span>
            <span class="c1"># 2. convert datelike to i8</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCIndexClass</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">_values</span>

            <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">asi8</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arr</span>

        <span class="k">def</span> <span class="nf">combiner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">ABCIndexClass</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">_values</span>

            <span class="n">x_values</span> <span class="o">=</span> <span class="n">extract_values</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y_values</span> <span class="o">=</span> <span class="n">extract_values</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

            <span class="c1"># If the column y in other DataFrame is not in first DataFrame,</span>
            <span class="c1"># just return y_values.</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y_values</span>

            <span class="k">return</span> <span class="n">expressions</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">x_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">combiner</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filter_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify in place using non-NA values from another DataFrame.</span>

<span class="sd">        Aligns on indices. There is no return value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame, or object coercible into a DataFrame</span>
<span class="sd">            Should have at least one matching index/column label</span>
<span class="sd">            with the original DataFrame. If a Series is passed,</span>
<span class="sd">            its name attribute must be set, and that will be</span>
<span class="sd">            used as the column name to align with the original DataFrame.</span>
<span class="sd">        join : {&#39;left&#39;}, default &#39;left&#39;</span>
<span class="sd">            Only left join is implemented, keeping the index and columns of the</span>
<span class="sd">            original object.</span>
<span class="sd">        overwrite : bool, default True</span>
<span class="sd">            How to handle non-NA values for overlapping keys:</span>

<span class="sd">            * True: overwrite original DataFrame&#39;s values</span>
<span class="sd">              with values from `other`.</span>
<span class="sd">            * False: only update values that are NA in</span>
<span class="sd">              the original DataFrame.</span>

<span class="sd">        filter_func : callable(1d-array) -&gt; bool 1d-array, optional</span>
<span class="sd">            Can choose to replace values other than NA. Return True for values</span>
<span class="sd">            that should be updated.</span>
<span class="sd">        errors : {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;ignore&#39;</span>
<span class="sd">            If &#39;raise&#39;, will raise a ValueError if the DataFrame and `other`</span>
<span class="sd">            both contain non-NA data in the same place.</span>

<span class="sd">            .. versionchanged:: 0.24.0</span>
<span class="sd">               Changed from `raise_conflict=False|True`</span>
<span class="sd">               to `errors=&#39;ignore&#39;|&#39;raise&#39;`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None : method directly changes calling object</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * When `errors=&#39;raise&#39;` and there&#39;s overlapping non-NA data.</span>
<span class="sd">            * When `errors` is not either `&#39;ignore&#39;` or `&#39;raise&#39;`</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            * If `join != &#39;left&#39;`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dict.update : Similar method for dictionaries.</span>
<span class="sd">        DataFrame.merge : For column(s)-on-columns(s) operations.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3],</span>
<span class="sd">        ...                    &#39;B&#39;: [400, 500, 600]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [4, 5, 6],</span>
<span class="sd">        ...                        &#39;C&#39;: [7, 8, 9]})</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        The DataFrame&#39;s length does not increase as a result of the update,</span>
<span class="sd">        only values at matching index/column labels are updated.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  a  d</span>
<span class="sd">        1  b  e</span>
<span class="sd">        2  c  f</span>

<span class="sd">        For Series, it&#39;s name attribute must be set.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; new_column = pd.Series([&#39;d&#39;, &#39;e&#39;], name=&#39;B&#39;, index=[0, 2])</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_column)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  a  d</span>
<span class="sd">        1  b  y</span>
<span class="sd">        2  c  e</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [&#39;d&#39;, &#39;e&#39;]}, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  a  x</span>
<span class="sd">        1  b  d</span>
<span class="sd">        2  c  e</span>

<span class="sd">        If `other` contains NaNs the corresponding values are not updated</span>
<span class="sd">        in the original dataframe.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3],</span>
<span class="sd">        ...                    &#39;B&#39;: [400, 500, 600]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [4, np.nan, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A      B</span>
<span class="sd">        0  1    4.0</span>
<span class="sd">        1  2  500.0</span>
<span class="sd">        2  3    6.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">pandas.core.computation.expressions</span> <span class="k">as</span> <span class="nn">expressions</span>

        <span class="c1"># TODO: Support other joins</span>
        <span class="k">if</span> <span class="n">join</span> <span class="o">!=</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only left join is supported&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="s2">&quot;raise&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parameter errors must be either &#39;ignore&#39; or &#39;raise&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">_values</span>
            <span class="n">that</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">_values</span>
            <span class="k">if</span> <span class="n">filter_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">filter_func</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                    <span class="n">mask_this</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
                    <span class="n">mask_that</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask_this</span> <span class="o">&amp;</span> <span class="n">mask_that</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data overlaps.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>

            <span class="c1"># don&#39;t overwrite columns unnecessarily</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Data reshaping</span>
    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame({&#39;Animal&#39;: [&#39;Falcon&#39;, &#39;Falcon&#39;,</span>
<span class="sd">...                               &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">...                    &#39;Max Speed&#39;: [380., 370., 24., 26.]})</span>
<span class="sd">&gt;&gt;&gt; df</span>
<span class="sd">   Animal  Max Speed</span>
<span class="sd">0  Falcon      380.0</span>
<span class="sd">1  Falcon      370.0</span>
<span class="sd">2  Parrot       24.0</span>
<span class="sd">3  Parrot       26.0</span>
<span class="sd">&gt;&gt;&gt; df.groupby([&#39;Animal&#39;]).mean()</span>
<span class="sd">        Max Speed</span>
<span class="sd">Animal</span>
<span class="sd">Falcon      375.0</span>
<span class="sd">Parrot       25.0</span>

<span class="sd">**Hierarchical Indexes**</span>

<span class="sd">We can groupby different levels of a hierarchical index</span>
<span class="sd">using the `level` parameter:</span>

<span class="sd">&gt;&gt;&gt; arrays = [[&#39;Falcon&#39;, &#39;Falcon&#39;, &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">...           [&#39;Captive&#39;, &#39;Wild&#39;, &#39;Captive&#39;, &#39;Wild&#39;]]</span>
<span class="sd">&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(arrays, names=(&#39;Animal&#39;, &#39;Type&#39;))</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame({&#39;Max Speed&#39;: [390., 350., 30., 20.]},</span>
<span class="sd">...                   index=index)</span>
<span class="sd">&gt;&gt;&gt; df</span>
<span class="sd">                Max Speed</span>
<span class="sd">Animal Type</span>
<span class="sd">Falcon Captive      390.0</span>
<span class="sd">       Wild         350.0</span>
<span class="sd">Parrot Captive       30.0</span>
<span class="sd">       Wild          20.0</span>
<span class="sd">&gt;&gt;&gt; df.groupby(level=0).mean()</span>
<span class="sd">        Max Speed</span>
<span class="sd">Animal</span>
<span class="sd">Falcon      370.0</span>
<span class="sd">Parrot       25.0</span>
<span class="sd">&gt;&gt;&gt; df.groupby(level=&quot;Type&quot;).mean()</span>
<span class="sd">         Max Speed</span>
<span class="sd">Type</span>
<span class="sd">Captive      210.0</span>
<span class="sd">Wild         185.0</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;groupby&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">as_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">group_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">squeeze</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">observed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;groupby_generic.DataFrameGroupBy&quot;</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have to supply one of &#39;by&#39; and &#39;level&#39;&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">groupby_generic</span><span class="o">.</span><span class="n">DataFrameGroupBy</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">keys</span><span class="o">=</span><span class="n">by</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">as_index</span><span class="o">=</span><span class="n">as_index</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span>
            <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;pivot&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return reshaped DataFrame organized by given index / column values.</span>

<span class="s2">        Reshape data (produce a &quot;pivot&quot; table) based on column values. Uses</span>
<span class="s2">        unique values from specified `index` / `columns` to form axes of the</span>
<span class="s2">        resulting DataFrame. This function does not support data</span>
<span class="s2">        aggregation, multiple values will result in a MultiIndex in the</span>
<span class="s2">        columns. See the :ref:`User Guide &lt;reshaping&gt;` for more on reshaping.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span><span class="si">%s</span><span class="s2"></span>
<span class="s2">        index : str or object, optional</span>
<span class="s2">            Column to use to make new frame&#39;s index. If None, uses</span>
<span class="s2">            existing index.</span>
<span class="s2">        columns : str or object</span>
<span class="s2">            Column to use to make new frame&#39;s columns.</span>
<span class="s2">        values : str, object or a list of the previous, optional</span>
<span class="s2">            Column(s) to use for populating new frame&#39;s values. If not</span>
<span class="s2">            specified, all remaining columns will be used and the result will</span>
<span class="s2">            have hierarchically indexed columns.</span>

<span class="s2">            .. versionchanged:: 0.23.0</span>
<span class="s2">               Also accept list of column names.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        DataFrame</span>
<span class="s2">            Returns reshaped DataFrame.</span>

<span class="s2">        Raises</span>
<span class="s2">        ------</span>
<span class="s2">        ValueError:</span>
<span class="s2">            When there are any `index`, `columns` combinations with multiple</span>
<span class="s2">            values. `DataFrame.pivot_table` when you need to aggregate.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.pivot_table : Generalization of pivot that can handle</span>
<span class="s2">            duplicate values for one index/column pair.</span>
<span class="s2">        DataFrame.unstack : Pivot based on the index values instead of a</span>
<span class="s2">            column.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        For finer-tuned control, see hierarchical indexing documentation along</span>
<span class="s2">        with the related stack/unstack methods.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;foo&#39;: [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;two&#39;,</span>
<span class="s2">        ...                            &#39;two&#39;],</span>
<span class="s2">        ...                    &#39;bar&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                    &#39;baz&#39;: [1, 2, 3, 4, 5, 6],</span>
<span class="s2">        ...                    &#39;zoo&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;q&#39;, &#39;w&#39;, &#39;t&#39;]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">            foo   bar  baz  zoo</span>
<span class="s2">        0   one   A    1    x</span>
<span class="s2">        1   one   B    2    y</span>
<span class="s2">        2   one   C    3    z</span>
<span class="s2">        3   two   A    4    q</span>
<span class="s2">        4   two   B    5    w</span>
<span class="s2">        5   two   C    6    t</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;, values=&#39;baz&#39;)</span>
<span class="s2">        bar  A   B   C</span>
<span class="s2">        foo</span>
<span class="s2">        one  1   2   3</span>
<span class="s2">        two  4   5   6</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;)[&#39;baz&#39;]</span>
<span class="s2">        bar  A   B   C</span>
<span class="s2">        foo</span>
<span class="s2">        one  1   2   3</span>
<span class="s2">        two  4   5   6</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;, values=[&#39;baz&#39;, &#39;zoo&#39;])</span>
<span class="s2">              baz       zoo</span>
<span class="s2">        bar   A  B  C   A  B  C</span>
<span class="s2">        foo</span>
<span class="s2">        one   1  2  3   x  y  z</span>
<span class="s2">        two   4  5  6   q  w  t</span>

<span class="s2">        A ValueError is raised if there are any duplicates.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&quot;foo&quot;: [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;two&#39;],</span>
<span class="s2">        ...                    &quot;bar&quot;: [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                    &quot;baz&quot;: [1, 2, 3, 4]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">           foo bar  baz</span>
<span class="s2">        0  one   A    1</span>
<span class="s2">        1  one   A    2</span>
<span class="s2">        2  two   B    3</span>
<span class="s2">        3  two   C    4</span>

<span class="s2">        Notice that the first two rows are the same for our `index`</span>
<span class="s2">        and `columns` arguments.</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;, values=&#39;baz&#39;)</span>
<span class="s2">        Traceback (most recent call last):</span>
<span class="s2">           ...</span>
<span class="s2">        ValueError: Index contains duplicate entries, cannot reshape</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;pivot&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pivot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.pivot</span> <span class="kn">import</span> <span class="n">pivot</span>

        <span class="k">return</span> <span class="n">pivot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;pivot_table&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Create a spreadsheet-style pivot table as a DataFrame.</span>

<span class="s2">        The levels in the pivot table will be stored in MultiIndex objects</span>
<span class="s2">        (hierarchical indexes) on the index and columns of the result DataFrame.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span><span class="si">%s</span><span class="s2"></span>
<span class="s2">        values : column to aggregate, optional</span>
<span class="s2">        index : column, Grouper, array, or list of the previous</span>
<span class="s2">            If an array is passed, it must be the same length as the data. The</span>
<span class="s2">            list can contain any of the other types (except list).</span>
<span class="s2">            Keys to group by on the pivot table index.  If an array is passed,</span>
<span class="s2">            it is being used as the same manner as column values.</span>
<span class="s2">        columns : column, Grouper, array, or list of the previous</span>
<span class="s2">            If an array is passed, it must be the same length as the data. The</span>
<span class="s2">            list can contain any of the other types (except list).</span>
<span class="s2">            Keys to group by on the pivot table column.  If an array is passed,</span>
<span class="s2">            it is being used as the same manner as column values.</span>
<span class="s2">        aggfunc : function, list of functions, dict, default numpy.mean</span>
<span class="s2">            If list of functions passed, the resulting pivot table will have</span>
<span class="s2">            hierarchical columns whose top level are the function names</span>
<span class="s2">            (inferred from the function objects themselves)</span>
<span class="s2">            If dict is passed, the key is column to aggregate and value</span>
<span class="s2">            is function or list of functions.</span>
<span class="s2">        fill_value : scalar, default None</span>
<span class="s2">            Value to replace missing values with.</span>
<span class="s2">        margins : bool, default False</span>
<span class="s2">            Add all row / columns (e.g. for subtotal / grand totals).</span>
<span class="s2">        dropna : bool, default True</span>
<span class="s2">            Do not include columns whose entries are all NaN.</span>
<span class="s2">        margins_name : str, default &#39;All&#39;</span>
<span class="s2">            Name of the row / column that will contain the totals</span>
<span class="s2">            when margins is True.</span>
<span class="s2">        observed : bool, default False</span>
<span class="s2">            This only applies if any of the groupers are Categoricals.</span>
<span class="s2">            If True: only show observed values for categorical groupers.</span>
<span class="s2">            If False: show all values for categorical groupers.</span>

<span class="s2">            .. versionchanged:: 0.25.0</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        DataFrame</span>
<span class="s2">            An Excel style pivot table.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.pivot : Pivot without aggregation that can handle</span>
<span class="s2">            non-numeric data.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;,</span>
<span class="s2">        ...                          &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;],</span>
<span class="s2">        ...                    &quot;B&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;,</span>
<span class="s2">        ...                          &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;],</span>
<span class="s2">        ...                    &quot;C&quot;: [&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;,</span>
<span class="s2">        ...                          &quot;small&quot;, &quot;large&quot;, &quot;small&quot;, &quot;small&quot;,</span>
<span class="s2">        ...                          &quot;large&quot;],</span>
<span class="s2">        ...                    &quot;D&quot;: [1, 2, 2, 3, 3, 4, 5, 6, 7],</span>
<span class="s2">        ...                    &quot;E&quot;: [2, 4, 5, 5, 6, 6, 8, 9, 9]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">             A    B      C  D  E</span>
<span class="s2">        0  foo  one  small  1  2</span>
<span class="s2">        1  foo  one  large  2  4</span>
<span class="s2">        2  foo  one  large  2  5</span>
<span class="s2">        3  foo  two  small  3  5</span>
<span class="s2">        4  foo  two  small  3  6</span>
<span class="s2">        5  bar  one  large  4  6</span>
<span class="s2">        6  bar  one  small  5  8</span>
<span class="s2">        7  bar  two  small  6  9</span>
<span class="s2">        8  bar  two  large  7  9</span>

<span class="s2">        This first example aggregates values by taking the sum.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=&#39;D&#39;, index=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="s2">        ...                     columns=[&#39;C&#39;], aggfunc=np.sum)</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">        C        large  small</span>
<span class="s2">        A   B</span>
<span class="s2">        bar one    4.0    5.0</span>
<span class="s2">            two    7.0    6.0</span>
<span class="s2">        foo one    4.0    1.0</span>
<span class="s2">            two    NaN    6.0</span>

<span class="s2">        We can also fill missing values using the `fill_value` parameter.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=&#39;D&#39;, index=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="s2">        ...                     columns=[&#39;C&#39;], aggfunc=np.sum, fill_value=0)</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">        C        large  small</span>
<span class="s2">        A   B</span>
<span class="s2">        bar one      4      5</span>
<span class="s2">            two      7      6</span>
<span class="s2">        foo one      4      1</span>
<span class="s2">            two      0      6</span>

<span class="s2">        The next example aggregates by taking the mean across multiple columns.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=[&#39;D&#39;, &#39;E&#39;], index=[&#39;A&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                     aggfunc={&#39;D&#39;: np.mean,</span>
<span class="s2">        ...                              &#39;E&#39;: np.mean})</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">                        D         E</span>
<span class="s2">        A   C</span>
<span class="s2">        bar large  5.500000  7.500000</span>
<span class="s2">            small  5.500000  8.500000</span>
<span class="s2">        foo large  2.000000  4.500000</span>
<span class="s2">            small  2.333333  4.333333</span>

<span class="s2">        We can also calculate multiple types of aggregations for any given</span>
<span class="s2">        value column.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=[&#39;D&#39;, &#39;E&#39;], index=[&#39;A&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                     aggfunc={&#39;D&#39;: np.mean,</span>
<span class="s2">        ...                              &#39;E&#39;: [min, max, np.mean]})</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">                        D    E</span>
<span class="s2">                    mean  max      mean  min</span>
<span class="s2">        A   C</span>
<span class="s2">        bar large  5.500000  9.0  7.500000  6.0</span>
<span class="s2">            small  5.500000  9.0  8.500000  8.0</span>
<span class="s2">        foo large  2.000000  5.0  4.500000  4.0</span>
<span class="s2">            small  2.333333  6.0  4.333333  2.0</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;pivot_table&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pivot_table</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aggfunc</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">margins</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dropna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">margins_name</span><span class="o">=</span><span class="s2">&quot;All&quot;</span><span class="p">,</span>
        <span class="n">observed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.pivot</span> <span class="kn">import</span> <span class="n">pivot_table</span>

        <span class="k">return</span> <span class="n">pivot_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">margins</span><span class="o">=</span><span class="n">margins</span><span class="p">,</span>
            <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">,</span>
            <span class="n">margins_name</span><span class="o">=</span><span class="n">margins_name</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack the prescribed level(s) from columns to index.</span>

<span class="sd">        Return a reshaped DataFrame or Series having a multi-level</span>
<span class="sd">        index with one or more new inner-most levels compared to the current</span>
<span class="sd">        DataFrame. The new inner-most levels are created by pivoting the</span>
<span class="sd">        columns of the current dataframe:</span>

<span class="sd">          - if the columns have a single level, the output is a Series;</span>
<span class="sd">          - if the columns have multiple levels, the new index</span>
<span class="sd">            level(s) is (are) taken from the prescribed level(s) and</span>
<span class="sd">            the output is a DataFrame.</span>

<span class="sd">        The new index levels are sorted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, list, default -1</span>
<span class="sd">            Level(s) to stack from the column axis onto the index</span>
<span class="sd">            axis, defined as one index or label, or a list of indices</span>
<span class="sd">            or labels.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Whether to drop rows in the resulting Frame/Series with</span>
<span class="sd">            missing values. Stacking a column level onto the index</span>
<span class="sd">            axis can create combinations of index and column values</span>
<span class="sd">            that are missing from the original dataframe. See Examples</span>
<span class="sd">            section.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or Series</span>
<span class="sd">            Stacked dataframe or series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.unstack : Unstack prescribed level(s) from index axis</span>
<span class="sd">             onto column axis.</span>
<span class="sd">        DataFrame.pivot : Reshape dataframe from long format to wide</span>
<span class="sd">             format.</span>
<span class="sd">        DataFrame.pivot_table : Create a spreadsheet-style pivot table</span>
<span class="sd">             as a DataFrame.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function is named by analogy with a collection of books</span>
<span class="sd">        being reorganized from being side by side on a horizontal</span>
<span class="sd">        position (the columns of the dataframe) to being stacked</span>
<span class="sd">        vertically on top of each other (in the index of the</span>
<span class="sd">        dataframe).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Single level columns**</span>

<span class="sd">        &gt;&gt;&gt; df_single_level_cols = pd.DataFrame([[0, 1], [2, 3]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=[&#39;weight&#39;, &#39;height&#39;])</span>

<span class="sd">        Stacking a dataframe with a single level column axis returns a Series:</span>

<span class="sd">        &gt;&gt;&gt; df_single_level_cols</span>
<span class="sd">             weight height</span>
<span class="sd">        cat       0      1</span>
<span class="sd">        dog       2      3</span>
<span class="sd">        &gt;&gt;&gt; df_single_level_cols.stack()</span>
<span class="sd">        cat  weight    0</span>
<span class="sd">             height    1</span>
<span class="sd">        dog  weight    2</span>
<span class="sd">             height    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        **Multi level columns: simple case**</span>

<span class="sd">        &gt;&gt;&gt; multicol1 = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;),</span>
<span class="sd">        ...                                        (&#39;weight&#39;, &#39;pounds&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols1 = pd.DataFrame([[1, 2], [2, 4]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=multicol1)</span>

<span class="sd">        Stacking a dataframe with a multi-level column axis:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols1</span>
<span class="sd">             weight</span>
<span class="sd">                 kg    pounds</span>
<span class="sd">        cat       1        2</span>
<span class="sd">        dog       2        4</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols1.stack()</span>
<span class="sd">                    weight</span>
<span class="sd">        cat kg           1</span>
<span class="sd">            pounds       2</span>
<span class="sd">        dog kg           2</span>
<span class="sd">            pounds       4</span>

<span class="sd">        **Missing values**</span>

<span class="sd">        &gt;&gt;&gt; multicol2 = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;),</span>
<span class="sd">        ...                                        (&#39;height&#39;, &#39;m&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2 = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=multicol2)</span>

<span class="sd">        It is common to have missing values when stacking a dataframe</span>
<span class="sd">        with multi-level columns, as the stacked dataframe typically</span>
<span class="sd">        has more values than the original dataframe. Missing values</span>
<span class="sd">        are filled with NaNs:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2</span>
<span class="sd">            weight height</span>
<span class="sd">                kg      m</span>
<span class="sd">        cat    1.0    2.0</span>
<span class="sd">        dog    3.0    4.0</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2.stack()</span>
<span class="sd">                height  weight</span>
<span class="sd">        cat kg     NaN     1.0</span>
<span class="sd">            m      2.0     NaN</span>
<span class="sd">        dog kg     NaN     3.0</span>
<span class="sd">            m      4.0     NaN</span>

<span class="sd">        **Prescribing the level(s) to be stacked**</span>

<span class="sd">        The first parameter controls which level or levels are stacked:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2.stack(0)</span>
<span class="sd">                     kg    m</span>
<span class="sd">        cat height  NaN  2.0</span>
<span class="sd">            weight  1.0  NaN</span>
<span class="sd">        dog height  NaN  4.0</span>
<span class="sd">            weight  3.0  NaN</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2.stack([0, 1])</span>
<span class="sd">        cat  height  m     2.0</span>
<span class="sd">             weight  kg    1.0</span>
<span class="sd">        dog  height  m     4.0</span>
<span class="sd">             weight  kg    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        **Dropping missing values**</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3 = pd.DataFrame([[None, 1.0], [2.0, 3.0]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=multicol2)</span>

<span class="sd">        Note that rows where all values are missing are dropped by</span>
<span class="sd">        default but this behaviour can be controlled via the dropna</span>
<span class="sd">        keyword parameter:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3</span>
<span class="sd">            weight height</span>
<span class="sd">                kg      m</span>
<span class="sd">        cat    NaN    1.0</span>
<span class="sd">        dog    2.0    3.0</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3.stack(dropna=False)</span>
<span class="sd">                height  weight</span>
<span class="sd">        cat kg     NaN     NaN</span>
<span class="sd">            m      1.0     NaN</span>
<span class="sd">        dog kg     NaN     2.0</span>
<span class="sd">            m      3.0     NaN</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3.stack(dropna=True)</span>
<span class="sd">                height  weight</span>
<span class="sd">        cat m      1.0     NaN</span>
<span class="sd">        dog kg     NaN     2.0</span>
<span class="sd">            m      3.0     NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.reshape</span> <span class="kn">import</span> <span class="n">stack</span><span class="p">,</span> <span class="n">stack_multiple</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">stack_multiple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">explode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each element of a list-like to a row, replicating index values.</span>

<span class="sd">        .. versionadded:: 0.25.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column : str or tuple</span>
<span class="sd">            Column to explode.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Exploded lists to rows of the subset columns;</span>
<span class="sd">            index will be duplicated for these rows.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError :</span>
<span class="sd">            if columns of the frame are not unique.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.unstack : Pivot a level of the (necessarily hierarchical)</span>
<span class="sd">            index labels.</span>
<span class="sd">        DataFrame.melt : Unpivot a DataFrame from wide format to long format.</span>
<span class="sd">        Series.explode : Explode a DataFrame from list-like columns to long format.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine will explode list-likes including lists, tuples,</span>
<span class="sd">        Series, and np.ndarray. The result dtype of the subset rows will</span>
<span class="sd">        be object. Scalars will be returned unchanged. Empty list-likes will</span>
<span class="sd">        result in a np.nan for that row.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [[1, 2, 3], &#39;foo&#39;, [], [3, 4]], &#39;B&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                   A  B</span>
<span class="sd">        0  [1, 2, 3]  1</span>
<span class="sd">        1        foo  1</span>
<span class="sd">        2         []  1</span>
<span class="sd">        3     [3, 4]  1</span>

<span class="sd">        &gt;&gt;&gt; df.explode(&#39;A&#39;)</span>
<span class="sd">             A  B</span>
<span class="sd">        0    1  1</span>
<span class="sd">        0    2  1</span>
<span class="sd">        0    3  1</span>
<span class="sd">        1  foo  1</span>
<span class="sd">        2  NaN  1</span>
<span class="sd">        3    3  1</span>
<span class="sd">        3    4  1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;column must be a scalar&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;columns must be unique&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># TODO: use overload to refine return type of reset_index</span>
        <span class="k">assert</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># needed for mypy</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">column</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pivot a level of the (necessarily hierarchical) index labels.</span>

<span class="sd">        Returns a DataFrame having a new level of column labels whose inner-most level</span>
<span class="sd">        consists of the pivoted index labels.</span>

<span class="sd">        If the index is not a MultiIndex, the output will be a Series</span>
<span class="sd">        (the analogue of stack when the columns are not a MultiIndex).</span>

<span class="sd">        The level involved will automatically get sorted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, or list of these, default -1 (last level)</span>
<span class="sd">            Level(s) of index to unstack, can pass level name.</span>
<span class="sd">        fill_value : int, str or dict</span>
<span class="sd">            Replace NaN with this value if the unstack produces missing values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.pivot : Pivot a table based on column values.</span>
<span class="sd">        DataFrame.stack : Pivot a level of the column labels (inverse operation</span>
<span class="sd">            from `unstack`).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.MultiIndex.from_tuples([(&#39;one&#39;, &#39;a&#39;), (&#39;one&#39;, &#39;b&#39;),</span>
<span class="sd">        ...                                    (&#39;two&#39;, &#39;a&#39;), (&#39;two&#39;, &#39;b&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.arange(1.0, 5.0), index=index)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        one  a   1.0</span>
<span class="sd">             b   2.0</span>
<span class="sd">        two  a   3.0</span>
<span class="sd">             b   4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=-1)</span>
<span class="sd">             a   b</span>
<span class="sd">        one  1.0  2.0</span>
<span class="sd">        two  3.0  4.0</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=0)</span>
<span class="sd">           one  two</span>
<span class="sd">        a  1.0   3.0</span>
<span class="sd">        b  2.0   4.0</span>

<span class="sd">        &gt;&gt;&gt; df = s.unstack(level=0)</span>
<span class="sd">        &gt;&gt;&gt; df.unstack()</span>
<span class="sd">        one  a  1.0</span>
<span class="sd">             b  2.0</span>
<span class="sd">        two  a  3.0</span>
<span class="sd">             b  4.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.reshape</span> <span class="kn">import</span> <span class="n">unstack</span>

        <span class="k">return</span> <span class="n">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;melt&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Unpivot a DataFrame from wide to long format, optionally leaving identifiers set.</span>

<span class="s2">    This function is useful to massage a DataFrame into a format where one</span>
<span class="s2">    or more columns are identifier variables (`id_vars`), while all other</span>
<span class="s2">    columns, considered measured variables (`value_vars`), are &quot;unpivoted&quot; to</span>
<span class="s2">    the row axis, leaving just two non-identifier columns, &#39;variable&#39; and</span>
<span class="s2">    &#39;value&#39;.</span>
<span class="s2">    </span><span class="si">%(versionadded)s</span><span class="s2"></span>
<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    id_vars : tuple, list, or ndarray, optional</span>
<span class="s2">        Column(s) to use as identifier variables.</span>
<span class="s2">    value_vars : tuple, list, or ndarray, optional</span>
<span class="s2">        Column(s) to unpivot. If not specified, uses all columns that</span>
<span class="s2">        are not set as `id_vars`.</span>
<span class="s2">    var_name : scalar</span>
<span class="s2">        Name to use for the &#39;variable&#39; column. If None it uses</span>
<span class="s2">        ``frame.columns.name`` or &#39;variable&#39;.</span>
<span class="s2">    value_name : scalar, default &#39;value&#39;</span>
<span class="s2">        Name to use for the &#39;value&#39; column.</span>
<span class="s2">    col_level : int or str, optional</span>
<span class="s2">        If columns are a MultiIndex then use this level to melt.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    DataFrame</span>
<span class="s2">        Unpivoted DataFrame.</span>

<span class="s2">    See Also</span>
<span class="s2">    --------</span>
<span class="s2">    </span><span class="si">%(other)s</span><span class="s2"></span>
<span class="s2">    pivot_table</span>
<span class="s2">    DataFrame.pivot</span>
<span class="s2">    Series.explode</span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: {0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;},</span>
<span class="s2">    ...                    &#39;B&#39;: {0: 1, 1: 3, 2: 5},</span>
<span class="s2">    ...                    &#39;C&#39;: {0: 2, 1: 4, 2: 6}})</span>
<span class="s2">    &gt;&gt;&gt; df</span>
<span class="s2">       A  B  C</span>
<span class="s2">    0  a  1  2</span>
<span class="s2">    1  b  3  4</span>
<span class="s2">    2  c  5  6</span>

<span class="s2">    &gt;&gt;&gt; </span><span class="si">%(caller)s</span><span class="s2">id_vars=[&#39;A&#39;], value_vars=[&#39;B&#39;])</span>
<span class="s2">       A variable  value</span>
<span class="s2">    0  a        B      1</span>
<span class="s2">    1  b        B      3</span>
<span class="s2">    2  c        B      5</span>

<span class="s2">    &gt;&gt;&gt; </span><span class="si">%(caller)s</span><span class="s2">id_vars=[&#39;A&#39;], value_vars=[&#39;B&#39;, &#39;C&#39;])</span>
<span class="s2">       A variable  value</span>
<span class="s2">    0  a        B      1</span>
<span class="s2">    1  b        B      3</span>
<span class="s2">    2  c        B      5</span>
<span class="s2">    3  a        C      2</span>
<span class="s2">    4  b        C      4</span>
<span class="s2">    5  c        C      6</span>

<span class="s2">    The names of &#39;variable&#39; and &#39;value&#39; columns can be customized:</span>

<span class="s2">    &gt;&gt;&gt; </span><span class="si">%(caller)s</span><span class="s2">id_vars=[&#39;A&#39;], value_vars=[&#39;B&#39;],</span>
<span class="s2">    ...         var_name=&#39;myVarname&#39;, value_name=&#39;myValname&#39;)</span>
<span class="s2">       A myVarname  myValname</span>
<span class="s2">    0  a         B          1</span>
<span class="s2">    1  b         B          3</span>
<span class="s2">    2  c         B          5</span>

<span class="s2">    If you have multi-index columns:</span>

<span class="s2">    &gt;&gt;&gt; df.columns = [list(&#39;ABC&#39;), list(&#39;DEF&#39;)]</span>
<span class="s2">    &gt;&gt;&gt; df</span>
<span class="s2">       A  B  C</span>
<span class="s2">       D  E  F</span>
<span class="s2">    0  a  1  2</span>
<span class="s2">    1  b  3  4</span>
<span class="s2">    2  c  5  6</span>

<span class="s2">    &gt;&gt;&gt; </span><span class="si">%(caller)s</span><span class="s2">col_level=0, id_vars=[&#39;A&#39;], value_vars=[&#39;B&#39;])</span>
<span class="s2">       A variable  value</span>
<span class="s2">    0  a        B      1</span>
<span class="s2">    1  b        B      3</span>
<span class="s2">    2  c        B      5</span>

<span class="s2">    &gt;&gt;&gt; </span><span class="si">%(caller)s</span><span class="s2">id_vars=[(&#39;A&#39;, &#39;D&#39;)], value_vars=[(&#39;B&#39;, &#39;E&#39;)])</span>
<span class="s2">      (A, D) variable_0 variable_1  value</span>
<span class="s2">    0      a          B          E      1</span>
<span class="s2">    1      b          B          E      3</span>
<span class="s2">    2      c          B          E      5</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;melt&quot;</span><span class="p">]</span>
        <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">caller</span><span class="o">=</span><span class="s2">&quot;df.melt(&quot;</span><span class="p">,</span> <span class="n">versionadded</span><span class="o">=</span><span class="s2">&quot;.. versionadded:: 0.20.0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="s2">&quot;melt&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">melt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">col_level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.melt</span> <span class="kn">import</span> <span class="n">melt</span>

        <span class="k">return</span> <span class="n">melt</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="n">id_vars</span><span class="p">,</span>
            <span class="n">value_vars</span><span class="o">=</span><span class="n">value_vars</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="n">value_name</span><span class="p">,</span>
            <span class="n">col_level</span><span class="o">=</span><span class="n">col_level</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Time series-related</span>

    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        First discrete difference of element.</span>

<span class="sd">        Calculates the difference of a DataFrame element compared with another</span>
<span class="sd">        element in the DataFrame (default is the element in the same column</span>
<span class="sd">        of the previous row).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int, default 1</span>
<span class="sd">            Periods to shift for calculating difference, accepts negative</span>
<span class="sd">            values.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Take difference over rows (0) or columns (1).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.diff: First discrete difference for a Series.</span>
<span class="sd">        DataFrame.pct_change: Percent change over given number of periods.</span>
<span class="sd">        DataFrame.shift: Shift index by desired number of periods with an</span>
<span class="sd">            optional time freq.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For boolean dtypes, this uses :meth:`operator.xor` rather than</span>
<span class="sd">        :meth:`operator.sub`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Difference with previous row</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [1, 2, 3, 4, 5, 6],</span>
<span class="sd">        ...                    &#39;b&#39;: [1, 1, 2, 3, 5, 8],</span>
<span class="sd">        ...                    &#39;c&#39;: [1, 4, 9, 16, 25, 36]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           a  b   c</span>
<span class="sd">        0  1  1   1</span>
<span class="sd">        1  2  1   4</span>
<span class="sd">        2  3  2   9</span>
<span class="sd">        3  4  3  16</span>
<span class="sd">        4  5  5  25</span>
<span class="sd">        5  6  8  36</span>

<span class="sd">        &gt;&gt;&gt; df.diff()</span>
<span class="sd">             a    b     c</span>
<span class="sd">        0  NaN  NaN   NaN</span>
<span class="sd">        1  1.0  0.0   3.0</span>
<span class="sd">        2  1.0  1.0   5.0</span>
<span class="sd">        3  1.0  1.0   7.0</span>
<span class="sd">        4  1.0  2.0   9.0</span>
<span class="sd">        5  1.0  3.0  11.0</span>

<span class="sd">        Difference with previous column</span>

<span class="sd">        &gt;&gt;&gt; df.diff(axis=1)</span>
<span class="sd">            a    b     c</span>
<span class="sd">        0 NaN  0.0   0.0</span>
<span class="sd">        1 NaN -1.0   3.0</span>
<span class="sd">        2 NaN -1.0   7.0</span>
<span class="sd">        3 NaN -1.0  13.0</span>
<span class="sd">        4 NaN  0.0  20.0</span>
<span class="sd">        5 NaN  2.0  28.0</span>

<span class="sd">        Difference with 3rd previous row</span>

<span class="sd">        &gt;&gt;&gt; df.diff(periods=3)</span>
<span class="sd">             a    b     c</span>
<span class="sd">        0  NaN  NaN   NaN</span>
<span class="sd">        1  NaN  NaN   NaN</span>
<span class="sd">        2  NaN  NaN   NaN</span>
<span class="sd">        3  3.0  2.0  15.0</span>
<span class="sd">        4  3.0  4.0  21.0</span>
<span class="sd">        5  3.0  6.0  27.0</span>

<span class="sd">        Difference with following row</span>

<span class="sd">        &gt;&gt;&gt; df.diff(periods=-1)</span>
<span class="sd">             a    b     c</span>
<span class="sd">        0 -1.0  0.0  -3.0</span>
<span class="sd">        1 -1.0 -1.0  -5.0</span>
<span class="sd">        2 -1.0 -1.0  -7.0</span>
<span class="sd">        3 -1.0 -2.0  -9.0</span>
<span class="sd">        4 -1.0 -3.0 -11.0</span>
<span class="sd">        5  NaN  NaN   NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bm_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">bm_axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Function application</span>

    <span class="k">def</span> <span class="nf">_gotitem</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">ndim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Series</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Series</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sub-classes to define. Return a sliced object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : string / list of selections</span>
<span class="sd">        ndim : 1,2</span>
<span class="sd">            requested ndim of result</span>
<span class="sd">        subset : object, default None</span>
<span class="sd">            subset to act on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">subset</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># is Series</span>
            <span class="k">return</span> <span class="n">subset</span>

        <span class="c1"># TODO: _shallow_copy(subset)?</span>
        <span class="k">return</span> <span class="n">subset</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">_agg_summary_and_see_also_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The aggregation operations are always performed over an axis, either the</span>
<span class="sd">    index (default) or the column axis. This behavior is different from</span>
<span class="sd">    `numpy` aggregation functions (`mean`, `median`, `prod`, `sum`, `std`,</span>
<span class="sd">    `var`), where the default is to compute the aggregation of the flattened</span>
<span class="sd">    array, e.g., ``numpy.mean(arr_2d)`` as opposed to</span>
<span class="sd">    ``numpy.mean(arr_2d, axis=0)``.</span>

<span class="sd">    `agg` is an alias for `aggregate`. Use the alias.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DataFrame.apply : Perform any type of operations.</span>
<span class="sd">    DataFrame.transform : Perform transformation type operations.</span>
<span class="sd">    core.groupby.GroupBy : Perform operations over groups.</span>
<span class="sd">    core.resample.Resampler : Perform operations over resampled bins.</span>
<span class="sd">    core.window.Rolling : Perform operations over rolling window.</span>
<span class="sd">    core.window.Expanding : Perform operations over expanding window.</span>
<span class="sd">    core.window.EWM : Perform operation over exponential weighted</span>
<span class="sd">        window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">_agg_examples_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3],</span>
<span class="sd">    ...                    [4, 5, 6],</span>
<span class="sd">    ...                    [7, 8, 9],</span>
<span class="sd">    ...                    [np.nan, np.nan, np.nan]],</span>
<span class="sd">    ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>

<span class="sd">    Aggregate these functions over the rows.</span>

<span class="sd">    &gt;&gt;&gt; df.agg([&#39;sum&#39;, &#39;min&#39;])</span>
<span class="sd">            A     B     C</span>
<span class="sd">    sum  12.0  15.0  18.0</span>
<span class="sd">    min   1.0   2.0   3.0</span>

<span class="sd">    Different aggregations per column.</span>

<span class="sd">    &gt;&gt;&gt; df.agg({&#39;A&#39; : [&#39;sum&#39;, &#39;min&#39;], &#39;B&#39; : [&#39;min&#39;, &#39;max&#39;]})</span>
<span class="sd">            A    B</span>
<span class="sd">    max   NaN  8.0</span>
<span class="sd">    min   1.0  2.0</span>
<span class="sd">    sum  12.0  NaN</span>

<span class="sd">    Aggregate over the columns.</span>

<span class="sd">    &gt;&gt;&gt; df.agg(&quot;mean&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">    0    2.0</span>
<span class="sd">    1    5.0</span>
<span class="sd">    2    8.0</span>
<span class="sd">    3    NaN</span>
<span class="sd">    dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">see_also</span><span class="o">=</span><span class="n">_agg_summary_and_see_also_doc</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">_agg_examples_doc</span><span class="p">,</span>
        <span class="n">versionadded</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">.. versionadded:: 0.20.0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;aggregate&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># NDFrame.aggregate returns a tuple, and we need to transpose</span>
            <span class="c1"># only result</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">how</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_aggregate</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">agg</span> <span class="o">=</span> <span class="n">aggregate</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">result_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function along an axis of the DataFrame.</span>

<span class="sd">        Objects passed to the function are Series objects whose index is</span>
<span class="sd">        either the DataFrame&#39;s index (``axis=0``) or the DataFrame&#39;s columns</span>
<span class="sd">        (``axis=1``). By default (``result_type=None``), the final return type</span>
<span class="sd">        is inferred from the return type of the applied function. Otherwise,</span>
<span class="sd">        it depends on the `result_type` argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function to apply to each column or row.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Axis along which the function is applied:</span>

<span class="sd">            * 0 or &#39;index&#39;: apply function to each column.</span>
<span class="sd">            * 1 or &#39;columns&#39;: apply function to each row.</span>

<span class="sd">        raw : bool, default False</span>
<span class="sd">            Determines if row or column is passed as a Series or ndarray object:</span>

<span class="sd">            * ``False`` : passes each row or column as a Series to the</span>
<span class="sd">              function.</span>
<span class="sd">            * ``True`` : the passed function will receive ndarray objects</span>
<span class="sd">              instead.</span>
<span class="sd">              If you are just applying a NumPy reduction function this will</span>
<span class="sd">              achieve much better performance.</span>

<span class="sd">        result_type : {&#39;expand&#39;, &#39;reduce&#39;, &#39;broadcast&#39;, None}, default None</span>
<span class="sd">            These only act when ``axis=1`` (columns):</span>

<span class="sd">            * &#39;expand&#39; : list-like results will be turned into columns.</span>
<span class="sd">            * &#39;reduce&#39; : returns a Series if possible rather than expanding</span>
<span class="sd">              list-like results. This is the opposite of &#39;expand&#39;.</span>
<span class="sd">            * &#39;broadcast&#39; : results will be broadcast to the original shape</span>
<span class="sd">              of the DataFrame, the original index and columns will be</span>
<span class="sd">              retained.</span>

<span class="sd">            The default behaviour (None) depends on the return value of the</span>
<span class="sd">            applied function: list-like results will be returned as a Series</span>
<span class="sd">            of those. However if the apply function returns a Series these</span>
<span class="sd">            are expanded to columns.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>

<span class="sd">        args : tuple</span>
<span class="sd">            Positional arguments to pass to `func` in addition to the</span>
<span class="sd">            array/series.</span>
<span class="sd">        **kwds</span>
<span class="sd">            Additional keyword arguments to pass as keywords arguments to</span>
<span class="sd">            `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Result of applying ``func`` along the given axis of the</span>
<span class="sd">            DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.applymap: For elementwise operations.</span>
<span class="sd">        DataFrame.aggregate: Only perform aggregating type operations.</span>
<span class="sd">        DataFrame.transform: Only perform transforming type operations.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[4, 9]] * 3, columns=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  4  9</span>
<span class="sd">        1  4  9</span>
<span class="sd">        2  4  9</span>

<span class="sd">        Using a numpy universal function (in this case the same as</span>
<span class="sd">        ``np.sqrt(df)``):</span>

<span class="sd">        &gt;&gt;&gt; df.apply(np.sqrt)</span>
<span class="sd">             A    B</span>
<span class="sd">        0  2.0  3.0</span>
<span class="sd">        1  2.0  3.0</span>
<span class="sd">        2  2.0  3.0</span>

<span class="sd">        Using a reducing function on either axis</span>

<span class="sd">        &gt;&gt;&gt; df.apply(np.sum, axis=0)</span>
<span class="sd">        A    12</span>
<span class="sd">        B    27</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.apply(np.sum, axis=1)</span>
<span class="sd">        0    13</span>
<span class="sd">        1    13</span>
<span class="sd">        2    13</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Returning a list-like will result in a Series</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1)</span>
<span class="sd">        0    [1, 2]</span>
<span class="sd">        1    [1, 2]</span>
<span class="sd">        2    [1, 2]</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Passing result_type=&#39;expand&#39; will expand list-like results</span>
<span class="sd">        to columns of a Dataframe</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1, result_type=&#39;expand&#39;)</span>
<span class="sd">           0  1</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  1  2</span>
<span class="sd">        2  1  2</span>

<span class="sd">        Returning a Series inside the function is similar to passing</span>
<span class="sd">        ``result_type=&#39;expand&#39;``. The resulting column names</span>
<span class="sd">        will be the Series index.</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: pd.Series([1, 2], index=[&#39;foo&#39;, &#39;bar&#39;]), axis=1)</span>
<span class="sd">           foo  bar</span>
<span class="sd">        0    1    2</span>
<span class="sd">        1    1    2</span>
<span class="sd">        2    1    2</span>

<span class="sd">        Passing ``result_type=&#39;broadcast&#39;`` will ensure the same shape</span>
<span class="sd">        result, whether list-like or scalar is returned by the function,</span>
<span class="sd">        and broadcast it along the axis. The resulting column names will</span>
<span class="sd">        be the originals.</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1, result_type=&#39;broadcast&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  1  2</span>
<span class="sd">        2  1  2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="n">frame_apply</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">frame_apply</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">,</span>
            <span class="n">result_type</span><span class="o">=</span><span class="n">result_type</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">kwds</span><span class="o">=</span><span class="n">kwds</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">applymap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to a Dataframe elementwise.</span>

<span class="sd">        This method applies a function that accepts and returns a scalar</span>
<span class="sd">        to every element of a DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Python function, returns a single value from a single value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Transformed DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.apply : Apply a function along input axis of DataFrame.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the current implementation applymap calls `func` twice on the</span>
<span class="sd">        first column/row to decide whether it can take a fast or slow</span>
<span class="sd">        code path. This can lead to unexpected behavior if `func` has</span>
<span class="sd">        side-effects, as they will take effect twice for the first</span>
<span class="sd">        column/row.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2.12], [3.356, 4.567]])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">               0      1</span>
<span class="sd">        0  1.000  2.120</span>
<span class="sd">        1  3.356  4.567</span>

<span class="sd">        &gt;&gt;&gt; df.applymap(lambda x: len(str(x)))</span>
<span class="sd">           0  1</span>
<span class="sd">        0  3  4</span>
<span class="sd">        1  5  5</span>

<span class="sd">        Note that a vectorized version of `func` often exists, which will</span>
<span class="sd">        be much faster. You could square each number elementwise.</span>

<span class="sd">        &gt;&gt;&gt; df.applymap(lambda x: x**2)</span>
<span class="sd">                   0          1</span>
<span class="sd">        0   1.000000   4.494400</span>
<span class="sd">        1  11.262736  20.857489</span>

<span class="sd">        But it&#39;s better to avoid applymap in that case.</span>

<span class="sd">        &gt;&gt;&gt; df ** 2</span>
<span class="sd">                   0          1</span>
<span class="sd">        0   1.000000   4.494400</span>
<span class="sd">        1  11.262736  20.857489</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if we have a dtype == &#39;M8[ns]&#39;, provide boxed values</span>
        <span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">infer</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Merging / joining methods</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append rows of `other` to the end of caller, returning a new object.</span>

<span class="sd">        Columns in `other` that are not in the caller are added as new columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame or Series/dict-like object, or list of these</span>
<span class="sd">            The data to append.</span>
<span class="sd">        ignore_index : bool, default False</span>
<span class="sd">            If True, do not use the index labels.</span>
<span class="sd">        verify_integrity : bool, default False</span>
<span class="sd">            If True, raise ValueError on creating index with duplicates.</span>
<span class="sd">        sort : bool, default False</span>
<span class="sd">            Sort columns if the columns of `self` and `other` are not aligned.</span>

<span class="sd">            .. versionadded:: 0.23.0</span>
<span class="sd">            .. versionchanged:: 1.0.0</span>

<span class="sd">                Changed to not sort by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        concat : General function to concatenate DataFrame or Series objects.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If a list of dict/series is passed and the keys are all contained in</span>
<span class="sd">        the DataFrame&#39;s index, the order of the columns in the resulting</span>
<span class="sd">        DataFrame will be unchanged.</span>

<span class="sd">        Iteratively appending rows to a DataFrame can be more computationally</span>
<span class="sd">        intensive than a single concatenate. A better solution is to append</span>
<span class="sd">        those rows to a list and then concatenate the list with the original</span>
<span class="sd">        DataFrame all at once.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], columns=list(&#39;AB&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  3  4</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list(&#39;AB&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df.append(df2)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  3  4</span>
<span class="sd">        0  5  6</span>
<span class="sd">        1  7  8</span>

<span class="sd">        With `ignore_index` set to True:</span>

<span class="sd">        &gt;&gt;&gt; df.append(df2, ignore_index=True)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  3  4</span>
<span class="sd">        2  5  6</span>
<span class="sd">        3  7  8</span>

<span class="sd">        The following, while not recommended methods for generating DataFrames,</span>
<span class="sd">        show two ways to generate a DataFrame from multiple data sources.</span>

<span class="sd">        Less efficient:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(columns=[&#39;A&#39;])</span>
<span class="sd">        &gt;&gt;&gt; for i in range(5):</span>
<span class="sd">        ...     df = df.append({&#39;A&#39;: i}, ignore_index=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A</span>
<span class="sd">        0  0</span>
<span class="sd">        1  1</span>
<span class="sd">        2  2</span>
<span class="sd">        3  3</span>
<span class="sd">        4  4</span>

<span class="sd">        More efficient:</span>

<span class="sd">        &gt;&gt;&gt; pd.concat([pd.DataFrame([i], columns=[&#39;A&#39;]) for i in range(5)],</span>
<span class="sd">        ...           ignore_index=True)</span>
<span class="sd">           A</span>
<span class="sd">        0  0</span>
<span class="sd">        1  1</span>
<span class="sd">        2  2</span>
<span class="sd">        3  3</span>
<span class="sd">        4  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only append a Series if ignore_index=True &quot;</span>
                    <span class="s2">&quot;or if the Series has a name&quot;</span>
                <span class="p">)</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">idx_diff</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">combined_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_diff</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">combined_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_diff</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">combined_columns</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
                <span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">infer_objects</span><span class="p">()</span>
                <span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">combined_columns</span><span class="p">):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">combined_columns</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">concat</span><span class="p">(</span>
            <span class="n">to_concat</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">,</span>
            <span class="n">verify_integrity</span><span class="o">=</span><span class="n">verify_integrity</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">lsuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">rsuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join columns of another DataFrame.</span>

<span class="sd">        Join columns with `other` DataFrame either on index or on a key</span>
<span class="sd">        column. Efficiently join multiple DataFrame objects by index at once by</span>
<span class="sd">        passing a list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame, Series, or list of DataFrame</span>
<span class="sd">            Index should be similar to one of the columns in this one. If a</span>
<span class="sd">            Series is passed, its name attribute must be set, and that will be</span>
<span class="sd">            used as the column name in the resulting joined DataFrame.</span>
<span class="sd">        on : str, list of str, or array-like, optional</span>
<span class="sd">            Column or index level name(s) in the caller to join on the index</span>
<span class="sd">            in `other`, otherwise joins index-on-index. If multiple</span>
<span class="sd">            values given, the `other` DataFrame must have a MultiIndex. Can</span>
<span class="sd">            pass an array as the join key if it is not already contained in</span>
<span class="sd">            the calling DataFrame. Like an Excel VLOOKUP operation.</span>
<span class="sd">        how : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;}, default &#39;left&#39;</span>
<span class="sd">            How to handle the operation of the two objects.</span>

<span class="sd">            * left: use calling frame&#39;s index (or column if on is specified)</span>
<span class="sd">            * right: use `other`&#39;s index.</span>
<span class="sd">            * outer: form union of calling frame&#39;s index (or column if on is</span>
<span class="sd">              specified) with `other`&#39;s index, and sort it.</span>
<span class="sd">              lexicographically.</span>
<span class="sd">            * inner: form intersection of calling frame&#39;s index (or column if</span>
<span class="sd">              on is specified) with `other`&#39;s index, preserving the order</span>
<span class="sd">              of the calling&#39;s one.</span>
<span class="sd">        lsuffix : str, default &#39;&#39;</span>
<span class="sd">            Suffix to use from left frame&#39;s overlapping columns.</span>
<span class="sd">        rsuffix : str, default &#39;&#39;</span>
<span class="sd">            Suffix to use from right frame&#39;s overlapping columns.</span>
<span class="sd">        sort : bool, default False</span>
<span class="sd">            Order result DataFrame lexicographically by the join key. If False,</span>
<span class="sd">            the order of the join key depends on the join type (how keyword).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A dataframe containing columns from both the caller and `other`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.merge : For column(s)-on-columns(s) operations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Parameters `on`, `lsuffix`, and `rsuffix` are not supported when</span>
<span class="sd">        passing a list of `DataFrame` objects.</span>

<span class="sd">        Support for specifying index levels as the `on` parameter was added</span>
<span class="sd">        in version 0.23.0.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;, &#39;K4&#39;, &#39;K5&#39;],</span>
<span class="sd">        ...                    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]})</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          key   A</span>
<span class="sd">        0  K0  A0</span>
<span class="sd">        1  K1  A1</span>
<span class="sd">        2  K2  A2</span>
<span class="sd">        3  K3  A3</span>
<span class="sd">        4  K4  A4</span>
<span class="sd">        5  K5  A5</span>

<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],</span>
<span class="sd">        ...                       &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;]})</span>

<span class="sd">        &gt;&gt;&gt; other</span>
<span class="sd">          key   B</span>
<span class="sd">        0  K0  B0</span>
<span class="sd">        1  K1  B1</span>
<span class="sd">        2  K2  B2</span>

<span class="sd">        Join DataFrames using their indexes.</span>

<span class="sd">        &gt;&gt;&gt; df.join(other, lsuffix=&#39;_caller&#39;, rsuffix=&#39;_other&#39;)</span>
<span class="sd">          key_caller   A key_other    B</span>
<span class="sd">        0         K0  A0        K0   B0</span>
<span class="sd">        1         K1  A1        K1   B1</span>
<span class="sd">        2         K2  A2        K2   B2</span>
<span class="sd">        3         K3  A3       NaN  NaN</span>
<span class="sd">        4         K4  A4       NaN  NaN</span>
<span class="sd">        5         K5  A5       NaN  NaN</span>

<span class="sd">        If we want to join using the key columns, we need to set key to be</span>
<span class="sd">        the index in both `df` and `other`. The joined DataFrame will have</span>
<span class="sd">        key as its index.</span>

<span class="sd">        &gt;&gt;&gt; df.set_index(&#39;key&#39;).join(other.set_index(&#39;key&#39;))</span>
<span class="sd">              A    B</span>
<span class="sd">        key</span>
<span class="sd">        K0   A0   B0</span>
<span class="sd">        K1   A1   B1</span>
<span class="sd">        K2   A2   B2</span>
<span class="sd">        K3   A3  NaN</span>
<span class="sd">        K4   A4  NaN</span>
<span class="sd">        K5   A5  NaN</span>

<span class="sd">        Another option to join using the key columns is to use the `on`</span>
<span class="sd">        parameter. DataFrame.join always uses `other`&#39;s index but we can use</span>
<span class="sd">        any column in `df`. This method preserves the original DataFrame&#39;s</span>
<span class="sd">        index in the result.</span>

<span class="sd">        &gt;&gt;&gt; df.join(other.set_index(&#39;key&#39;), on=&#39;key&#39;)</span>
<span class="sd">          key   A    B</span>
<span class="sd">        0  K0  A0   B0</span>
<span class="sd">        1  K1  A1   B1</span>
<span class="sd">        2  K2  A2   B2</span>
<span class="sd">        3  K3  A3  NaN</span>
<span class="sd">        4  K4  A4  NaN</span>
<span class="sd">        5  K5  A5  NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_compat</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">lsuffix</span><span class="o">=</span><span class="n">lsuffix</span><span class="p">,</span> <span class="n">rsuffix</span><span class="o">=</span><span class="n">rsuffix</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_join_compat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">lsuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">rsuffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">merge</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Other Series must have a name&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">({</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">other</span><span class="p">})</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">merge</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">left_on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                <span class="n">left_index</span><span class="o">=</span><span class="n">on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="n">lsuffix</span><span class="p">,</span> <span class="n">rsuffix</span><span class="p">),</span>
                <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Joining multiple DataFrames only supported for joining on index&quot;</span>
                <span class="p">)</span>

            <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">can_concat</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">)</span>

            <span class="c1"># join indexes only using concat</span>
            <span class="k">if</span> <span class="n">can_concat</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span>
                        <span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">concat</span><span class="p">(</span>
                        <span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span>
                    <span class="p">)</span>

            <span class="n">joined</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">joined</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span>
                    <span class="n">joined</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">joined</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_merge_doc</span><span class="p">,</span> <span class="n">indents</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span>
        <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">left_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">left_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">right_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_x&quot;</span><span class="p">,</span> <span class="s2">&quot;_y&quot;</span><span class="p">),</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">indicator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">validate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">merge</span>

        <span class="k">return</span> <span class="n">merge</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">right</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">left_on</span><span class="o">=</span><span class="n">left_on</span><span class="p">,</span>
            <span class="n">right_on</span><span class="o">=</span><span class="n">right_on</span><span class="p">,</span>
            <span class="n">left_index</span><span class="o">=</span><span class="n">left_index</span><span class="p">,</span>
            <span class="n">right_index</span><span class="o">=</span><span class="n">right_index</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">suffixes</span><span class="o">=</span><span class="n">suffixes</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">indicator</span><span class="o">=</span><span class="n">indicator</span><span class="p">,</span>
            <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Round a DataFrame to a variable number of decimal places.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decimals : int, dict, Series</span>
<span class="sd">            Number of decimal places to round each column to. If an int is</span>
<span class="sd">            given, round each column to the same number of places.</span>
<span class="sd">            Otherwise dict and Series round to variable numbers of places.</span>
<span class="sd">            Column names should be in the keys if `decimals` is a</span>
<span class="sd">            dict-like, or in the index if `decimals` is a Series. Any</span>
<span class="sd">            columns not included in `decimals` will be left as is. Elements</span>
<span class="sd">            of `decimals` which are not columns of the input will be</span>
<span class="sd">            ignored.</span>
<span class="sd">        *args</span>
<span class="sd">            Additional keywords have no effect but might be accepted for</span>
<span class="sd">            compatibility with numpy.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keywords have no effect but might be accepted for</span>
<span class="sd">            compatibility with numpy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A DataFrame with the affected columns rounded to the specified</span>
<span class="sd">            number of decimal places.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.around : Round a numpy array to the given number of decimals.</span>
<span class="sd">        Series.round : Round a Series to the given number of decimals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(.21, .32), (.01, .67), (.66, .03), (.21, .18)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0  0.21  0.32</span>
<span class="sd">        1  0.01  0.67</span>
<span class="sd">        2  0.66  0.03</span>
<span class="sd">        3  0.21  0.18</span>

<span class="sd">        By providing an integer each column is rounded to the same number</span>
<span class="sd">        of decimal places</span>

<span class="sd">        &gt;&gt;&gt; df.round(1)</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0   0.2   0.3</span>
<span class="sd">        1   0.0   0.7</span>
<span class="sd">        2   0.7   0.0</span>
<span class="sd">        3   0.2   0.2</span>

<span class="sd">        With a dict, the number of places for specific columns can be</span>
<span class="sd">        specified with the column names as key and the number of decimal</span>
<span class="sd">        places as value</span>

<span class="sd">        &gt;&gt;&gt; df.round({&#39;dogs&#39;: 1, &#39;cats&#39;: 0})</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0   0.2   0.0</span>
<span class="sd">        1   0.0   1.0</span>
<span class="sd">        2   0.7   0.0</span>
<span class="sd">        3   0.2   0.0</span>

<span class="sd">        Using a Series, the number of places for specific columns can be</span>
<span class="sd">        specified with the column names as index and the number of</span>
<span class="sd">        decimal places as value</span>

<span class="sd">        &gt;&gt;&gt; decimals = pd.Series([0, 1], index=[&#39;cats&#39;, &#39;dogs&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.round(decimals)</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0   0.2   0.0</span>
<span class="sd">        1   0.0   1.0</span>
<span class="sd">        2   0.7   0.0</span>
<span class="sd">        3   0.2   0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="k">def</span> <span class="nf">_dict_round</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">decimals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">_series_round</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">decimals</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">vals</span>

        <span class="k">def</span> <span class="nf">_series_round</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">decimals</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="n">nv</span><span class="o">.</span><span class="n">validate_round</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">decimals</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index of decimals must be unique&quot;</span><span class="p">)</span>
            <span class="n">new_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_dict_round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">decimals</span><span class="p">):</span>
            <span class="c1"># Dispatch to Series.round</span>
            <span class="n">new_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">_series_round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;decimals must be an integer, a dict-like or a Series&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">concat</span><span class="p">(</span><span class="n">new_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Statistical methods, etc.</span>

    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pearson&quot;</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute pairwise correlation of columns, excluding NA/null values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;pearson&#39;, &#39;kendall&#39;, &#39;spearman&#39;} or callable</span>
<span class="sd">            Method of correlation:</span>

<span class="sd">            * pearson : standard correlation coefficient</span>
<span class="sd">            * kendall : Kendall Tau correlation coefficient</span>
<span class="sd">            * spearman : Spearman rank correlation</span>
<span class="sd">            * callable: callable with input two 1d ndarrays</span>
<span class="sd">                and returning a float. Note that the returned matrix from corr</span>
<span class="sd">                will have 1 along the diagonals and will be symmetric</span>
<span class="sd">                regardless of the callable&#39;s behavior.</span>

<span class="sd">                .. versionadded:: 0.24.0</span>

<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations required per pair of columns</span>
<span class="sd">            to have a valid result. Currently only available for Pearson</span>
<span class="sd">            and Spearman correlation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Correlation matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.corrwith</span>
<span class="sd">        Series.corr</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; def histogram_intersection(a, b):</span>
<span class="sd">        ...     v = np.minimum(a, b).sum().round(decimals=1)</span>
<span class="sd">        ...     return v</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.corr(method=histogram_intersection)</span>
<span class="sd">              dogs  cats</span>
<span class="sd">        dogs   1.0   0.3</span>
<span class="sd">        cats   0.3   1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numeric_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">numeric_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">numeric_df</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span>
            <span class="n">correl</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">ensure_float64</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="n">minp</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;spearman&quot;</span><span class="p">:</span>
            <span class="n">correl</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">nancorr_spearman</span><span class="p">(</span><span class="n">ensure_float64</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="n">minp</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kendall&quot;</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">ensure_float64</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">corrf</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">get_corr_func</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">correl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">valid</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_periods</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">valid</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">corrf</span><span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">bc</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">corrf</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
                    <span class="n">correl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">correl</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;method must be either &#39;pearson&#39;, &quot;</span>
                <span class="s2">&quot;&#39;spearman&#39;, &#39;kendall&#39;, or a callable, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; was supplied&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">correl</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute pairwise covariance of columns, excluding NA/null values.</span>

<span class="sd">        Compute the pairwise covariance among the series of a DataFrame.</span>
<span class="sd">        The returned data frame is the `covariance matrix</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Covariance_matrix&gt;`__ of the columns</span>
<span class="sd">        of the DataFrame.</span>

<span class="sd">        Both NA and null values are automatically excluded from the</span>
<span class="sd">        calculation. (See the note below about bias from missing values.)</span>
<span class="sd">        A threshold can be set for the minimum number of</span>
<span class="sd">        observations for each value created. Comparisons with observations</span>
<span class="sd">        below this threshold will be returned as ``NaN``.</span>

<span class="sd">        This method is generally used for the analysis of time series data to</span>
<span class="sd">        understand the relationship between different measures</span>
<span class="sd">        across time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations required per pair of columns</span>
<span class="sd">            to have a valid result.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The covariance matrix of the series of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.cov : Compute covariance with another Series.</span>
<span class="sd">        core.window.EWM.cov: Exponential weighted sample covariance.</span>
<span class="sd">        core.window.Expanding.cov : Expanding sample covariance.</span>
<span class="sd">        core.window.Rolling.cov : Rolling sample covariance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Returns the covariance matrix of the DataFrame&#39;s time series.</span>
<span class="sd">        The covariance is normalized by N-1.</span>

<span class="sd">        For DataFrames that have Series that are missing data (assuming that</span>
<span class="sd">        data is `missing at random</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Missing_data#Missing_at_random&gt;`__)</span>
<span class="sd">        the returned covariance matrix will be an unbiased estimate</span>
<span class="sd">        of the variance and covariance between the member Series.</span>

<span class="sd">        However, for many applications this estimate may not be acceptable</span>
<span class="sd">        because the estimate covariance matrix is not guaranteed to be positive</span>
<span class="sd">        semi-definite. This could lead to estimate correlations having</span>
<span class="sd">        absolute values which are greater than one, and/or a non-invertible</span>
<span class="sd">        covariance matrix. See `Estimation of covariance matrices</span>
<span class="sd">        &lt;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_</span>
<span class="sd">        matrices&gt;`__ for more details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(1, 2), (0, 3), (2, 0), (1, 1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.cov()</span>
<span class="sd">                  dogs      cats</span>
<span class="sd">        dogs  0.666667 -1.000000</span>
<span class="sd">        cats -1.000000  1.666667</span>

<span class="sd">        &gt;&gt;&gt; np.random.seed(42)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.random.randn(1000, 5),</span>
<span class="sd">        ...                   columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.cov()</span>
<span class="sd">                  a         b         c         d         e</span>
<span class="sd">        a  0.998438 -0.020161  0.059277 -0.008943  0.014144</span>
<span class="sd">        b -0.020161  1.059352 -0.008543 -0.024738  0.009826</span>
<span class="sd">        c  0.059277 -0.008543  1.010670 -0.001486 -0.000271</span>
<span class="sd">        d -0.008943 -0.024738 -0.001486  0.921297 -0.013692</span>
<span class="sd">        e  0.014144  0.009826 -0.000271 -0.013692  0.977795</span>

<span class="sd">        **Minimum number of periods**</span>

<span class="sd">        This method also supports an optional ``min_periods`` keyword</span>
<span class="sd">        that specifies the required minimum number of non-NA observations for</span>
<span class="sd">        each column pair in order to have a valid result:</span>

<span class="sd">        &gt;&gt;&gt; np.random.seed(42)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.random.randn(20, 3),</span>
<span class="sd">        ...                   columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.loc[df.index[:5], &#39;a&#39;] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; df.loc[df.index[5:10], &#39;b&#39;] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; df.cov(min_periods=12)</span>
<span class="sd">                  a         b         c</span>
<span class="sd">        a  0.316741       NaN -0.150812</span>
<span class="sd">        b       NaN  1.248003  0.191417</span>
<span class="sd">        c -0.150812  0.191417  0.895202</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numeric_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">numeric_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">numeric_df</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="n">notna</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_periods</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
                <span class="n">baseCov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">baseCov</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">baseCov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">baseCov</span> <span class="o">=</span> <span class="n">baseCov</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">baseCov</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">ensure_float64</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minp</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">baseCov</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">corrwith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;pearson&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute pairwise correlation.</span>

<span class="sd">        Pairwise correlation is computed between rows or columns of</span>
<span class="sd">        DataFrame with rows or columns of Series or DataFrame. DataFrames</span>
<span class="sd">        are first aligned along both axes before computing the</span>
<span class="sd">        correlations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame, Series</span>
<span class="sd">            Object with which to compute correlations.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; to compute column-wise, 1 or &#39;columns&#39; for</span>
<span class="sd">            row-wise.</span>
<span class="sd">        drop : bool, default False</span>
<span class="sd">            Drop missing indices from result.</span>
<span class="sd">        method : {&#39;pearson&#39;, &#39;kendall&#39;, &#39;spearman&#39;} or callable</span>
<span class="sd">            Method of correlation:</span>

<span class="sd">            * pearson : standard correlation coefficient</span>
<span class="sd">            * kendall : Kendall Tau correlation coefficient</span>
<span class="sd">            * spearman : Spearman rank correlation</span>
<span class="sd">            * callable: callable with input two 1d ndarrays</span>
<span class="sd">                and returning a float.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Pairwise correlations.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.corr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">T</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span>
            <span class="c1"># mask missing values</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span> <span class="o">+</span> <span class="n">left</span> <span class="o">*</span> <span class="mi">0</span>

            <span class="c1"># demeaned data</span>
            <span class="n">ldem</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">rdem</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">right</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">ldem</span> <span class="o">*</span> <span class="n">rdem</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">left</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">right</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

            <span class="n">correl</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">dom</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;kendall&quot;</span><span class="p">,</span> <span class="s2">&quot;spearman&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

            <span class="n">correl</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> was passed, &quot;</span>
                <span class="s2">&quot;valid methods are: &#39;pearson&#39;, &#39;kendall&#39;, &quot;</span>
                <span class="s2">&quot;&#39;spearman&#39;, or callable&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">drop</span><span class="p">:</span>
            <span class="c1"># Find non-matching labels along the given axis</span>
            <span class="c1"># and append missing correlations (GH 22375)</span>
            <span class="n">raxis</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">result_index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">raxis</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">raxis</span><span class="p">))</span>
            <span class="n">idx_diff</span> <span class="o">=</span> <span class="n">result_index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">correl</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">correl</span> <span class="o">=</span> <span class="n">correl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_diff</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">idx_diff</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">correl</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># ndarray-like stats methods</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count non-NA cells for each column or row.</span>

<span class="sd">        The values `None`, `NaN`, `NaT`, and optionally `numpy.inf` (depending</span>
<span class="sd">        on `pandas.options.mode.use_inf_as_na`) are considered NA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            If 0 or &#39;index&#39; counts are generated for each column.</span>
<span class="sd">            If 1 or &#39;columns&#39; counts are generated for each **row**.</span>
<span class="sd">        level : int or str, optional</span>
<span class="sd">            If the axis is a `MultiIndex` (hierarchical), count along a</span>
<span class="sd">            particular `level`, collapsing into a `DataFrame`.</span>
<span class="sd">            A `str` specifies the level name.</span>
<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            For each column/row the number of non-NA/null entries.</span>
<span class="sd">            If `level` is specified returns a `DataFrame`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.count: Number of non-NA elements in a Series.</span>
<span class="sd">        DataFrame.shape: Number of DataFrame rows and columns (including NA</span>
<span class="sd">            elements).</span>
<span class="sd">        DataFrame.isna: Boolean same-sized DataFrame showing places of NA</span>
<span class="sd">            elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Constructing DataFrame from a dictionary:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;Person&quot;:</span>
<span class="sd">        ...                    [&quot;John&quot;, &quot;Myla&quot;, &quot;Lewis&quot;, &quot;John&quot;, &quot;Myla&quot;],</span>
<span class="sd">        ...                    &quot;Age&quot;: [24., np.nan, 21., 33, 26],</span>
<span class="sd">        ...                    &quot;Single&quot;: [False, True, True, True, False]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           Person   Age  Single</span>
<span class="sd">        0    John  24.0   False</span>
<span class="sd">        1    Myla   NaN    True</span>
<span class="sd">        2   Lewis  21.0    True</span>
<span class="sd">        3    John  33.0    True</span>
<span class="sd">        4    Myla  26.0   False</span>

<span class="sd">        Notice the uncounted NA values:</span>

<span class="sd">        &gt;&gt;&gt; df.count()</span>
<span class="sd">        Person    5</span>
<span class="sd">        Age       4</span>
<span class="sd">        Single    5</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Counts for each **row**:</span>

<span class="sd">        &gt;&gt;&gt; df.count(axis=&#39;columns&#39;)</span>
<span class="sd">        0    3</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    3</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Counts for one level of a `MultiIndex`:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index([&quot;Person&quot;, &quot;Single&quot;]).count(level=&quot;Person&quot;)</span>
<span class="sd">                Age</span>
<span class="sd">        Person</span>
<span class="sd">        John      2</span>
<span class="sd">        Lewis     1</span>
<span class="sd">        Myla      1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_level</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># GH #423</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">or</span> <span class="n">frame</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">any_extension_types</span><span class="p">:</span>
                <span class="c1"># the or any_extension_types is really only hit for single-</span>
                <span class="c1"># column frames with an extension array</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># GH13407</span>
                <span class="n">series_counts</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="n">series_counts</span><span class="o">.</span><span class="n">values</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_count_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">count_axis</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">agg_axis</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">count_axis</span><span class="p">,</span> <span class="n">ABCMultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can only count levels on hierarchical </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
            <span class="c1"># Since we have mixed types, calling notna(frame.values) might</span>
            <span class="c1"># upcast everything to object</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># But use the speedup when we have homogeneous dtypes</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We&#39;re transposing the mask rather than frame to avoid potential</span>
            <span class="c1"># upcasts to object, which induces a ~20x slowdown</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">count_axis</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="n">level_name</span> <span class="o">=</span> <span class="n">count_axis</span><span class="o">.</span><span class="n">_names</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="n">level_index</span> <span class="o">=</span> <span class="n">count_axis</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">.</span><span class="n">_shallow_copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">level_name</span><span class="p">)</span>
        <span class="n">level_codes</span> <span class="o">=</span> <span class="n">ensure_int64</span><span class="p">(</span><span class="n">count_axis</span><span class="o">.</span><span class="n">codes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">count_level_2d</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">level_codes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">level_index</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">level_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Undo our earlier transpose</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Make other agg func handle axis=None properly</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="n">axis_matters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;numeric&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">axis_matters</span><span class="p">:</span>
                    <span class="c1"># GH#25101, GH#24434</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bool_data</span><span class="p">()</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bool_data</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Generating numeric_only data with filter_type </span><span class="si">{</span><span class="n">filter_type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;not supported.&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="k">if</span> <span class="n">numeric_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">numeric_only</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">_get_data</span><span class="p">(</span><span class="n">axis_matters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">out_dtype</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span> <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="c1"># After possibly _get_data and transposing, we are now in the</span>
            <span class="c1">#  simple case where we can use BlockManager._reduce</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">out_dtype</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">if</span> <span class="n">numeric_only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span> <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">and</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># work around https://github.com/numpy/numpy/issues/10489</span>
                    <span class="c1"># TODO: combine with hasattr(result, &#39;dtype&#39;) further down</span>
                    <span class="c1"># hard since we don&#39;t have `values` down there.</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># e.g. in nanops trying to convert strs to float</span>

                <span class="c1"># try by-column first</span>
                <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># this can end up with a non-reduction</span>
                    <span class="c1"># but not always. if the types are mixed</span>
                    <span class="c1"># with datelike then need to make sure a series</span>

                    <span class="c1"># we only end up here if we have not specified</span>
                    <span class="c1"># numeric_only and yet we have tried a</span>
                    <span class="c1"># column-by-column reduction, where we have mixed type.</span>
                    <span class="c1"># So let&#39;s just do what we can</span>
                    <span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="n">frame_apply</span>

                    <span class="n">opa</span> <span class="o">=</span> <span class="n">frame_apply</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">result_type</span><span class="o">=</span><span class="s2">&quot;expand&quot;</span><span class="p">,</span> <span class="n">ignore_failures</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">opa</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">result</span>

                <span class="c1"># TODO: why doesnt axis matter here?</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_get_data</span><span class="p">(</span><span class="n">axis_matters</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_get_data</span><span class="p">(</span><span class="n">axis_matters</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;numeric&quot;</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span> <span class="ow">and</span> <span class="n">notna</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>

                <span class="c1"># try to coerce to the original dtypes item by item if we can</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">coerce_to_dtypes</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">constructor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">nunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count distinct observations over requested axis.</span>

<span class="sd">        Return Series with number of distinct observations. Can ignore NaN</span>
<span class="sd">        values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for</span>
<span class="sd">            column-wise.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don&#39;t include NaN in the counts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.nunique: Method nunique for Series.</span>
<span class="sd">        DataFrame.count: Count non-NA cells for each column or row.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3], &#39;B&#39;: [1, 1, 1]})</span>
<span class="sd">        &gt;&gt;&gt; df.nunique()</span>
<span class="sd">        A    3</span>
<span class="sd">        B    1</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.nunique(axis=1)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    2</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">nunique</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index of first occurrence of minimum over requested axis.</span>

<span class="sd">        NA/null values are excluded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for column-wise.</span>
<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="sd">            will be NA.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Indexes of minima along the specified axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If the row/column is empty</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.idxmin</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the DataFrame version of ``ndarray.argmin``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index of first occurrence of maximum over requested axis.</span>

<span class="sd">        NA/null values are excluded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for column-wise.</span>
<span class="sd">        skipna : bool, default True</span>
<span class="sd">            Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="sd">            will be NA.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Indexes of maxima along the specified axis.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If the row/column is empty</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.idxmax</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is the DataFrame version of ``ndarray.argmax``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_agg_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Let&#39;s be explicit about this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">elif</span> <span class="n">axis_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axis must be 0 or 1 (got </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">axis_num</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the mode(s) of each element along the selected axis.</span>

<span class="sd">        The mode of a set of values is the value that appears most often.</span>
<span class="sd">        It can be multiple values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to iterate over while searching for the mode:</span>

<span class="sd">            * 0 or &#39;index&#39; : get mode of each column</span>
<span class="sd">            * 1 or &#39;columns&#39; : get mode of each row.</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            If True, only apply to numeric columns.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don&#39;t consider counts of NaN/NaT.</span>

<span class="sd">            .. versionadded:: 0.24.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The modes of each column or row.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.mode : Return the highest frequency value in a Series.</span>
<span class="sd">        Series.value_counts : Return the counts of values in a Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;bird&#39;, 2, 2),</span>
<span class="sd">        ...                    (&#39;mammal&#39;, 4, np.nan),</span>
<span class="sd">        ...                    (&#39;arthropod&#39;, 8, 0),</span>
<span class="sd">        ...                    (&#39;bird&#39;, 2, np.nan)],</span>
<span class="sd">        ...                   index=(&#39;falcon&#39;, &#39;horse&#39;, &#39;spider&#39;, &#39;ostrich&#39;),</span>
<span class="sd">        ...                   columns=(&#39;species&#39;, &#39;legs&#39;, &#39;wings&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                   species  legs  wings</span>
<span class="sd">        falcon        bird     2    2.0</span>
<span class="sd">        horse       mammal     4    NaN</span>
<span class="sd">        spider   arthropod     8    0.0</span>
<span class="sd">        ostrich       bird     2    NaN</span>

<span class="sd">        By default, missing values are not considered, and the mode of wings</span>
<span class="sd">        are both 0 and 2. The second row of species and legs contains ``NaN``,</span>
<span class="sd">        because they have only one mode, but the DataFrame has two rows.</span>

<span class="sd">        &gt;&gt;&gt; df.mode()</span>
<span class="sd">          species  legs  wings</span>
<span class="sd">        0    bird   2.0    0.0</span>
<span class="sd">        1     NaN   NaN    2.0</span>

<span class="sd">        Setting ``dropna=False`` ``NaN`` values are considered and they can be</span>
<span class="sd">        the mode (like for wings).</span>

<span class="sd">        &gt;&gt;&gt; df.mode(dropna=False)</span>
<span class="sd">          species  legs  wings</span>
<span class="sd">        0    bird     2    NaN</span>

<span class="sd">        Setting ``numeric_only=True``, only the mode of numeric columns is</span>
<span class="sd">        computed, and columns of other types are ignored.</span>

<span class="sd">        &gt;&gt;&gt; df.mode(numeric_only=True)</span>
<span class="sd">           legs  wings</span>
<span class="sd">        0   2.0    0.0</span>
<span class="sd">        1   NaN    2.0</span>

<span class="sd">        To compute the mode over columns and not rows, use the axis parameter:</span>

<span class="sd">        &gt;&gt;&gt; df.mode(axis=&#39;columns&#39;, numeric_only=True)</span>
<span class="sd">                   0    1</span>
<span class="sd">        falcon   2.0  NaN</span>
<span class="sd">        horse    4.0  NaN</span>
<span class="sd">        spider   0.0  8.0</span>
<span class="sd">        ostrich  2.0  NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return values at the given quantile over requested axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float or array-like, default 0.5 (50% quantile)</span>
<span class="sd">            Value between 0 &lt;= q &lt;= 1, the quantile(s) to compute.</span>
<span class="sd">        axis : {0, 1, &#39;index&#39;, &#39;columns&#39;} (default 0)</span>
<span class="sd">            Equals 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for column-wise.</span>
<span class="sd">        numeric_only : bool, default True</span>
<span class="sd">            If False, the quantile of datetime and timedelta data will be</span>
<span class="sd">            computed as well.</span>
<span class="sd">        interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">            This optional parameter specifies the interpolation method to use,</span>
<span class="sd">            when the desired quantile lies between two data points `i` and `j`:</span>

<span class="sd">            * linear: `i + (j - i) * fraction`, where `fraction` is the</span>
<span class="sd">              fractional part of the index surrounded by `i` and `j`.</span>
<span class="sd">            * lower: `i`.</span>
<span class="sd">            * higher: `j`.</span>
<span class="sd">            * nearest: `i` or `j` whichever is nearest.</span>
<span class="sd">            * midpoint: (`i` + `j`) / 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">            If ``q`` is an array, a DataFrame will be returned where the</span>
<span class="sd">              index is ``q``, the columns are the columns of self, and the</span>
<span class="sd">              values are the quantiles.</span>
<span class="sd">            If ``q`` is a float, a Series will be returned where the</span>
<span class="sd">              index is the columns of self and the values are the quantiles.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        core.window.Rolling.quantile: Rolling quantile.</span>
<span class="sd">        numpy.percentile: Numpy function to compute the percentile.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.array([[1, 1], [2, 10], [3, 100], [4, 100]]),</span>
<span class="sd">        ...                   columns=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.quantile(.1)</span>
<span class="sd">        a    1.3</span>
<span class="sd">        b    3.7</span>
<span class="sd">        Name: 0.1, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; df.quantile([.1, .5])</span>
<span class="sd">               a     b</span>
<span class="sd">        0.1  1.3   3.7</span>
<span class="sd">        0.5  2.5  55.0</span>

<span class="sd">        Specifying `numeric_only=False` will also compute the quantile of</span>
<span class="sd">        datetime and timedelta data.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2],</span>
<span class="sd">        ...                    &#39;B&#39;: [pd.Timestamp(&#39;2010&#39;),</span>
<span class="sd">        ...                          pd.Timestamp(&#39;2011&#39;)],</span>
<span class="sd">        ...                    &#39;C&#39;: [pd.Timedelta(&#39;1 days&#39;),</span>
<span class="sd">        ...                          pd.Timedelta(&#39;2 days&#39;)]})</span>
<span class="sd">        &gt;&gt;&gt; df.quantile(0.5, numeric_only=False)</span>
<span class="sd">        A                    1.5</span>
<span class="sd">        B    2010-07-02 12:00:00</span>
<span class="sd">        C        1 days 12:00:00</span>
<span class="sd">        Name: 0.5, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_percentile</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span> <span class="k">if</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">is_transposed</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">is_transposed</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># GH#23925 _get_numeric_data may have dropped all columns</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">([],</span> <span class="n">index</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">([],</span> <span class="n">index</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
            <span class="n">qs</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span> <span class="n">transposed</span><span class="o">=</span><span class="n">is_transposed</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_transposed</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">to_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to DatetimeIndex of timestamps, at *beginning* of period.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : str, default frequency of PeriodIndex</span>
<span class="sd">            Desired frequency.</span>
<span class="sd">        how : {&#39;s&#39;, &#39;e&#39;, &#39;start&#39;, &#39;end&#39;}</span>
<span class="sd">            Convention for converting period to timestamp; start of period</span>
<span class="sd">            vs. end.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to convert (the index by default).</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            If False then underlying input data is not copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame with DatetimeIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axis must be 0 or 1. Got </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert DataFrame from DatetimeIndex to PeriodIndex.</span>

<span class="sd">        Convert DataFrame from DatetimeIndex to PeriodIndex with desired</span>
<span class="sd">        frequency (inferred from index if not passed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : str, default</span>
<span class="sd">            Frequency of the PeriodIndex.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to convert (the index by default).</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            If False then underlying input data is not copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeSeries with PeriodIndex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axis must be 0 or 1. Got </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether each element in the DataFrame is contained in values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : iterable, Series, DataFrame or dict</span>
<span class="sd">            The result will only be true at a location if all the</span>
<span class="sd">            labels match. If `values` is a Series, that&#39;s the index. If</span>
<span class="sd">            `values` is a dict, the keys must be the column names,</span>
<span class="sd">            which must match. If `values` is a DataFrame,</span>
<span class="sd">            then both the index and column labels must match.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame of booleans showing whether each element in the DataFrame</span>
<span class="sd">            is contained in values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.eq: Equality test for DataFrame.</span>
<span class="sd">        Series.isin: Equivalent method on Series.</span>
<span class="sd">        Series.str.contains: Test if pattern or regex is contained within a</span>
<span class="sd">            string of a Series or Index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [2, 4], &#39;num_wings&#39;: [2, 0]},</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;dog&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon         2          2</span>
<span class="sd">        dog            4          0</span>

<span class="sd">        When ``values`` is a list check whether every value in the DataFrame</span>
<span class="sd">        is present in the list (which animals have 0 or 2 legs or wings)</span>

<span class="sd">        &gt;&gt;&gt; df.isin([0, 2])</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon      True       True</span>
<span class="sd">        dog        False       True</span>

<span class="sd">        When ``values`` is a dict, we can pass values to check for each</span>
<span class="sd">        column separately:</span>

<span class="sd">        &gt;&gt;&gt; df.isin({&#39;num_wings&#39;: [0, 3]})</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon     False      False</span>
<span class="sd">        dog        False       True</span>

<span class="sd">        When ``values`` is a Series or DataFrame the index and column must</span>
<span class="sd">        match. Note that &#39;falcon&#39; does not match based on the number of legs</span>
<span class="sd">        in df2.</span>

<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame({&#39;num_legs&#39;: [8, 2], &#39;num_wings&#39;: [0, 2]},</span>
<span class="sd">        ...                      index=[&#39;spider&#39;, &#39;falcon&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.isin(other)</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon      True       True</span>
<span class="sd">        dog        False      False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">concat</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot compute isin with a duplicate axis.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot compute isin with a duplicate axis.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;only list-like or dict-like objects are allowed &quot;</span>
                    <span class="s2">&quot;to be passed to DataFrame.isin(), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;you passed a </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
                <span class="n">algorithms</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Add plotting methods to DataFrame</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">PlotAccessor</span><span class="p">)</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">hist_frame</span>
    <span class="n">boxplot</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">boxplot_frame</span>
    <span class="n">sparse</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="n">SparseFrameAccessor</span><span class="p">)</span>


<span class="n">DataFrame</span><span class="o">.</span><span class="n">_setup_axes</span><span class="p">(</span>
    <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">],</span>
    <span class="n">docs</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;The index (row labels) of the DataFrame.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="s2">&quot;The column labels of the DataFrame.&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">)</span>
<span class="n">DataFrame</span><span class="o">.</span><span class="n">_add_numeric_operations</span><span class="p">()</span>
<span class="n">DataFrame</span><span class="o">.</span><span class="n">_add_series_or_dataframe_operations</span><span class="p">()</span>

<span class="n">ops</span><span class="o">.</span><span class="n">add_flex_arithmetic_methods</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">)</span>
<span class="n">ops</span><span class="o">.</span><span class="n">add_special_arithmetic_methods</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_from_nested_dict</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="c1"># TODO: this should be seriously cythonized</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">new_data</span>


<span class="k">def</span> <span class="nf">_put_str</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)[:</span><span class="n">space</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Benjamin Ries, Stephanie Linker, David Hahn. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.3

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>